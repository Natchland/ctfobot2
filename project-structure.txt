====================================
PROJECT STRUCTURE AND CONTENTS
====================================

PROJECT STRUCTURE:
==================
├── .gitignore
├── ctfobot2_0.py
├── db.py
├── nixpacks.toml
├── railway.json
├── requirements.txt
├── web.py
├── cogs/
│   ├── cleanup.py
│   ├── codes.py
│   ├── feedback.py
│   ├── member_forms.py
│   ├── recruit_reminder.py
│   ├── staff_applications.py
│   ├── stats.py
│   ├── steam_sync.py
│   ├── welcome_general.py
│   └── xp.py
├── static/
│   └── css/
│       └── style.css
└── templates/
    ├── admin.html
    ├── base.html
    ├── login.html
    ├── signup.html
    ├── welcome.html
    └── partials/
        └── admin_codes.html

FILE CONTENTS:
==============

FILE: cogs\cleanup.py
----------------------------------------
# cogs/cleanup.py
import discord
from discord.ext import commands

class CleanupCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="cleanchannel")
    @commands.has_permissions(administrator=True)
    @commands.bot_has_permissions(manage_messages=True)
    async def clean_channel(self, ctx, limit: int = 100):
        """Delete all non-pinned messages in the current channel (Admin only)"""
        if limit <= 0 or limit > 10000:
            return await ctx.send("Please provide a limit between 1 and 10,000 messages.", ephemeral=True)
            
        await ctx.send(f"Starting cleanup of up to {limit} messages... This may take a while.", ephemeral=True)
        
        deleted_count = 0
        failed_count = 0
        processed = 0
        
        # Create progress embed
        progress_embed = discord.Embed(
            title="Channel Cleanup Progress",
            description=f"Processed: {processed} | Deleted: {deleted_count} | Failed: {failed_count}",
            color=discord.Color.orange()
        )
        progress_msg = await ctx.channel.send(embed=progress_embed)
        
        # Get messages in batches of 100 (Discord API limit)
        while deleted_count + failed_count < limit:
            try:
                messages = []
                async for message in ctx.channel.history(limit=100):
                    # Skip pinned messages
                    if not message.pinned:
                        messages.append(message)
                        
                if not messages:
                    break
                    
                # Limit to remaining needed deletions
                remaining = limit - (deleted_count + failed_count)
                messages = messages[:remaining]
                
                # Delete messages
                try:
                    deleted = await ctx.channel.delete_messages(messages)
                    deleted_count += len(deleted)
                except discord.HTTPException:
                    # If bulk delete fails, try deleting individually
                    for message in messages:
                        try:
                            await message.delete()
                            deleted_count += 1
                        except discord.HTTPException:
                            failed_count += 1
                            
                processed += len(messages)
                
                # Update progress
                progress_embed.description = f"Processed: {processed} | Deleted: {deleted_count} | Failed: {failed_count}"
                await progress_msg.edit(embed=progress_embed)
                
                # If we got less than 100 messages, we've reached the end
                if len(messages) < 100:
                    break
                    
            except discord.HTTPException as e:
                failed_count += 1
                
        # Final update
        final_embed = discord.Embed(
            title="Channel Cleanup Complete",
            description=f"Processed: {processed} | Deleted: {deleted_count} | Failed: {failed_count}",
            color=discord.Color.green() if failed_count == 0 else discord.Color.red()
        )
        await progress_msg.edit(embed=final_embed)
        
        # Send summary to command user
        await ctx.send(
            f"Channel cleanup complete!\n"
            f"Processed: {processed} messages\n"
            f"Deleted: {deleted_count} messages\n"
            f"Failed: {failed_count} messages",
            ephemeral=True
        )

async def setup(bot):
    await bot.add_cog(CleanupCog(bot))


FILE: cogs\codes.py
----------------------------------------
# cogs/codes.py
# ────────────────────────────────────────────────────────────────────
#   Access-Code system  –  /codes slash-commands + single embed
# ────────────────────────────────────────────────────────────────────
from __future__ import annotations

import os
import asyncio
import contextlib
from datetime import datetime, timezone
from typing import Dict, Optional

import asyncpg
import discord
from discord import app_commands
from discord.ext import commands

# ═════════════════════ CONFIG ═════════════════════
CODES_CH_ID  = 1398667158237483138                 # channel that holds the embed
STORE_PATH   = "/data/codes_msg_id.txt"            # remembers embed message-id
DATABASE_URL = os.getenv("DATABASE_URL")           # for LISTEN codes_changed
# ══════════════════════════════════════════════════


# ───────────────────────── Embed builder ─────────────────────────
def _build_embed(codes: Dict[str, tuple[str, bool]]) -> discord.Embed:
    e = discord.Embed(
        title="🔑 Access Codes",
        description="Codes with 🔒 are **private** (hidden from `/codes list`).",
        colour=discord.Color.blue(),
        timestamp=datetime.now(timezone.utc),
    )
    if not codes:
        e.description += "\n\n*No codes configured yet.*"
    else:
        for name, (pin, public) in codes.items():
            lock = "" if public else " 🔒"
            e.add_field(name=f"{name}{lock}", value=f"`{pin}`", inline=False)
    return e


# ═════════════════════ COG ═══════════════════════
class CodesCog(commands.Cog):
    """/codes command group, single embed upkeep, Postgres listener."""

    # group is auto-registered when cog is injected
    codes_group = app_commands.Group(name="codes", description="Manage / view access codes")

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._lock = asyncio.Lock()
        self._listener_task: Optional[asyncio.Task] = None
        self._ready = False                        # run on_ready once

    # ─────────────── CLEAN-UP ───────────────
    async def cog_unload(self):
        if self._listener_task:
            self._listener_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._listener_task

    # ─────────────── AFTER LOGIN ───────────────
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready:
            return
        self._ready = True

        # wait until the core bot has created the asyncpg pool
        while self.db.pool is None:
            await asyncio.sleep(0.5)

        await self._refresh_embed()
        self._listener_task = asyncio.create_task(self._listen_pg())

    # ═════════════════ UTILITIES ════════════════
    async def _channel(self) -> Optional[discord.TextChannel]:
        ch = self.bot.get_channel(CODES_CH_ID)
        return ch if isinstance(ch, discord.TextChannel) else None

    @staticmethod
    def _valid_pin(pin: str) -> bool:
        return pin.isdigit() and len(pin) == 4

    async def _is_staff(self, i: discord.Interaction) -> bool:
        reviewers = await self.db.get_reviewers()
        return i.user.guild_permissions.administrator or i.user.id in reviewers

    # ═════════════ EMBED REFRESH ═══════════════
    async def _refresh_embed(self):
        async with self._lock:                     # debounce
            try:
                ch = await self._channel()
                if ch is None:
                    print("[codes] Codes channel not found!")
                    return

                # ----- find existing embed -----
                msg: Optional[discord.Message] = None
                if os.path.exists(STORE_PATH):
                    try:
                        mid = int(open(STORE_PATH).read())
                        msg = await ch.fetch_message(mid)
                    except (ValueError, discord.NotFound, discord.HTTPException):
                        msg = None
                if msg is None:
                    async for m in ch.history(limit=50):
                        if (m.author == self.bot.user
                                and m.embeds
                                and m.embeds[0].title.startswith("🔑 Access Codes")):
                            msg = m
                            break

                embed = _build_embed(await self.db.get_codes())

                if msg:
                    await msg.edit(embed=embed)
                    mid = msg.id
                else:
                    msg = await ch.send(embed=embed)
                    mid = msg.id

                os.makedirs(os.path.dirname(STORE_PATH), exist_ok=True)
                with open(STORE_PATH, "w") as f:
                    f.write(str(mid))

                print(f"[codes] Embed refreshed (message {mid})")
            except Exception as exc:
                print(f"[codes] refresh error: {type(exc).__name__}: {exc}")

    # ═════════════ SLASH COMMANDS ══════════════
    @codes_group.command(name="add", description="Add a new access code")
    @app_commands.describe(name="Code name", pin="4-digit number", public="Visible in /codes list?")
    async def add_code(self, i: discord.Interaction, name: str, pin: str, public: bool = False):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if not self._valid_pin(pin):
            return await i.response.send_message("PIN must be 4 digits.", ephemeral=True)
        if name in await self.db.get_codes():
            return await i.response.send_message("Name already exists.", ephemeral=True)

        await self.db.add_code(name, pin, public)
        await self._refresh_embed()
        await i.response.send_message("Code added.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="edit", description="Edit an existing code")
    @app_commands.describe(name="Existing name", pin="New 4-digit pin", public="Leave blank to keep current visibility")
    async def edit_code(self, i: discord.Interaction, name: str, pin: str, public: Optional[bool] = None):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if not self._valid_pin(pin):
            return await i.response.send_message("PIN must be 4 digits.", ephemeral=True)
        if name not in await self.db.get_codes():
            return await i.response.send_message("No such code.", ephemeral=True)

        await self.db.edit_code(name, pin, public)
        await self._refresh_embed()
        await i.response.send_message("Code updated.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="remove", description="Delete a code")
    async def remove_code(self, i: discord.Interaction, name: str):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if name not in await self.db.get_codes():
            return await i.response.send_message("No such code.", ephemeral=True)

        await self.db.remove_code(name)
        await self._refresh_embed()
        await i.response.send_message("Code removed.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="list", description="Show public codes")
    async def list_codes(self, i: discord.Interaction):
        pub = await self.db.get_codes(only_public=True)
        if not pub:
            return await i.response.send_message("No public codes.", ephemeral=True)
        await i.response.send_message(
            "\n".join(f"• **{n}**: `{pin}`" for n, (pin, _) in pub.items()),
            ephemeral=True
        )

    # ═════════════ Postgres LISTEN ═════════════
    async def _listen_pg(self):
        if not DATABASE_URL:
            print("[codes] DATABASE_URL not set – listener disabled")
            return
        try:
            conn: asyncpg.Connection = await asyncpg.connect(DATABASE_URL)
            await conn.add_listener(
                "codes_changed",
                lambda *_: asyncio.create_task(self._refresh_embed())
            )
            print("[codes] LISTEN codes_changed attached")

            while True:
                await asyncio.sleep(3600)          # keep task alive
        except asyncio.CancelledError:
            pass
        except Exception as exc:
            print(f"[codes] listener error: {type(exc).__name__}: {exc}")
        finally:
            with contextlib.suppress(Exception):
                await conn.close()


# ═════════════ setup entry-point ═════════════
async def setup(bot: commands.Bot, db):
    await bot.add_cog(CodesCog(bot, db))


FILE: cogs\feedback.py
----------------------------------------
# cogs/feedback.py
# =============================================================
# /feedback → embed to staff channel + private per-case channel
# Category auto-created if missing.  ✅ Resolved deletes channel.
# =============================================================
from __future__ import annotations

import contextlib
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, cast

import discord
from discord import app_commands
from discord.ext import commands

# ─────────────── CONFIG ──────────────────────────────────────
FEEDBACK_CH_ID   = 1413188006499586158      # staff feedback channel
THREAD_CAT_NAME  = "Feedback Threads"       # created/used automatically
ANON_RATE        = timedelta(hours=24)      # 1 anonymous post / 24 h

CAT_COMPLAINT = "Staff / Member complaint"
CAT_DISCORD   = "Discord issue"
CAT_OTHER     = "Other"
# ─────────────────────────────────────────────────────────────


# ═══ helper – ensure category exists ═════════════════════════
async def ensure_case_category(
    guild: discord.Guild, staff_tpl: discord.TextChannel
) -> discord.CategoryChannel:
    for cat in guild.categories:
        if cat.name.lower() == THREAD_CAT_NAME.lower():
            return cat

    overwrites = {k: v for k, v in staff_tpl.overwrites.items()}
    overwrites.setdefault(
        guild.default_role, discord.PermissionOverwrite(view_channel=False)
    )

    return await guild.create_category(
        name=THREAD_CAT_NAME,
        overwrites=overwrites,
        reason="Initial feedback case category",
    )


# ═══ Modal (body only) ═══════════════════════════════════════
class BodyModal(discord.ui.Modal):
    def __init__(
        self,
        cog: "FeedbackCog",
        *,
        category_label: str,
        target: Optional[discord.Member],
        anonymous: bool,
    ):
        super().__init__(title="Describe your feedback")
        self.cog, self.cat, self.target, self.anon = (
            cog, category_label, target, anonymous
        )
        self.body = discord.ui.TextInput(
            label="Details (max 2000 chars)",
            style=discord.TextStyle.paragraph,
            max_length=2000,
        )
        self.add_item(self.body)

    async def on_submit(self, inter: discord.Interaction):
        await self.cog._finalise_feedback(
            inter,
            category_label=self.cat,
            target=self.target,
            anonymous=self.anon,
            text=self.body.value,
        )


# ═══ helper – create per-case channel ════════════════════════
async def create_case_channel(
    guild: discord.Guild,
    fid: int,
    *,
    staff_tpl: discord.TextChannel,
) -> discord.TextChannel:
    category = await ensure_case_category(guild, staff_tpl)

    overwrites = {k: v for k, v in staff_tpl.overwrites.items()}
    overwrites[guild.default_role] = discord.PermissionOverwrite(view_channel=False)

    return await guild.create_text_channel(
        name=f"feedback-{fid}",
        category=category,
        overwrites=overwrites,
        topic=f"Private discussion for feedback #{fid}",
        reason="New feedback received",
    )


# ═══ Staff triage / Contact view ═════════════════════════════
class TriageView(discord.ui.View):
    def __init__(self, db, fid: int, author_id: int, case_chan_id: int):
        super().__init__(timeout=None)
        self.db, self.fid, self.author_id, self.case_chan_id = (
            db, fid, author_id, case_chan_id
        )
        if author_id == 0:
            self.contact.disabled = True  # anonymous

    async def _set_status(self, inter, status, colour):
        if not (
            inter.user.guild_permissions.manage_messages
            or inter.user.guild_permissions.administrator
        ):
            return await inter.response.send_message("No permission.", ephemeral=True)

        emb = inter.message.embeds[0]
        emb.colour = colour
        emb.set_footer(
            text=f"Status: {status} • by {inter.user}",
            icon_url=inter.user.display_avatar.url,
        )
        await inter.message.edit(embed=emb, view=self)
        await self.db.update_feedback_status(self.fid, status)

        # Auto-delete when resolved
        if status == "Resolved":
            chan = inter.guild and inter.guild.get_channel(self.case_chan_id)
            if isinstance(chan, discord.TextChannel):
                with contextlib.suppress(discord.Forbidden, discord.HTTPException):
                    await chan.delete(reason="Feedback resolved")

        await inter.response.send_message("Status updated.", ephemeral=True)

    @discord.ui.button(label="Ack", style=discord.ButtonStyle.gray, emoji="👀")
    async def ack(self, i, _): await self._set_status(i, "Ack", discord.Color.yellow())

    @discord.ui.button(label="WIP", style=discord.ButtonStyle.blurple, emoji="🔧")
    async def wip(self, i, _): await self._set_status(i, "WIP", discord.Color.blue())

    @discord.ui.button(label="Resolved", style=discord.ButtonStyle.green, emoji="✅")
    async def res(self, i, _): await self._set_status(i, "Resolved", discord.Color.green())

    # ---- Contact button -------------------------------------
    @discord.ui.button(label="Contact", style=discord.ButtonStyle.gray, emoji="✉️")
    async def contact(self, inter: discord.Interaction, _):
        if self.author_id == 0:
            return await inter.response.send_message("Author is anonymous.", ephemeral=True)

        guild = inter.guild
        chan  = guild and guild.get_channel(self.case_chan_id)
        if chan is None:
            return await inter.response.send_message("Case channel missing.", ephemeral=True)

        author_obj: discord.abc.Snowflake = (
            guild.get_member(self.author_id)
            or await inter.client.fetch_user(self.author_id)
        )

        try:
            await chan.set_permissions(
                author_obj,
                overwrite=discord.PermissionOverwrite(view_channel=True,
                                                      send_messages=True),
            )
        except discord.Forbidden:
            return await inter.response.send_message(
                "Cannot edit channel permissions.", ephemeral=True
            )

        await chan.send(
            f"{author_obj.mention} – staff member {inter.user.mention} would like "
            "to discuss your feedback. Please reply here."
        )
        await inter.response.send_message(f"Author invited! → {chan.mention}", ephemeral=True)


# ═══════════════════════ Cog ═════════════════════════════════
class FeedbackCog(commands.Cog):
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        if not hasattr(bot, "last_anonymous_time"):
            bot.last_anonymous_time = cast(Dict[int, datetime], {})

    # ---------- /feedback command ----------------------------
    @app_commands.command(name="feedback", description="Send feedback to the staff")
    @app_commands.describe(
        category="Select a category",
        target="User you're complaining about (if Complaint)",
        anonymous="Hide your name from staff?",
    )
    @app_commands.choices(
        category=[
            app_commands.Choice(name=CAT_COMPLAINT, value="complaint"),
            app_commands.Choice(name=CAT_DISCORD,   value="discord"),
            app_commands.Choice(name=CAT_OTHER,     value="other"),
        ]
    )
    async def feedback(
        self, inter: discord.Interaction,
        *, category: app_commands.Choice[str],
        anonymous: bool = False,
        target: Optional[discord.Member] = None,
    ):
        if category.value == "complaint" and target is None:
            return await inter.response.send_message(
                "Please choose a target user for complaints.", ephemeral=True
            )

        # anon cooldown
        if anonymous:
            now = datetime.now(timezone.utc)
            last = self.bot.last_anonymous_time.get(inter.user.id) \
                   or await self.db.get_last_anon_ts(inter.user.id)
            if last:
                self.bot.last_anonymous_time[inter.user.id] = last
            if last and now - last < ANON_RATE:
                rem = ANON_RATE - (now - last)
                h, r = divmod(rem.seconds, 3600); m, _ = divmod(r, 60)
                return await inter.response.send_message(
                    f"You can post anonymously again in {rem.days}d {h}h {m}m.",
                    ephemeral=True,
                )

        await inter.response.send_modal(
            BodyModal(self,
                      category_label=category.name,
                      target=target,
                      anonymous=anonymous)
        )

    # ---------- modal callback -------------------------------
    async def _finalise_feedback(
        self, inter: discord.Interaction,
        *, category_label: str, target: Optional[discord.Member],
        anonymous: bool, text: str,
    ):
        colour = discord.Color.light_gray() if anonymous else discord.Color.blue()
        embed = discord.Embed(title=category_label, description=text,
                              colour=colour, timestamp=datetime.now(timezone.utc))
        if target:
            embed.add_field(name="Target", value=target.mention, inline=False)

        if anonymous:
            embed.set_footer(text="Sent anonymously")
            author_id_db = 0
        else:
            embed.set_author(name=str(inter.user),
                             icon_url=inter.user.display_avatar.url)
            author_id_db = inter.user.id

        staff_chan = inter.client.get_channel(FEEDBACK_CH_ID)  # type: ignore
        if not isinstance(staff_chan, discord.TextChannel):
            return await inter.response.send_message(
                "Staff feedback channel missing.", ephemeral=True
            )

        msg = await staff_chan.send(embed=embed)

        fid = await self.db.record_feedback(
            msg_id=msg.id,
            author_id=author_id_db,
            category=category_label,
            target_id=target.id if target else None,
            text=text,
            rating=None,
            attachment_urls=None,
        )

        case_chan = await create_case_channel(
            guild=staff_chan.guild,
            fid=fid,
            staff_tpl=staff_chan,
        )

        await msg.edit(view=TriageView(self.db, fid, author_id_db, case_chan.id))

        if anonymous:
            now = datetime.now(timezone.utc)
            self.bot.last_anonymous_time[inter.user.id] = now
            await self.db.set_last_anon_ts(inter.user.id, now)

        await inter.response.send_message("✅  Thanks for the feedback!", ephemeral=True)

    # ---------- /myfeedback ----------------------------------
    @app_commands.command(name="myfeedback", description="DM your last 25 feedback submissions")
    async def myfeedback(self, inter: discord.Interaction):
        rows = await self.db.list_feedback_by_author(inter.user.id, 25)
        if not rows:
            return await inter.response.send_message(
                "You have no feedback entries.", ephemeral=True
            )

        summary = "\n".join(
            f"- {r['created_at']:%Y-%m-%d} • {r['category']} • {r['status']} (ID {r['id']})"
            for r in rows
        )
        await inter.user.send(summary)
        await inter.response.send_message("📨  Sent to your DMs.", ephemeral=True)


# ─────────────── setup entry point ───────────────────────────
async def setup(bot, db):
    await bot.add_cog(FeedbackCog(bot, db))


FILE: cogs\member_forms.py
----------------------------------------
# cogs/member_forms.py
# ───────────────────────────────────────────────────────────────
#   Member registration workflow + reviewer commands
# ───────────────────────────────────────────────────────────────
from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import os
import re
from typing import Dict, Optional

import httpx
import discord
from discord import app_commands
from discord.ext import commands

# ───────────────────────── log setup ──────────────────────────
log = logging.getLogger("cog.member_forms")

# ═══════════════════ ENV / CONFIG ═════════════════════════════
try:
    # Optional – load .env if python-dotenv is installed
    from dotenv import load_dotenv

    load_dotenv()
except Exception:
    pass


def req(name: str) -> str:
    """Get a required env-var or raise & log clearly."""
    value = os.getenv(name)
    if not value:
        log.error("[member_forms] REQUIRED env variable %s missing - cog disabled", name)
        raise RuntimeError(f"Missing env {name}")
    return value


STEAM_API_KEY = req("STEAM_API_KEY")
GUILD_ID = int(req("GUILD_ID"))

# The rest are optional – fall back to literal IDs if not found
MEMBER_FORM_CH = int(os.getenv("MEMBER_FORM_CH", "1378118620873494548"))
UNCOMPLETED_APP_ROLE_ID = int(os.getenv("UNCOMPLETED_APP_ROLE_ID", "1390143545066917931"))
COMPLETED_APP_ROLE_ID = int(os.getenv("COMPLETED_APP_ROLE_ID", "1398708167525011568"))
ACCEPT_ROLE_ID = int(os.getenv("ACCEPT_ROLE_ID", "1377075930144571452"))

ROLE_PREFIXES = {
    "PvP": "[P]",
    "Farming": "[F]",
    "Electricity": "[E]",
    "Building": "[B]",
    "Base Sorting": "[BB]",
}

REGION_ROLE_IDS = {
    "North America": 1411364406096433212,
    "Europe": 1411364744484491287,
    "Asia": 1411364982117105684,
    "Other": 1411365034440921260,
}
FOCUS_ROLE_IDS = {
    "Farming": 1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building": 1380233086544908428,
    "Electricity": 1380233234675400875,
    "PvP": 1408687710159245362,
}
TEMP_BAN_SECONDS = 7 * 24 * 60 * 60
# ══════════════════════════════════════════════════════════════

# ──────────────────────────── STEAM API ────────────────────────────
BASE_URL = "https://api.steampowered.com"


async def _steam_get(client: httpx.AsyncClient, endpoint: str, params: dict) -> dict:
    """Call Steam Web API endpoint with given params. Never raise; return {} on error.
    The API key is passed as a param and never logged.
    """
    try:
        r = await client.get(f"{BASE_URL}/{endpoint}", params=params, timeout=6.0)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as exc:
        status = exc.response.status_code
        # Avoid logging the key; show endpoint only
        if status == 403:
            log.warning("Steam request 403 Forbidden on %s", endpoint)
        else:
            log.warning("Steam request failed (%s) on %s: %s", status, endpoint, exc)
        return {}
    except Exception as exc:
        log.warning("Steam request error on %s: %s", endpoint, exc)
        return {}


async def extract_steam_id(url: str) -> Optional[str]:
    """Extract a 64-bit SteamID from a profile URL. Resolve vanity if needed."""
    url = url.strip().lower()

    # /profiles/<64-bit>
    if (m := re.search(r"steamcommunity\.com/profiles/(\d{17})", url)):
        return m.group(1)

    # /id/<vanity>  → ResolveVanityURL
    if (m := re.search(r"steamcommunity\.com/id/([\w\-]+)", url)):
        vanity = m.group(1)
        async with httpx.AsyncClient() as client:
            data = await _steam_get(
                client,
                "ISteamUser/ResolveVanityURL/v1/",
                {"key": STEAM_API_KEY, "vanityurl": vanity},
            )
        return data.get("response", {}).get("steamid")

    return None


async def is_steam_profile_valid(steam_id: str) -> bool:
    """
    Requirements for a *valid* profile:
      • profile visibility  == public (3)
      • at least 1 owned game  AND  at least 1 h (≥60 min) on ANY game
      • friends list not empty
    """
    async with httpx.AsyncClient() as client:
        summary, games, friends = await asyncio.gather(
            _steam_get(
                client,
                "ISteamUser/GetPlayerSummaries/v2/",
                {"key": STEAM_API_KEY, "steamids": steam_id},
            ),
            _steam_get(
                client,
                "IPlayerService/GetOwnedGames/v1/",
                {"key": STEAM_API_KEY, "steamid": steam_id, "include_appinfo": 0},
            ),
            _steam_get(
                client,
                "ISteamUser/GetFriendList/v1/",
                {"key": STEAM_API_KEY, "steamid": steam_id},
            ),
        )

    # 1) profile visibility
    player = (summary.get("response", {}).get("players") or [{}])[0]
    if player.get("communityvisibilitystate") != 3:
        return False

    # 2) games + ≥1 h play-time
    g_resp = games.get("response", {})
    if g_resp.get("game_count", 0) == 0:
        return False

    games_list = g_resp.get("games", [])
    has_1h = any((g.get("playtime_forever") or 0) >= 60 for g in games_list)
    if not has_1h:
        return False

    # 3) friends not empty
    if not friends.get("friendslist", {}).get("friends"):
        return False

    return True


async def get_steam_username(steam_id: str) -> Optional[str]:
    async with httpx.AsyncClient() as client:
        data = await _steam_get(
            client,
            "ISteamUser/GetPlayerSummaries/v2/",
            {"key": STEAM_API_KEY, "steamids": steam_id},
        )
    player = (data.get("response", {}).get("players") or [{}])[0]
    return player.get("personaname")


def _opts(*lbl: str) -> list[discord.SelectOption]:
    return [discord.SelectOption(label=l, value=l) for l in lbl]


async def safe_fetch(guild: discord.Guild, uid: int) -> Optional[discord.Member]:
    try:
        return await guild.fetch_member(uid)
    except (discord.NotFound, discord.HTTPException):
        return None


# ═══════════════════ MAIN COG ═══════════════════
class MemberFormCog(commands.Cog):
    """Member registration workflow + reviewer helper commands."""

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._ready_once = False

    # ───────────────────────── on_ready ─────────────────────────
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready_once:
            return
        self._ready_once = True
        await self._restore_action_views()
        log.info("[member_forms] persistent ActionViews reattached")

    async def _restore_action_views(self):
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        chan = guild.get_channel(MEMBER_FORM_CH)
        if not isinstance(chan, discord.TextChannel):
            return

        for row in await self.db.get_pending_member_forms():
            try:
                await chan.fetch_message(row["message_id"])
            except discord.NotFound:
                continue  # message gone

            region = row.get("region")
            focus = row.get("focus")

            if not region or not focus:
                raw = row.get("data") or {}
                if isinstance(raw, str):
                    with contextlib.suppress(json.JSONDecodeError):
                        raw = json.loads(raw)
                region = region or raw.get("region")
                focus = focus or raw.get("focus")

            if not region or not focus:
                continue

            self.bot.add_view(
                ActionView(guild, row["user_id"], region, focus, self.db),
                message_id=row["message_id"],
            )

    # ───────────────────────── reviewer cmds ────────────────────
    @app_commands.command(name="addreviewer", description="Add a reviewer")
    async def add_reviewer(self, i: discord.Interaction, member: discord.Member):
        if not i.user.guild_permissions.administrator:
            return await i.response.send_message("No permission.", ephemeral=True)
        await self.db.add_reviewer(member.id)
        await i.response.send_message("Added.", ephemeral=True)

    @app_commands.command(name="removereviewer", description="Remove a reviewer")
    async def remove_reviewer(self, i: discord.Interaction, member: discord.Member):
        if not i.user.guild_permissions.administrator:
            return await i.response.send_message("No permission.", ephemeral=True)
        await self.db.remove_reviewer(member.id)
        await i.response.send_message("Removed.", ephemeral=True)

    @app_commands.command(name="reviewers", description="List reviewers")
    async def list_reviewers(self, i: discord.Interaction):
        reviewers = await self.db.get_reviewers()
        txt = ", ".join(f"<@{u}>" for u in reviewers) or "None."
        await i.response.send_message(txt, ephemeral=True)

    # /memberform entry-point
    @app_commands.command(name="memberform", description="Start member registration")
    async def memberform(self, i: discord.Interaction):
        await i.response.send_message(
            "Click below to begin registration:",
            view=MemberRegistrationView(self.db),
            ephemeral=True,
        )


# ═══════════════════  REGISTRATION UI  ═══════════════════
class MemberRegistrationView(discord.ui.View):
    """Five dropdowns → then Submit button."""

    def __init__(self, db):
        super().__init__(timeout=300)
        self.db = db
        self.data: Dict[str, str] = {}
        self.user: Optional[discord.User] = None
        self.start_msg: Optional[discord.Message] = None
        self.submit_msg: Optional[discord.Message] = None
        self.submit_sent = False

    # first button
    @discord.ui.button(label="Start Registration", style=discord.ButtonStyle.primary)
    async def start(self, i: discord.Interaction, _):
        self.user = i.user
        self.clear_items()
        self.add_item(SelectAge(self))
        self.add_item(SelectRegion(self))
        self.add_item(SelectBans(self))
        self.add_item(SelectFocus(self))
        self.add_item(SelectSkill(self))
        await i.response.edit_message(
            content="Fill each dropdown – **Submit** appears when all done.",
            view=self,
        )
        self.start_msg = await i.original_response()


# ---------- generic dropdown base ----------
class _BaseSelect(discord.ui.Select):
    def __init__(self, v: MemberRegistrationView, key: str, **kw):
        self.v, self.key = v, key
        super().__init__(**kw)

    async def callback(self, i: discord.Interaction):
        self.v.data[self.key] = self.values[0]
        self.placeholder = self.values[0]
        await i.response.edit_message(view=self.v)
        if (
            not self.v.submit_sent
            and all(k in self.v.data for k in ("age", "region", "bans", "focus", "skill"))
        ):
            self.v.submit_sent = True
            self.v.submit_msg = await i.followup.send(
                "All set – click **Submit**:",
                view=SubmitView(self.v),
                ephemeral=True,
                wait=True,
            )


# ---------- concrete dropdowns ----------
class SelectAge(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "age", placeholder="Age", options=_opts("12-14", "15-17", "18-21", "21+"))


class SelectRegion(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "region", placeholder="Region", options=_opts("North America", "Europe", "Asia", "Other"))


class SelectBans(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "bans", placeholder="Any bans?", options=_opts("Yes", "No"))


class SelectFocus(_BaseSelect):
    def __init__(self, v):
        super().__init__(
            v,
            "focus",
            placeholder="Main focus",
            options=_opts("PvP", "Farming", "Base Sorting", "Building", "Electricity"),
        )


class SelectSkill(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "skill", placeholder="Skill level", options=_opts("Beginner", "Intermediate", "Advanced", "Expert"))


# ---------- submit helper view ----------
class SubmitView(discord.ui.View):
    def __init__(self, v: MemberRegistrationView):
        super().__init__(timeout=300)
        self.v = v

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.success)
    async def submit(self, i: discord.Interaction, _):
        await i.response.send_modal(FinalRegistrationModal(self.v))


# ═══════════════════  FINAL MODAL  ═══════════════════
class FinalRegistrationModal(discord.ui.Modal):
    def __init__(self, v: MemberRegistrationView):
        self.v = v
        needs_ban = v.data.get("bans") == "Yes"
        super().__init__(title="More Details" if needs_ban else "Additional Info")

        self.steam = discord.ui.TextInput(label="Steam Profile Link", placeholder="https://steamcommunity.com/…")
        self.hours = discord.ui.TextInput(label="Hours in Rust")
        self.heard = discord.ui.TextInput(label="Where did you hear about us?")

        self.ban_expl = self.gender = self.referral = None
        if needs_ban:
            self.ban_expl = discord.ui.TextInput(label="Ban Explanation", style=discord.TextStyle.paragraph)
            self.referral = discord.ui.TextInput(label="Referral (optional)", required=False)
            comps = (self.steam, self.hours, self.heard, self.ban_expl, self.referral)
        else:
            self.referral = discord.ui.TextInput(label="Referral (optional)", required=False)
            self.gender = discord.ui.TextInput(label="Gender (optional)", required=False)
            comps = (self.steam, self.hours, self.heard, self.referral, self.gender)
        for c in comps:
            self.add_item(c)

    # ------------------------------------------------------------
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)

        d = self.v.data
        user = self.v.user or interaction.user
        link = self.steam.value.strip()

        steam_id = await extract_steam_id(link)
        if not steam_id:
            return await interaction.followup.send(
                "⚠️ I couldn't read that Steam link – make sure it's a full profile URL "
                "(`/profiles/…` or `/id/…`).", ephemeral=True
            )

        if not await is_steam_profile_valid(steam_id):
            return await interaction.followup.send(
                "⚠️ Your Steam profile must be **fully public** and show at least "
                "one game, at least one friend, and **at least one hour of play-time**.\n"
                "Please adjust your privacy settings and try again.",
                ephemeral=True,
    )

        # ───── Build reviewer embed ─────
        e = (
            discord.Embed(
                title="📋 NEW MEMBER REGISTRATION",
                colour=discord.Color.gold(),
                timestamp=interaction.created_at,
            )
            .set_author(name=str(user), icon_url=user.display_avatar.url)
        )
        e.add_field(name="👤 User",   value=user.mention, inline=False)
        e.add_field(name="🔗 Steam",  value=link,         inline=False)
        e.add_field(name="🗓️ Age",   value=d["age"],     inline=True)
        e.add_field(name="🌍 Region", value=d["region"],  inline=True)
        e.add_field(name="🚫 Bans",   value=d["bans"],    inline=True)
        if d["bans"] == "Yes" and self.ban_expl:
            e.add_field(name="📝 Ban Explanation", value=self.ban_expl.value, inline=False)
        e.add_field(name="🎯 Focus",  value=d["focus"],   inline=True)
        e.add_field(name="⭐ Skill",  value=d["skill"],   inline=True)
        e.add_field(name="⏱️ Hours", value=self.hours.value, inline=True)
        e.add_field(name="📢 Heard about us", value=self.heard.value, inline=False)
        e.add_field(name="🤝 Referral", value=self.referral.value if self.referral else "N/A", inline=True)
        if self.gender:
            e.add_field(name="⚧️ Gender", value=self.gender.value or "N/A", inline=True)

        review_ch: discord.TextChannel = interaction.client.get_channel(MEMBER_FORM_CH)  # type: ignore
        msg = await review_ch.send(
            embed=e,
            view=ActionView(interaction.guild, user.id, d["region"], d["focus"], self.v.db),
        )

        # ───── DB save ─────
        await self.v.db.add_member_form(
            user.id,
            {
                **d,
                "steam": link,
                "hours": self.hours.value,
                "heard": self.heard.value,
                "referral": self.referral.value if self.referral else None,
                "gender":   self.gender.value   if self.gender   else None,
                "ban_explanation": self.ban_expl.value if self.ban_expl else None,
            },
            message_id=msg.id,
        )

        # swap roles
        try:
            member = await interaction.guild.fetch_member(user.id)
            unc    = interaction.guild.get_role(UNCOMPLETED_APP_ROLE_ID)
            comp   = interaction.guild.get_role(COMPLETED_APP_ROLE_ID)
            if comp and comp not in member.roles:
                await member.add_roles(comp, reason="Application submitted")
            if unc and unc in member.roles:
                await member.remove_roles(unc, reason="Application submitted")
        except discord.Forbidden:
            pass

        await interaction.followup.send("✅ Registration submitted – thank you!", ephemeral=True)

        # tidy helper messages
        async def tidy():
            await asyncio.sleep(2)
            for m in (self.v.start_msg, self.v.submit_msg):
                if m:
                    with contextlib.suppress(discord.HTTPException):
                        await m.delete()
        asyncio.create_task(tidy())


# ═══════════════════  REVIEWER ActionView  ═══════════════════
class ActionView(discord.ui.View):
    # unchanged __init__
    def __init__(self, guild: discord.Guild, uid: int, region: str, focus: str, db):
        super().__init__(timeout=None)
        self.guild, self.uid, self.region, self.focus, self.db = guild, uid, region, focus, db

    async def _reviewers(self) -> set[int]:
        return await self.db.get_reviewers()

    async def _finish(
        self,
        interaction: discord.Interaction,
        txt: str,
        colour: discord.Colour,
    ):
        """Disable buttons, recolour embed, then send confirmation."""
        emb = interaction.message.embeds[0]
        emb.colour = colour

        for c in self.children:
            c.disabled = True
        await interaction.message.edit(embed=emb, view=self)

        # choose response vs follow-up
        if interaction.response.is_done():
            await interaction.followup.send(txt, ephemeral=True)
        else:
            await interaction.response.send_message(txt, ephemeral=True)

    # ───────────── Accept ─────────────
    @discord.ui.button(
        label="Accept",
        style=discord.ButtonStyle.success,
        emoji="✅",
        custom_id="memberform_accept",
    )
    async def accept(self, interaction: discord.Interaction, _):
        # Acknowledge as early as possible
        await interaction.response.defer(ephemeral=True)

        if (
            interaction.user.id not in await self._reviewers()
            and not interaction.user.guild_permissions.manage_roles
        ):
            return await interaction.followup.send("Not authorised.", ephemeral=True)

        mem = await safe_fetch(self.guild, self.uid)
        if not mem:
            return await interaction.followup.send("Member left.", ephemeral=True)

        # ── nickname ───────────────────────────────────────────
        steam_link = next(
            (f.value for f in interaction.message.embeds[0].fields
             if f.name.startswith("🔗")),
            None,
        )
        steam_username = None
        if steam_link:
            if (steam_id := await extract_steam_id(steam_link)):
                steam_username = await get_steam_username(steam_id)

        prefix = ROLE_PREFIXES.get(self.focus, "")
        nick   = f"{prefix} {steam_username or mem.display_name}".strip()[:32]
        with contextlib.suppress(discord.Forbidden):
            await mem.edit(nick=nick)

        # ── roles ──────────────────────────────────────────────
        roles = [
            r for r in (
                self.guild.get_role(ACCEPT_ROLE_ID),
                self.guild.get_role(REGION_ROLE_IDS.get(self.region, 0)),
                self.guild.get_role(FOCUS_ROLE_IDS.get(self.focus, 0)),
            ) if r
        ]
        with contextlib.suppress(discord.Forbidden):
            if roles:
                await mem.add_roles(*roles, reason="Application accepted")

        await self.db.update_member_form_status(interaction.message.id, "accepted")
        await self._finish(interaction, f"{mem.mention} accepted ✅", discord.Color.green())

    # ───────────── Deny ─────────────
    @discord.ui.button(
        label="Deny",
        style=discord.ButtonStyle.danger,
        emoji="⛔",
        custom_id="memberform_deny",
    )
    async def deny(self, interaction: discord.Interaction, _):
        # Defer immediately
        await interaction.response.defer(ephemeral=True)

        # permission check
        if (
            interaction.user.id not in await self._reviewers()
            and not interaction.user.guild_permissions.ban_members
        ):
            return await interaction.followup.send("Not authorised.", ephemeral=True)

        # fetch applicant
        mem = await safe_fetch(self.guild, self.uid)
        if mem:
            with contextlib.suppress(discord.Forbidden):
                await self.guild.ban(
                    mem,
                    reason="Application denied – temp ban",
                    delete_message_seconds=0,
                )

            # schedule un-ban
            async def unban_later():
                await asyncio.sleep(TEMP_BAN_SECONDS)
                with contextlib.suppress(Exception):
                    await self.guild.unban(discord.Object(self.uid))

            asyncio.create_task(unban_later())

        # DB + UI
        await self.db.update_member_form_status(interaction.message.id, "denied")
        await self._finish(
            interaction,
            "Application denied ⛔",
            discord.Color.red(),
        )


# ═══════════════════ setup entry-point ═══════════════════
async def setup(bot: commands.Bot, db):
    await bot.add_cog(MemberFormCog(bot, db))


FILE: cogs\recruit_reminder.py
----------------------------------------
# cogs/recruit_reminder.py
# Production-ready • discord.py ≥ 2.3 • 2024-10-05
#
#  • A message in the #recruit channel lets recruitment staff press ✅ Accept
#    to "take the shift" and locks further posts for 6 h.
#  • The button is PERSISTENT – survives bot restarts.
#  • Table `recruit_reminder` is created automatically.
#  • Fix: view is re-attached only after the DB table is ready, so the button
#    always works after a reboot.

from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timezone
from typing import Optional

import asyncpg
import discord
from discord import app_commands
from discord.ext import commands, tasks

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)

# ───────────── Server-specific constants ─────────────
RECRUIT_CHANNEL_ID  = 1421856820460388383          # channel where the reminder lives
RECRUITMENT_ROLE_ID = 1410659214959054988          # role allowed to accept

SHIFT_SECONDS   = 6 * 60 * 60                      # 6-hour cooldown
UPDATE_INTERVAL = 15                               # seconds between checks

# ───────────── SQL ─────────────
CREATE_SQL = """
CREATE TABLE IF NOT EXISTS recruit_reminder (
    id         BOOLEAN PRIMARY KEY DEFAULT TRUE,
    message_id BIGINT,
    claimed_by BIGINT,
    end_ts     BIGINT
);
INSERT INTO recruit_reminder (id) VALUES (TRUE)
ON CONFLICT (id) DO NOTHING;
"""

GET_SQL = "SELECT message_id, claimed_by, end_ts FROM recruit_reminder LIMIT 1"

SET_SQL = """
UPDATE recruit_reminder
   SET message_id = $1, claimed_by = $2, end_ts = $3
 WHERE id = TRUE;
"""


class RecruitReminder(commands.Cog):
    # ═════════════════ INITIALISATION ═════════════════
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db

        # will be set after the table exists & pool ready
        self._table_ready = asyncio.Event()

        # Start the update task only after table is ready
        self.update_task: Optional[asyncio.Task] = None
        asyncio.create_task(self._prepare_and_start())

    async def _prepare_and_start(self):
        """Prepare table and start update task."""
        await self._prepare_table()
        self.update_message.start()
        self.update_task = self.update_message.get_task()

    # ═════════════════ DB helpers ═════════════════
    async def _prepare_table(self):
        """Wait for `db.pool`, then create the table once."""
        while self.db.pool is None:
            await asyncio.sleep(1)

        async with self.db.pool.acquire() as conn:
            await conn.execute(CREATE_SQL)
        self._table_ready.set()
        log.debug("[recruit] table ready")

    async def _get_state(self) -> dict[str, Optional[int]]:
        """Return dict with keys: message_id, claimed_by, end_ts (can be None)."""
        if self.db.pool is None:
            return {"message_id": None, "claimed_by": None, "end_ts": None}

        await self._table_ready.wait()
        
        async with self.db.pool.acquire() as conn:
            try:
                row = await conn.fetchrow(GET_SQL)
            except asyncpg.UndefinedTableError:
                await conn.execute(CREATE_SQL)
                row = None
        return dict(row) if row else {"message_id": None, "claimed_by": None, "end_ts": None}

    async def _set_state(self, *, message_id, claimed_by, end_ts):
        if self.db.pool is None:
            return
        await self._table_ready.wait()
        
        async with self.db.pool.acquire() as conn:
            try:
                await conn.execute(SET_SQL, message_id, claimed_by, end_ts)
            except asyncpg.UndefinedTableError:
                await conn.execute(CREATE_SQL)
                await conn.execute(SET_SQL, message_id, claimed_by, end_ts)

    # ═════════════════ Persistent VIEW ═════════════════
    class AcceptView(discord.ui.View):
        def __init__(self, outer: "RecruitReminder"):
            super().__init__(timeout=None)  # keep alive forever
            self.outer = outer

        @discord.ui.button(
            label="Accept",
            emoji="✅",
            style=discord.ButtonStyle.success,
            custom_id="recruit_accept"
        )
        async def accept(self, inter: discord.Interaction, _button: discord.ui.Button):
            guild = inter.guild
            role  = guild.get_role(RECRUITMENT_ROLE_ID) if guild else None
            if not (
                inter.user.guild_permissions.administrator
                or (role and role in inter.user.roles)
            ):
                return await inter.response.send_message(
                    "You're not recruitment staff.", ephemeral=True
                )

            await inter.response.defer(ephemeral=True)

            try:
                end_ts = int(datetime.now(timezone.utc).timestamp()) + SHIFT_SECONDS
                await self.outer._set_state(
                    message_id=inter.message.id,
                    claimed_by=inter.user.id,
                    end_ts=end_ts,
                )

                for child in self.children:
                    child.disabled = True

                await inter.message.edit(
                    content=(
                        f"✅ {inter.user.mention} has sent out recruitment — "
                        f"next recruitment posts can be sent in **6 hours**."
                    ),
                    view=self,
                )
                await inter.followup.send("Shift accepted — thank you!", ephemeral=True)
            except Exception as exc:                         # noqa: BLE001
                log.exception("Recruit Accept callback failed: %s", exc)
                try:
                    await inter.followup.send(
                        "Something went wrong – try again later.", ephemeral=True
                    )
                except (discord.HTTPException, discord.NotFound):
                    pass

    # ═════════════════ Periodic updater ═════════════════
    @tasks.loop(seconds=UPDATE_INTERVAL)
    async def update_message(self):
        await self._table_ready.wait()

        state   = await self._get_state()
        channel = self.bot.get_channel(RECRUIT_CHANNEL_ID)
        if not isinstance(channel, discord.TextChannel):
            return

        now_ts = int(datetime.now(timezone.utc).timestamp())

        # ---------- no message stored – create ----------
        if state["message_id"] is None:
            try:
                msg = await channel.send(
                    f"<@&{RECRUITMENT_ROLE_ID}> "
                    "Click **Accept** below if you're available to send out recruitment posts!",
                    view=self.AcceptView(self),
                )
                await self._set_state(message_id=msg.id, claimed_by=None, end_ts=None)
            except discord.Forbidden:
                log.error("Bot lacks permissions to send message in recruit channel")
            except discord.HTTPException as e:
                log.error("Failed to send recruit message: %s", e)
            return

        # ---------- fetch stored message ----------
        try:
            msg = await channel.fetch_message(state["message_id"])
        except discord.NotFound:                               # message deleted
            await self._set_state(message_id=None, claimed_by=None, end_ts=None)
            return
        except discord.Forbidden:
            log.error("Bot lacks permissions to fetch message in recruit channel")
            return
        except discord.HTTPException as e:
            log.error("Failed to fetch recruit message: %s", e)
            return

        # ---------- update content ----------
        if state["end_ts"]:                                    # shift active
            if now_ts >= state["end_ts"]:                      # shift expired
                try:
                    await msg.edit(
                        content=(
                            f"<@&{RECRUITMENT_ROLE_ID}> "
                            "Click **Accept** below if you're available to send out recruitment posts!"
                        ),
                        view=self.AcceptView(self),
                    )
                    await self._set_state(message_id=msg.id, claimed_by=None, end_ts=None)
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to update expired shift message: %s", e)
            else:                                              # still locked
                remaining = state["end_ts"] - now_ts
                hrs, rem  = divmod(remaining, 3600)
                mins      = rem // 60
                try:
                    await msg.edit(
                        content=(
                            f"✅ <@{state['claimed_by']}> has sent out recruitment — "
                            f"next recruitment posts can be sent in **{hrs} h {mins:02} m**."
                        )
                    )
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to update locked shift message: %s", e)
        else:                                                  # idle
            if not msg.components:
                try:
                    await msg.edit(view=self.AcceptView(self))
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to add view to idle message: %s", e)

    # ═════════════════ Persist view on reboot ═════════════════
    @commands.Cog.listener()
    async def on_ready(self):
        await self._table_ready.wait()
        state = await self._get_state()
        if state["message_id"]:
            try:
                # re-attach the persistent view so the button works
                self.bot.add_view(
                    self.AcceptView(self), message_id=state["message_id"]
                )
                log.info("[recruit] View reattached to message %s", state["message_id"])
            except Exception as e:                             # noqa: BLE001
                log.warning("Failed to add persistent view: %s", e)

    # ═════════════════ Admin command ═════════════════
    @app_commands.command(name="recruitreset",
                          description="Force-reset the recruitment reminder (admin only)")
    @app_commands.checks.has_permissions(administrator=True)
    async def recruit_reset(self, inter: discord.Interaction):
        await self._set_state(message_id=None, claimed_by=None, end_ts=None)
        await inter.response.send_message(
            "Recruitment reminder will refresh within 15 seconds.", ephemeral=True
        )

    # ═════════════════ teardown ═════════════════
    def cog_unload(self):
        if self.update_message.is_running():
            self.update_message.cancel()
        log.info("RecruitReminder unloaded")


async def setup(bot, db):
    await bot.add_cog(RecruitReminder(bot, db))


FILE: cogs\staff_applications.py
----------------------------------------
# cogs/staff_applications.py
# ───────────────────────────────────────────────────────────────
#   Staff application system (separate from member registration)
#   Drop-in for CTFO bot: /staffapply, review, and staff role granting.
# ───────────────────────────────────────────────────────────────

from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Optional

import discord
from discord import app_commands
from discord.ext import commands

log = logging.getLogger("cog.staff_applications")

# ═════════════════════ CONFIG (copy from your main) ═════════════════════
GUILD_ID                = 1377035207777194005
STAFF_APPLICATION_CH_ID = 1410649548837093436
ADMIN_ROLE_ID           = 1377103244089622719

STAFF_ROLE_IDS: dict[str, int] = {
    "Group Leader":      1377077466513932338,
    "Player Management": 1377084533706588201,
    "Recruitment":       1410659214959054988,
}

# tuple = (label, style, required)   LABEL **≤ 45 chars**
STAFF_QUESTION_SETS: dict[str, list[tuple[str, discord.TextStyle, bool]]] = {
    "Group Leader": [
        ("What group are you looking to lead?",          discord.TextStyle.short,     True),
        ("Why do you want to be a group leader?",        discord.TextStyle.paragraph, True),
        ("What makes you a good fit for this role?",     discord.TextStyle.paragraph, True),
        ("How many Rust hours do you have?",             discord.TextStyle.short,     True),
        ("How many hours a week are you available?",     discord.TextStyle.short,     True),
        ("When are you most active?",                    discord.TextStyle.short,     True),
        ("What time-zone are you in?",                   discord.TextStyle.short,     True),
        ("How would you rate your in-game skills?",      discord.TextStyle.short,     True),
        ("How old are you?",                             discord.TextStyle.short,     True),
    ],

    "Player Management": [
        ("Why do you want to join player management?",        discord.TextStyle.paragraph, True),
        ("What makes you good for this role?",                discord.TextStyle.paragraph, True),
        ("Describe your leadership skills.",                  discord.TextStyle.paragraph, True),
        ("How would you handle breaking of rules?",           discord.TextStyle.paragraph, True),
        ("How would you handle an unpopular decision?",       discord.TextStyle.paragraph, True),
        ("How would you handle an irritating player?",        discord.TextStyle.paragraph, True),
        ("What would you do if you felt annoyed?",            discord.TextStyle.paragraph, True),
        ("What time-zone are you in?",                        discord.TextStyle.short,     True),
        ("How many hours a week are you active?",             discord.TextStyle.short,     True),
        ("When are you most active?",                         discord.TextStyle.short,     True),
        ("How old are you?",                                  discord.TextStyle.short,     True),
    ],

    "Recruitment": [
        ("Why do you want this role?",                        discord.TextStyle.paragraph, True),
        ("What time-zone are you in?",                        discord.TextStyle.short,     True),
        ("When are you most active?",                         discord.TextStyle.short,     True),
        ("Are you banned from any Rust discords?",            discord.TextStyle.short,     True),
        ("How old are you?",                                  discord.TextStyle.short,     True),
        ("If a rejected user messages you, what do?",         discord.TextStyle.paragraph, True),   # 41 chars
    ],
}
# ════════════════════════════════════════════════════════════════════════


# ────────────────────────── Helper ──────────────────────────
async def safe_fetch(guild: discord.Guild, uid: int) -> Optional[discord.Member]:
    try:
        return await guild.fetch_member(uid)
    except (discord.NotFound, discord.HTTPException):
        return None
    except discord.Forbidden:
        log.debug("Could not fetch member %s – forbidden", uid)
        return None


# ══════════════════════ MAIN COG ══════════════════════
class StaffApplicationsCog(commands.Cog):
    """Handles staff application workflow (/staffapply and review)."""

    _ready_once: bool

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._ready_once = False

    # ─────────────────── Bot ready ───────────────────
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready_once:
            return
        self._ready_once = True
        await self._restore_action_views()
        log.info("[staff_applications] persistent ActionViews re-attached")

    async def _restore_action_views(self):
        """Re-attach persistent ActionViews after a restart."""
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        rows = await self.db.get_pending_staff_apps()  # [{user_id, role, message_id}]
        for row in rows:
            # Avoid adding the same view twice if on_ready runs again
            if any(
                isinstance(v, StaffApplicationActionView)
                and getattr(v, "message_id", None) == row["message_id"]
                for v in self.bot.persistent_views
            ):
                continue

            self.bot.add_view(
                StaffApplicationActionView(guild, row["user_id"], row["role"], self.db),
                message_id=row["message_id"],
            )

    # ═════════ main slash command ════════════
    @app_commands.command(name="staffapply", description="Apply for a staff position")
    async def staffapply(self, i: discord.Interaction):
        # Prevent duplicate open applications
        # FIXED: Get all pending apps and filter manually
        pending_apps = await self.db.get_pending_staff_apps()
        user_has_pending = any(app["user_id"] == i.user.id for app in pending_apps)
        
        if user_has_pending:
            return await i.response.send_message(
                "You already have a pending staff application.", ephemeral=True
            )

        await i.response.send_message(
            "Select the staff role you'd like to apply for:",
            view=StaffRoleSelectView(self.db),
            ephemeral=True,
        )


# ══════════════════ STAFF APPLICATION UI ══════════════════
class StaffRoleSelectView(discord.ui.View):
    def __init__(self, db):
        super().__init__(timeout=300)
        self.db = db
        self.add_item(StaffRoleSelect(self.db))


class StaffRoleSelect(discord.ui.Select):
    def __init__(self, db):
        super().__init__(
            placeholder="Select the staff role you'd like to apply for…",
            options=[discord.SelectOption(label=r, value=r) for r in STAFF_QUESTION_SETS],
        )
        self.db = db

    async def callback(self, i: discord.Interaction):
        await i.response.send_modal(
            StaffApplicationModal(self.values[0], 0, [], self.db)
        )


class ContinueView(discord.ui.View):
    """Ephemeral view that shows a single **Continue** button."""

    def __init__(
        self,
        role: str,
        next_idx: int,
        collected: list[tuple[str, str]],
        db,
    ):
        super().__init__(timeout=300)
        self.role, self.next_idx, self.collected, self.db = role, next_idx, collected, db
        self.message: Optional[discord.Message] = None  # set after sending

    @discord.ui.button(label="Continue", style=discord.ButtonStyle.primary, emoji="➡️")
    async def continue_btn(self, i: discord.Interaction, _):
        await i.response.send_modal(
            StaffApplicationModal(
                self.role, self.next_idx, list(self.collected), self.db
            )
        )
        self.disable_all_items()
        await i.message.edit(view=self)
        self.stop()  # prevent double interaction

    async def on_timeout(self):
        if self.is_finished():
            return
        self.disable_all_items()
        try:
            if self.message:
                await self.message.edit(view=self)
        except Exception:
            pass
        self.stop()


class StaffApplicationModal(discord.ui.Modal):
    """One page (up to 5 questions) of the staff application."""

    def __init__(
        self, role: str, idx: int, collected: list[tuple[str, str]], db
    ):
        super().__init__(title=f"{role} Application")
        self.role, self.idx, self.collected, self.db = role, idx, collected, db

        qset = STAFF_QUESTION_SETS[role][idx : idx + 5]
        for q, style, req in qset:
            assert (
                len(q) <= 45
            ), f"Modal label >45 chars (Discord limit): {q!r}"
            self.add_item(
                discord.ui.TextInput(
                    label=q,
                    style=style,
                    required=req,
                    max_length=100 if style is discord.TextStyle.short else 1024,
                )
            )

    async def on_submit(self, i: discord.Interaction):
        # Cache answers from this page
        for comp in self.children:  # type: ignore
            label_txt = getattr(comp, "label", None) or comp._underlying.label
            self.collected.append((label_txt, comp.value))  # type: ignore

        next_idx = self.idx + 5
        if next_idx < len(STAFF_QUESTION_SETS[self.role]):
            view = ContinueView(self.role, next_idx, list(self.collected), self.db)
            await i.response.send_message(
                "Page saved — click **Continue** to answer the next set:",
                view=view,
                ephemeral=True,
            )
            # Store the message on the view for timeout edits
            view.message = await i.original_response()
            return

        # All questions answered: build embed & post to review channel
        review_ch = i.guild.get_channel(STAFF_APPLICATION_CH_ID)
        if not review_ch:
            return await i.response.send_message(
                "Review channel missing.", ephemeral=True
            )

        embed = (
            discord.Embed(
                title=f"{self.role} Application",
                colour=discord.Color.orange(),
                timestamp=datetime.now(timezone.utc),
            )
            .set_author(name=str(i.user), icon_url=i.user.display_avatar.url)
            .set_footer(text=f"User ID: {i.user.id}")
        )

        for idx, (q, a) in enumerate(self.collected, 1):
            # Truncate to embed field limit (1 024)
            val = a or "N/A"
            if len(val) > 1024:
                val = f"{val[:1021]}…"
            embed.add_field(name=f"{idx}. {q}", value=val, inline=False)

        view = StaffApplicationActionView(i.guild, i.user.id, self.role, self.db)
        msg = await review_ch.send(f"<@&{ADMIN_ROLE_ID}>", embed=embed, view=view)

        await self.db.add_staff_app(i.user.id, self.role, msg.id)
        await i.response.send_message(
            "✅ Your staff application was submitted.", ephemeral=True
        )


# ══════════════ STAFF APPLICATION REVIEW (ActionView) ══════════════
class StaffApplicationActionView(discord.ui.View):
    """Persistent view with Accept / Deny buttons for admins."""

    def __init__(self, guild: discord.Guild, applicant_id: int, role: str, db):
        super().__init__(timeout=None)
        self.guild: discord.Guild = guild
        self.applicant_id: int = applicant_id
        self.role: str = role
        self.db = db
        # keep for duplicate-view guard
        self.message_id: Optional[int] = None

    # ────────── helpers ──────────
    async def _authorised(self, member: discord.Member) -> bool:
        return member.guild_permissions.administrator or any(
            r.id in STAFF_ROLE_IDS.values() for r in member.roles
        )

    async def _notify(self, txt: str):
        user = await safe_fetch(self.guild, self.applicant_id)
        if user:
            try:
                await user.send(txt)
            except discord.Forbidden:
                log.debug("Could not DM applicant %s", self.applicant_id)

    async def _finish(self, i: discord.Interaction, colour: discord.Colour):
        emb = i.message.embeds[0]
        emb.colour = colour
        self.disable_all_items()
        await i.message.edit(embed=emb, view=self)
        self.stop()

    # ────────── buttons ──────────
    @discord.ui.button(
        label="Accept",
        style=discord.ButtonStyle.success,
        emoji="✅",
        custom_id="staff_app_accept",
    )
    async def accept(self, i: discord.Interaction, _):
        # Acknowledge interaction immediately
        await i.response.defer(ephemeral=True)
        
        if not await self._authorised(i.user):
            return await i.followup.send("Not authorised.", ephemeral=True)

        applicant = await safe_fetch(self.guild, self.applicant_id)
        if not applicant:
            return await i.followup.send("Applicant left.", ephemeral=True)

        role_obj = self.guild.get_role(STAFF_ROLE_IDS[self.role])
        if not role_obj:
            return await i.followup.send("Role missing.", ephemeral=True)

        try:
            await applicant.add_roles(role_obj, reason="Staff application accepted")
        except discord.Forbidden:
            await self.db.update_staff_app_status(i.message.id, "error")
            return await i.followup.send(
                "Cannot add role – my role is lower than the target role.",
                ephemeral=True,
            )

        await self.db.update_staff_app_status(i.message.id, "accepted")
        await i.followup.send(f"{applicant.mention} accepted ✅", ephemeral=True)
        await self._finish(i, discord.Color.green())
        await self._notify(f"🎉 You have been **accepted** as **{self.role}**!")

    @discord.ui.button(
        label="Deny",
        style=discord.ButtonStyle.danger,
        emoji="⛔",
        custom_id="staff_app_deny",
    )
    async def deny(self, i: discord.Interaction, _):
        # Acknowledge interaction immediately
        await i.response.defer(ephemeral=True)
        
        if not await self._authorised(i.user):
            return await i.followup.send("Not authorised.", ephemeral=True)

        await self.db.update_staff_app_status(i.message.id, "denied")
        await i.followup.send("Application denied ⛔", ephemeral=True)
        await self._finish(i, discord.Color.red())
        await self._notify(f"❌ Your application for **{self.role}** was **denied**.")


# ═════════════ setup entry-point ═════════════
async def setup(bot: commands.Bot, db):
    await bot.add_cog(StaffApplicationsCog(bot, db))


FILE: cogs\stats.py
----------------------------------------
# cogs/stats.py  –  FULL production version  (2024-09-23)
# This file contains every line required by the original cog
# plus the fixes discussed in the support thread.
from __future__ import annotations

# ────────────────────────── stdlib & 3rd-party ──────────────────────────
import os, re, json, statistics, datetime
import aiohttp
import cachetools
import discord
from discord import app_commands
from discord.ext import commands

# ════════════════════════════════════════
#               CONFIG
# ════════════════════════════════════════
STEAM_API_KEY = os.getenv("STEAM_API_KEY")            # ← MUST be set
BM_TOKEN      = os.getenv("BATTLEMETRICS_TOKEN", "")
BM_HEADERS    = {"Authorization": f"Bearer {BM_TOKEN}"} if BM_TOKEN else {}

APPID_RUST = 252490

PROFILE_RE   = re.compile(r"https?://steamcommunity\.com/(?:profiles|id)/([^/]+)")
PLAYER_CACHE = cachetools.TTLCache(maxsize=1_000, ttl=300)   # 5-minute cache

RISK_FLAG_EXPLANATIONS = {
    "🔒 Private profile":            "Profile not public",
    "👤 Default avatar":             "Using default Steam avatar",
    "🆕 New account":                "Account < 30 days old",
    "⬇️ Low Steam level":            "Level < 10",
    "🎮 Few games":                  "Owns < 3 games",
    "👥 Few friends":                "Has < 3 friends",
    "⚠️ Recent ban":                 "Ban in last 90 days",
    "⚠️ Very recent ban":            "Ban in last 14 days",
    "⚠️ Multiple bans":              "More than one VAC / game ban",
    "🔴 BattleMetrics ban":          "Banned on BattleMetrics",
    "🔴 EAC ban":                    "EAC ban recorded",
    "🔴 RustBans ban":               "Banned on RustBans",
    "⚠️ SteamRep flagged":           "Negative SteamRep",
    "✏️ Frequent name changes":      "≥ 3 previous names",
    "🕵️‍♂️ Suspicious name":          "Alt / smurf style name",
    "🕹️ Rust-only account":          "Only owns Rust (plus F2P)",
    "⏳ High Rust hours (fast)":      "High hours but new account",
}

# ────────────────────────────────────────────────────────────────
### BASELINE SECTION – put this once near the top of your cog
# ────────────────────────────────────────────────────────────────

RAW_SAMPLES: list[dict] = [
    # 1
    {"kill_scientist":354,"kill_bear":55,"kill_wolf":39,"kill_boar":83,"kill_deer":12,"kill_horse":65,"death_suicide":682,"death_fall":24,"harvest_wood":2362390,"harvest_stones":1403171,"harvest_metal_ore":2964557,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":197998,"acq_scrap":282686,"acq_cloth":17461,"acq_leather":7734,"build_place":37247,"build_upgrade":10749,"barrels":26798,"bps":1070,"pipes":1980,"wires":762,"waves":213,"horse_miles":86,"horses_ridden":65,"calories":914399,"water":276831,"map_open":189793,"inv_open":443857,"items_crafted":22261,"shots_fired":609332,"shots_hit":253134,"arrow_fired":5637,"arrow_hit":2870,"headshot_hits":13704,"kill_player":3178,"death_player":3436,"_hours":3511},
    # 2
    {"kill_scientist":177,"kill_bear":26,"kill_wolf":17,"kill_boar":29,"kill_deer":5,"kill_horse":66,"death_suicide":186,"death_fall":10,"harvest_wood":609213,"harvest_stones":723570,"harvest_metal_ore":1054506,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":32355,"acq_scrap":59674,"acq_cloth":14140,"acq_leather":2432,"build_place":42145,"build_upgrade":17988,"barrels":14600,"bps":886,"pipes":322,"wires":826,"waves":34,"horse_miles":16,"horses_ridden":66,"calories":241643,"water":75164,"map_open":40893,"inv_open":139486,"items_crafted":6758,"shots_fired":7692,"shots_hit":4204,"arrow_fired":983,"arrow_hit":477,"headshot_hits":743,"kill_player":511,"death_player":1115,"_hours":1361},
    # 3
    {"kill_scientist":150,"kill_bear":4,"kill_wolf":11,"kill_boar":24,"kill_deer":7,"kill_horse":4,"death_suicide":112,"death_fall":1,"harvest_wood":89169,"harvest_stones":76421,"harvest_metal_ore":507135,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":10907,"acq_scrap":13242,"acq_cloth":2684,"acq_leather":1141,"build_place":3041,"build_upgrade":2730,"barrels":4066,"bps":267,"pipes":0,"wires":15,"waves":0,"horse_miles":3,"horses_ridden":4,"calories":138684,"water":40459,"map_open":8922,"inv_open":48483,"items_crafted":2389,"shots_fired":42379,"shots_hit":19476,"arrow_fired":988,"arrow_hit":533,"headshot_hits":2057,"kill_player":470,"death_player":443,"_hours":407},
    # 4
    {"kill_scientist":7274,"kill_bear":554,"kill_wolf":288,"kill_boar":1010,"kill_deer":63,"kill_horse":231,"death_suicide":2799,"death_fall":201,"harvest_wood":559046,"harvest_stones":560009,"harvest_metal_ore":6190220,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":189473,"acq_scrap":217267,"acq_cloth":22015,"acq_leather":4009,"build_place":213313,"build_upgrade":73828,"barrels":46328,"bps":3881,"pipes":656,"wires":1772,"waves":513,"horse_miles":1655,"horses_ridden":231,"calories":1322232,"water":384341,"map_open":78908,"inv_open":635818,"items_crafted":30236,"shots_fired":244968,"shots_hit":117231,"arrow_fired":9018,"arrow_hit":6484,"headshot_hits":19610,"kill_player":12363,"death_player":4277,"_hours":4505},
    # 5
    {"kill_scientist":77,"kill_bear":30,"kill_wolf":23,"kill_boar":60,"kill_deer":44,"kill_horse":118,"death_suicide":328,"death_fall":14,"harvest_wood":571628,"harvest_stones":248131,"harvest_metal_ore":659782,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":34781,"acq_scrap":62898,"acq_cloth":13846,"acq_leather":5828,"build_place":2979,"build_upgrade":2754,"barrels":6998,"bps":213,"pipes":0,"wires":39,"waves":5,"horse_miles":36,"horses_ridden":118,"calories":245011,"water":108200,"map_open":29552,"inv_open":107325,"items_crafted":1705,"shots_fired":21212,"shots_hit":12931,"arrow_fired":1830,"arrow_hit":903,"headshot_hits":719,"kill_player":406,"death_player":1357,"_hours":895},
    # 6
    {"kill_scientist":508,"kill_bear":70,"kill_wolf":32,"kill_boar":117,"kill_deer":27,"kill_horse":49,"death_suicide":135,"death_fall":8,"harvest_wood":122734,"harvest_stones":137361,"harvest_metal_ore":1842790,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":43915,"acq_scrap":36475,"acq_cloth":6891,"acq_leather":1203,"build_place":10966,"build_upgrade":9572,"barrels":11272,"bps":1139,"pipes":153,"wires":668,"waves":29,"horse_miles":83,"horses_ridden":49,"calories":191708,"water":52369,"map_open":15614,"inv_open":92130,"items_crafted":6765,"shots_fired":10528,"shots_hit":5882,"arrow_fired":824,"arrow_hit":559,"headshot_hits":1305,"kill_player":753,"death_player":522,"_hours":560},
    # 7
    {"kill_scientist":127,"kill_bear":25,"kill_wolf":32,"kill_boar":51,"kill_deer":2,"kill_horse":74,"death_suicide":267,"death_fall":11,"harvest_wood":392618,"harvest_stones":316605,"harvest_metal_ore":892631,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":28336,"acq_scrap":71849,"acq_cloth":6066,"acq_leather":1883,"build_place":8435,"build_upgrade":6904,"barrels":7956,"bps":771,"pipes":0,"wires":0,"waves":42,"horse_miles":34,"horses_ridden":74,"calories":336570,"water":134404,"map_open":32268,"inv_open":118623,"items_crafted":3116,"shots_fired":57902,"shots_hit":27645,"arrow_fired":2431,"arrow_hit":1341,"headshot_hits":1756,"kill_player":730,"death_player":1093,"_hours":1076},
    # 8
    {"kill_scientist":94,"kill_bear":36,"kill_wolf":23,"kill_boar":85,"kill_deer":31,"kill_horse":111,"death_suicide":239,"death_fall":21,"harvest_wood":299206,"harvest_stones":406888,"harvest_metal_ore":1013881,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":33126,"acq_scrap":39103,"acq_cloth":25362,"acq_leather":5173,"build_place":23754,"build_upgrade":13041,"barrels":7606,"bps":353,"pipes":328,"wires":1398,"waves":222,"horse_miles":22,"horses_ridden":111,"calories":316711,"water":85832,"map_open":28185,"inv_open":160681,"items_crafted":10638,"shots_fired":20496,"shots_hit":10767,"arrow_fired":1098,"arrow_hit":571,"headshot_hits":1421,"kill_player":638,"death_player":1102,"_hours":1005},
    # 9
    {"kill_scientist":1538,"kill_bear":74,"kill_wolf":85,"kill_boar":148,"kill_deer":14,"kill_horse":132,"death_suicide":236,"death_fall":5,"harvest_wood":61552,"harvest_stones":124968,"harvest_metal_ore":2466700,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":28056,"acq_scrap":25135,"acq_cloth":1982,"acq_leather":700,"build_place":18518,"build_upgrade":14925,"barrels":16192,"bps":1333,"pipes":221,"wires":477,"waves":66,"horse_miles":224,"horses_ridden":132,"calories":589583,"water":156402,"map_open":65653,"inv_open":261916,"items_crafted":7612,"shots_fired":39702,"shots_hit":22799,"arrow_fired":3299,"arrow_hit":1844,"headshot_hits":4655,"kill_player":2031,"death_player":1083,"_hours":1383},
    # 10
    {"kill_scientist":2942,"kill_bear":192,"kill_wolf":103,"kill_boar":286,"kill_deer":115,"kill_horse":84,"death_suicide":796,"death_fall":77,"harvest_wood":401773,"harvest_stones":405135,"harvest_metal_ore":5359024,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":328675,"acq_scrap":236977,"acq_cloth":11583,"acq_leather":2603,"build_place":106074,"build_upgrade":45983,"barrels":37434,"bps":4999,"pipes":206,"wires":244,"waves":671,"horse_miles":126,"horses_ridden":84,"calories":1429121,"water":473881,"map_open":155438,"inv_open":638920,"items_crafted":18922,"shots_fired":209520,"shots_hit":127249,"arrow_fired":7372,"arrow_hit":4373,"headshot_hits":12376,"kill_player":7000,"death_player":4515,"_hours":3254},
    # 11
    {"kill_scientist":212,"kill_bear":34,"kill_wolf":37,"kill_boar":92,"kill_deer":15,"kill_horse":33,"death_suicide":184,"death_fall":6,"harvest_wood":2064470,"harvest_stones":899024,"harvest_metal_ore":1011734,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":14565,"acq_scrap":10602,"acq_cloth":41203,"acq_leather":14470,"build_place":1372,"build_upgrade":1576,"barrels":10064,"bps":317,"pipes":0,"wires":14,"waves":10,"horse_miles":29,"horses_ridden":33,"calories":232643,"water":70585,"map_open":23424,"inv_open":113051,"items_crafted":2508,"shots_fired":10883,"shots_hit":5711,"arrow_fired":995,"arrow_hit":652,"headshot_hits":799,"kill_player":689,"death_player":616,"_hours":738},
    # 12
    {"kill_scientist":259,"kill_bear":54,"kill_wolf":61,"kill_boar":136,"kill_deer":74,"kill_horse":70,"death_suicide":320,"death_fall":2,"harvest_wood":195700,"harvest_stones":290142,"harvest_metal_ore":1091375,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":24847,"acq_scrap":21259,"acq_cloth":8975,"acq_leather":2347,"build_place":72973,"build_upgrade":17626,"barrels":10098,"bps":493,"pipes":34,"wires":292,"waves":4,"horse_miles":41,"horses_ridden":70,"calories":266304,"water":117404,"map_open":23023,"inv_open":99896,"items_crafted":6156,"shots_fired":60589,"shots_hit":35985,"arrow_fired":8192,"arrow_hit":3780,"headshot_hits":2227,"kill_player":1145,"death_player":1728,"_hours":980},
    # 13
    {"kill_scientist":80,"kill_bear":7,"kill_wolf":4,"kill_boar":26,"kill_deer":1,"kill_horse":275,"death_suicide":61,"death_fall":1,"harvest_wood":416652,"harvest_stones":356796,"harvest_metal_ore":241345,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":4340,"acq_scrap":3175,"acq_cloth":10406,"acq_leather":2997,"build_place":509,"build_upgrade":605,"barrels":2282,"bps":15,"pipes":0,"wires":0,"waves":3,"horse_miles":7,"horses_ridden":275,"calories":62326,"water":17612,"map_open":3040,"inv_open":26637,"items_crafted":540,"shots_fired":4990,"shots_hit":2850,"arrow_fired":233,"arrow_hit":96,"headshot_hits":272,"kill_player":207,"death_player":290,"_hours":165},
    # 14
    {"kill_scientist":18,"kill_bear":9,"kill_wolf":9,"kill_boar":11,"kill_deer":2,"kill_horse":5,"death_suicide":11,"death_fall":1,"harvest_wood":91199,"harvest_stones":131170,"harvest_metal_ore":204296,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":1979,"acq_scrap":2221,"acq_cloth":2986,"acq_leather":1037,"build_place":609,"build_upgrade":466,"barrels":1732,"bps":20,"pipes":0,"wires":0,"waves":1,"horse_miles":8,"horses_ridden":5,"calories":44906,"water":12002,"map_open":1605,"inv_open":11889,"items_crafted":359,"shots_fired":2129,"shots_hit":1222,"arrow_fired":227,"arrow_hit":102,"headshot_hits":163,"kill_player":80,"death_player":148,"_hours":91},
    # 15
    {"kill_scientist":20,"kill_bear":4,"kill_wolf":3,"kill_boar":18,"kill_deer":3,"kill_horse":182,"death_suicide":69,"death_fall":9,"harvest_wood":103288,"harvest_stones":40823,"harvest_metal_ore":350620,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":14851,"acq_scrap":28422,"acq_cloth":878,"acq_leather":1033,"build_place":2624,"build_upgrade":1683,"barrels":4932,"bps":232,"pipes":1669,"wires":3401,"waves":0,"horse_miles":14,"horses_ridden":182,"calories":83077,"water":24560,"map_open":6929,"inv_open":38328,"items_crafted":2931,"shots_fired":2822,"shots_hit":1919,"arrow_fired":167,"arrow_hit":82,"headshot_hits":72,"kill_player":67,"death_player":262,"_hours":596},
    # 16
    {"kill_scientist":5914,"kill_bear":73,"kill_wolf":56,"kill_boar":261,"kill_deer":29,"kill_horse":2115,"death_suicide":600,"death_fall":11,"harvest_wood":1774328,"harvest_stones":928261,"harvest_metal_ore":312497,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":18345,"acq_scrap":39335,"acq_cloth":58659,"acq_leather":16666,"build_place":40607,"build_upgrade":11907,"barrels":12252,"bps":804,"pipes":63,"wires":149,"waves":25,"horse_miles":280,"horses_ridden":2115,"calories":489067,"water":156255,"map_open":23920,"inv_open":118232,"items_crafted":5484,"shots_fired":122665,"shots_hit":58707,"arrow_fired":7151,"arrow_hit":3577,"headshot_hits":14446,"kill_player":6461,"death_player":1727,"_hours":761},
    # 17
    {"kill_scientist":373,"kill_bear":46,"kill_wolf":26,"kill_boar":59,"kill_deer":8,"kill_horse":266,"death_suicide":145,"death_fall":10,"harvest_wood":328148,"harvest_stones":456950,"harvest_metal_ore":1791943,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":33950,"acq_scrap":30473,"acq_cloth":9211,"acq_leather":4933,"build_place":50198,"build_upgrade":14947,"barrels":5776,"bps":830,"pipes":335,"wires":808,"waves":73,"horse_miles":32,"horses_ridden":266,"calories":264662,"water":90732,"map_open":38546,"inv_open":171193,"items_crafted":6471,"shots_fired":22908,"shots_hit":12084,"arrow_fired":2096,"arrow_hit":1056,"headshot_hits":1675,"kill_player":914,"death_player":1063,"_hours":711},
    # 18
    {"kill_scientist":1503,"kill_bear":164,"kill_wolf":167,"kill_boar":388,"kill_deer":95,"kill_horse":181,"death_suicide":679,"death_fall":22,"harvest_wood":2488693,"harvest_stones":1878775,"harvest_metal_ore":1121361,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":100601,"acq_scrap":71940,"acq_cloth":103517,"acq_leather":38881,"build_place":21072,"build_upgrade":14789,"barrels":31764,"bps":983,"pipes":0,"wires":75,"waves":8,"horse_miles":219,"horses_ridden":181,"calories":1154754,"water":895653,"map_open":85639,"inv_open":357509,"items_crafted":8262,"shots_fired":280702,"shots_hit":113993,"arrow_fired":19525,"arrow_hit":8795,"headshot_hits":13599,"kill_player":4174,"death_player":4826,"_hours":2258},
    # 19
    {"kill_scientist":754,"kill_bear":129,"kill_wolf":107,"kill_boar":215,"kill_deer":81,"kill_horse":105,"death_suicide":1874,"death_fall":32,"harvest_wood":726685,"harvest_stones":325399,"harvest_metal_ore":3182498,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":363139,"acq_scrap":234022,"acq_cloth":25275,"acq_leather":9316,"build_place":70992,"build_upgrade":46432,"barrels":19190,"bps":1692,"pipes":151,"wires":522,"waves":178,"horse_miles":143,"horses_ridden":105,"calories":1852308,"water":595864,"map_open":86312,"inv_open":853846,"items_crafted":30230,"shots_fired":755531,"shots_hit":277956,"arrow_fired":17509,"arrow_hit":8121,"headshot_hits":17674,"kill_player":9430,"death_player":9065,"_hours":4194},
    # 20
    {"kill_scientist":105,"kill_bear":10,"kill_wolf":12,"kill_boar":24,"kill_deer":2,"kill_horse":17,"death_suicide":64,"death_fall":1,"harvest_wood":21972,"harvest_stones":31930,"harvest_metal_ore":142886,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":4556,"acq_scrap":6244,"acq_cloth":1969,"acq_leather":582,"build_place":728,"build_upgrade":724,"barrels":2502,"bps":672,"pipes":0,"wires":12,"waves":0,"horse_miles":6,"horses_ridden":17,"calories":52617,"water":28933,"map_open":3566,"inv_open":19844,"items_crafted":1254,"shots_fired":42886,"shots_hit":16490,"arrow_fired":623,"arrow_hit":274,"headshot_hits":1363,"kill_player":277,"death_player":262,"_hours":252},
    # 21
    {"kill_scientist":2186,"kill_bear":140,"kill_wolf":117,"kill_boar":158,"kill_deer":16,"kill_horse":229,"death_suicide":518,"death_fall":39,"harvest_wood":358730,"harvest_stones":635622,"harvest_metal_ore":2111269,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":171723,"acq_scrap":256875,"acq_cloth":26341,"acq_leather":4391,"build_place":121514,"build_upgrade":63315,"barrels":24652,"bps":2982,"pipes":1,"wires":280,"waves":483,"horse_miles":310,"horses_ridden":229,"calories":1189694,"water":466139,"map_open":103053,"inv_open":504075,"items_crafted":29209,"shots_fired":663120,"shots_hit":259016,"arrow_fired":3547,"arrow_hit":1812,"headshot_hits":22469,"kill_player":7803,"death_player":3118,"_hours":2797},
    # 22
    {"kill_scientist":38,"kill_bear":3,"kill_wolf":12,"kill_boar":18,"kill_deer":0,"kill_horse":124,"death_suicide":76,"death_fall":4,"harvest_wood":669959,"harvest_stones":419266,"harvest_metal_ore":366584,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":6810,"acq_scrap":14132,"acq_cloth":14639,"acq_leather":4296,"build_place":1556,"build_upgrade":1634,"barrels":6310,"bps":168,"pipes":4,"wires":14,"waves":34,"horse_miles":3,"horses_ridden":124,"calories":135077,"water":146203,"map_open":22242,"inv_open":52607,"items_crafted":2925,"shots_fired":9061,"shots_hit":3226,"arrow_fired":352,"arrow_hit":158,"headshot_hits":533,"kill_player":185,"death_player":492,"_hours":328},
    # 23
    {"kill_scientist":90,"kill_bear":13,"kill_wolf":11,"kill_boar":18,"kill_deer":9,"kill_horse":7,"death_suicide":264,"death_fall":9,"harvest_wood":29331,"harvest_stones":109020,"harvest_metal_ore":852785,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":23538,"acq_scrap":23944,"acq_cloth":3789,"acq_leather":254,"build_place":25772,"build_upgrade":8394,"barrels":3588,"bps":70,"pipes":0,"wires":121,"waves":40,"horse_miles":19,"horses_ridden":7,"calories":215783,"water":101466,"map_open":15590,"inv_open":100174,"items_crafted":3460,"shots_fired":57964,"shots_hit":30508,"arrow_fired":2660,"arrow_hit":1552,"headshot_hits":2014,"kill_player":1221,"death_player":1532,"_hours":842}
]

def _build_baseline(samples: list[dict]) -> dict[str, dict]:
    """
    Turn RAW_SAMPLES into {stat: {mean, sd}} (per-hour).
    Keep stats with ≥3 samples and players with ≥10 h.
    """
    per_key: dict[str, list[float]] = {}
    for s in samples:
        hrs = s.get("_hours", 0)
        if hrs < 10:
            continue
        for k, v in s.items():
            if k == "_hours": 
                continue
            per_key.setdefault(k, []).append(v / hrs)

    baseline: dict[str, dict] = {}
    for k, lst in per_key.items():
        if len(lst) < 3:             # need enough samples
            continue
        mu = statistics.mean(lst)
        sd = statistics.stdev(lst) if len(lst) > 1 else 0.001
        baseline[k] = {"mean": mu, "sd": sd}

    baseline["_meta"] = {
        "generated": datetime.datetime.utcnow().isoformat(timespec="seconds"),
        "source_samples": len(samples)
    }
    return baseline

BASELINE: dict = _build_baseline(RAW_SAMPLES)

# ════════════════════════════════════════
#               COG
# ════════════════════════════════════════
class StatsCog(commands.Cog):
    """
    /check …   – risk / ban look-ups  
    /stats …   – Rust statistics
    """

    check = app_commands.Group(name="check",  description="Look-ups & checks")
    stats = app_commands.Group(name="stats",  description="Game statistics")

    def __init__(self, bot: commands.Bot):
        self.bot = bot                # no manual add_command – discord.py does it

    async def _achievements(self, sid: str):
        """
        Return unlocked-count, total-count, percentage-string.
        """
        async with aiohttp.ClientSession() as ses:
            url = ("https://api.steampowered.com/ISteamUserStats/"
                   f"GetPlayerAchievements/v1/?key={STEAM_API_KEY}"
                   f"&steamid={sid}&appid={APPID_RUST}")
            async with ses.get(url) as r:
                data = await r.json()

        ps = data.get("playerstats", {})
        if not ps.get("success"):
            return 0, 0, "N/A"

        lst = ps.get("achievements", [])
        unlocked = sum(1 for a in lst if a["achieved"])
        total    = len(lst)
        pct      = f"{unlocked/total*100:.1f}%"
        return unlocked, total, pct

    async def _playtime_and_persona(self, sid: str):
        """Return total-hrs, 2-wk-hrs, last-played-date, player-summary-dict"""
        async with aiohttp.ClientSession() as ses:
            # total / 2-week hours
            url1 = ("https://api.steampowered.com/IPlayerService/"
                    f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
            async with ses.get(url1) as r:
                og = await r.json()
        g = next((x for x in og.get("response", {}).get("games", [])
                  if x["appid"] == APPID_RUST), None)
        total_h = g["playtime_forever"] // 60 if g else 0
        two_w_h = g.get("playtime_2weeks", 0) // 60 if g else 0

        # date last played
        async with aiohttp.ClientSession() as ses:
            url2 = ("https://api.steampowered.com/IPlayerService/"
                    f"GetRecentlyPlayedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
            async with ses.get(url2) as r:
                rp = await r.json()
        recent = next((x for x in rp.get("response", {}).get("games", [])
                       if x["appid"] == APPID_RUST), None)
        last_play = (datetime.datetime.utcfromtimestamp(recent["playtime_at"])
                     .strftime("%Y-%m-%d")
                     if recent and "playtime_at" in recent else "Unknown")

        # persona / avatar / profile-url
        async with aiohttp.ClientSession() as ses:
            url3 = ("https://api.steampowered.com/ISteamUser/"
                    f"GetPlayerSummaries/v2/?key={STEAM_API_KEY}&steamids={sid}")
            async with ses.get(url3) as r:
                prof = (await r.json())["response"]["players"][0]

        return total_h, two_w_h, last_play, prof

    # ────────────────────────────────
    #   /check help
    # ────────────────────────────────
    @check.command(name="help", description="Explain risk flags")
    async def check_help(self, inter: discord.Interaction):
        txt = "\n".join(f"{k} — {v}" for k, v in RISK_FLAG_EXPLANATIONS.items())
        await inter.response.send_message(txt, ephemeral=True)

    # ────────────────────────────────
    #   /check player
    # ────────────────────────────────
    @check.command(name="player", description="Steam profile & ban check")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def check_player(self, inter: discord.Interaction, steamid: str):

        if not STEAM_API_KEY:
            return await inter.response.send_message(
                "Steam API key is not configured on this bot.", ephemeral=True
            )

        await inter.response.defer(ephemeral=True)

        # ───── SteamID resolution ─────
        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send(
                "Unable to resolve SteamID.", ephemeral=True
            )

        # ───── fetch (with 5-min cache) ─────
        if sid in PLAYER_CACHE:
            (bans, prof, lvl, game_cnt, friend_cnt, top_games,
             bm_prof, bm_bans, eac, names,
             rb_status, rb_reason, rb_date,
             sr_status, rust_h, two_w_h,
             comments, patterns) = PLAYER_CACHE[sid]
        else:
            bans, prof = await self._steam_bans_and_profile(sid)
            lvl, game_cnt, friend_cnt, top_games = \
                await self._level_games_friends(sid)
            bm_prof, bm_bans, eac, names = await self._bm_info(sid)
            rb_status, rb_reason, rb_date = await self._rustbans_info(sid)
            sr_status = await self._steamrep_info(sid)
            rust_h, two_w_h = await self._rust_hours(sid)
            comments = await self._profile_comments(sid)
            patterns = [n for n in names
                        if re.search(r"(alt|smurf|rust|\d{5,})", n, re.I)]
            PLAYER_CACHE[sid] = (bans, prof, lvl, game_cnt, friend_cnt,
                                 top_games, bm_prof, bm_bans, eac, names,
                                 rb_status, rb_reason, rb_date,
                                 sr_status, rust_h, two_w_h,
                                 comments, patterns)

        # ───── risk / flag analysis ─────
        now = datetime.datetime.utcnow()
        created = (datetime.datetime.utcfromtimestamp(prof.get("timecreated", 0))
                   if prof.get("timecreated") else None)
        age = (now - created).days if created else None

        total_bans   = (bans.get("NumberOfVACBans", 0) or 0) + \
                       (bans.get("NumberOfGameBans", 0) or 0)
        has_any_ban  = bans.get("VACBanned") or total_bans

        recent_ban   = has_any_ban and bans.get("DaysSinceLastBan", 9999) <= 90
        very_recent  = has_any_ban and bans.get("DaysSinceLastBan", 9999) <= 14
        low_lvl      = lvl is not None and lvl < 6
        low_games    = game_cnt is not None and game_cnt < 3
        rust_only    = (game_cnt is not None and game_cnt <= 2
                        and top_games and top_games[0]["name"].lower() == "rust")
        low_friends  = friend_cnt is not None and friend_cnt < 3
        private      = prof.get("communityvisibilitystate", 3) != 3
        default_av   = prof.get("avatarfull", "").endswith("/avatar.jpg")
        many_names   = len(names) >= 3
        multi_bans   = total_bans > 1
        suspicious_name = bool(patterns)
        fast_rust    = (rust_h is not None and age is not None
                        and rust_h > 100 and age < 30)

        flags: list[str] = []
        if private:         flags.append("🔒 Private profile")
        if default_av:      flags.append("👤 Default avatar")
        if age is not None and age < 30: flags.append("🆕 New account")
        if low_lvl:         flags.append("⬇️ Low Steam level")
        if low_games:       flags.append("🎮 Few games")
        if low_friends:     flags.append("👥 Few friends")
        if very_recent:     flags.append("⚠️ Very recent ban")
        elif recent_ban:    flags.append("⚠️ Recent ban")
        if multi_bans:      flags.append("⚠️ Multiple bans")
        if bm_bans:         flags.append("🔴 BattleMetrics ban")
        if eac:             flags.append("🔴 EAC ban")
        if rb_status:       flags.append("🔴 RustBans ban")
        if sr_status:       flags.append("⚠️ SteamRep flagged")
        if many_names:      flags.append("✏️ Frequent name changes")
        if suspicious_name: flags.append("🕵️‍♂️ Suspicious name")
        if rust_only:       flags.append("🕹️ Rust-only account")
        if fast_rust:       flags.append("⏳ High Rust hrs (fast)")

        # ───── numeric score ─────
        score = 0
        if private:                        score += 2
        if default_av:                     score += 1
        if age is not None:
            score += 5 if age < 7 else 3 if age < 30 else 0
        if low_lvl:                        score += 2
        if lvl and lvl > 50:               score -= 2
        if low_games:                      score += 3
        if game_cnt and game_cnt > 100:    score -= 2
        if low_friends:                    score += 2
        if friend_cnt and friend_cnt > 100:score -= 1
        if very_recent:                    score += 8
        elif recent_ban:                   score += 5
        if multi_bans:                     score += 3
        if bm_bans:                        score += 5
        if eac:                            score += 5
        if rb_status:                      score += 5
        if sr_status:                      score += 5
        if many_names:                     score += 1
        if suspicious_name:                score += 2
        if rust_only:                      score += 2
        if fast_rust:                      score += 2
        score = max(score, 0)

        risk, colour = (
            ("🔴  HIGH RISK",     discord.Color.red())     if score >= 12 else
            ("🟠  MODERATE RISK", discord.Color.orange())  if score >= 5  else
            ("🟢  LOW RISK",      discord.Color.green())
        )

        # ───── embed skeleton ─────
        e = discord.Embed(
                title=prof.get("personaname", "Unknown"),
                url=prof.get("profileurl"),
                colour=colour,
                description=f"{risk}\n\n{' '.join(flags) or 'No immediate risk factors.'}"
            ).set_footer(text=f"SteamID64: {sid}  |  Score: {score}")
        if prof.get("avatarfull"):
            e.set_thumbnail(url=prof["avatarfull"])

        fmt = lambda n: f"{n:,}" if n is not None else "N/A"

        # ───── neat blocks ─────
        # Account block
        account_block = "\n".join([
            f"Created : {created.strftime('%Y-%m-%d') if created else 'N/A'}",
            f"Age     : {age} d" if age is not None else "Age     : N/A",
            f"Level   : {fmt(lvl)}",
            f"Games   : {fmt(game_cnt)}",
            ("Friends : " +
             ("Private" if friend_cnt is None else fmt(friend_cnt))),
            f"Status  : {'Private' if private else 'Public'}",
        ])
        e.add_field(name="Account", value=f"```ini\n{account_block}\n```",
                    inline=False)

        # Activity block
        activity_block = "\n".join([
            f"Rust hours  : {fmt(rust_h)}",
            f"2-weeks hrs : {fmt(two_w_h)}",
        ])
        e.add_field(name="Activity", value=f"```ini\n{activity_block}\n```",
                    inline=False)

        # Top games (already hours)
        if top_games:
            tg_list = "\n".join(
                f"{g['name'][:25]:25}  {g['playtime']:>6,} h"
                for g in top_games[:5]
            )
            e.add_field(name="Top games (hours)",
                        value=f"```ini\n{tg_list}\n```",
                        inline=False)

        # Bans / reputation
        ban_lines = [
            f"VAC             : {'Yes' if bans['VACBanned'] else 'No'} "
            f"({bans['NumberOfVACBans']})",
            f"Game bans       : {bans['NumberOfGameBans']}",
            f"Comm ban        : {'Yes' if bans['CommunityBanned'] else 'No'}",
            f"Trade ban       : {bans['EconomyBan'].capitalize()}",
        ]
        if eac is not None:
            ban_lines.append(f"EAC ban         : {'Yes' if eac else 'No'}")
        ban_lines.append(
            f"BattleMetrics   : "
            f"{len(bm_bans)} ban(s)" if bm_bans else "BattleMetrics   : None")
        ban_lines.append(
            f"RustBans        : {rb_status or 'None'}")
        ban_lines.append(
            f"SteamRep        : {sr_status or 'Clean'}")
        e.add_field(name="Bans / reputation",
                    value=f"```ini\n" + "\n".join(ban_lines) + "\n```",
                    inline=False)

        # BattleMetrics details (if any bans) – separate block to avoid clutter
        if bm_prof:
            bm_url = f"https://www.battlemetrics.com/rcon/players/{bm_prof['id']}"
            if bm_bans:
                bm_text = f"[Profile]({bm_url}) — **{len(bm_bans)} ban(s)**\n"
                for b in bm_bans[:3]:
                    org    = (b['attributes'].get('organization', {})
                              .get('name') or 'Org')
                    reason = b['attributes'].get('reason') or 'No reason'
                    date   = (b['attributes'].get('timestamp') or '')[:10]
                    bm_text += f"• {org}: {reason} ({date})\n"
                if len(bm_bans) > 3:
                    bm_text += f"…and {len(bm_bans)-3} more"
            else:
                bm_text = f"[Profile]({bm_url}) — no bans"
            e.add_field(name="BattleMetrics details", value=bm_text, inline=False)

        # Previous names / comments
        if names:
            e.add_field(name="Previous names",
                        value="\n".join(names[:10]), inline=False)
        if comments:
            e.add_field(name="Profile comments",
                        value="\n".join(comments[:5]), inline=False)

        # Glossary (only for flags present)
        if flags:
            glossary = "\n".join(f"{f} — {RISK_FLAG_EXPLANATIONS[f]}"
                                 for f in flags)
            e.add_field(name="Flag glossary", value=glossary, inline=False)

        # Links
        links = [
            f"[Steam]({prof.get('profileurl')})",
            (f"[BattleMetrics](https://www.battlemetrics.com/rcon/players/"
             f"{bm_prof['id']})" if bm_prof else None),
            f"[RustBans](https://rustbans.com/lookup/{sid})",
            f"[SteamDB](https://steamdb.info/calculator/{sid}/)",
            f"[SteamRep](https://steamrep.com/profiles/{sid})",
        ]
        e.add_field(name="Links",
                    value=" | ".join(l for l in links if l),
                    inline=False)

        await inter.followup.send(embed=e, ephemeral=True)

    # ────────────────────────────────
    #   /dump raw stats
    # ────────────────────────────────
    @app_commands.command(name="dump_rust_raw", description="DM-dump raw stats with hours")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def dump_rust_raw(self, inter: discord.Interaction, steamid: str):
        await inter.response.defer(ephemeral=True)
        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send("SteamID could not be resolved.", ephemeral=True)
        ok, raw = await self._rust_stats(sid)
        if not ok:
            return await inter.followup.send("Stats private / unavailable.", ephemeral=True)
        # Fetch total Rust hours (lifetime)
        tot_h, *_ = await self._rust_hours(sid)
        if tot_h is not None:
            raw["_hours"] = tot_h
        await inter.followup.send(
            "Copy & save this JSON for baseline analysis:\n"
            f"```json\n{json.dumps(raw, indent=2)}```",
            ephemeral=True
        )

    # ────────────────────────────────────────────────────────────────
    ### /stats rust  –  baseline-aware version
    # ────────────────────────────────────────────────────────────────
    @stats.command(name="rust", description="Rust hours & detailed risk assessment")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def rust_stats(self, inter: discord.Interaction, steamid: str):

        if not STEAM_API_KEY:
            return await inter.response.send_message(
                "Steam API key not configured on this bot.", ephemeral=True
            )
        await inter.response.defer(ephemeral=True)

        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send("Unable to resolve SteamID.",
                                            ephemeral=True)

        # ─── top-level activity ────────────────────────────────────
        tot_h, twk_h, last_play, profile = await self._playtime_and_persona(sid)
        ach_unl, ach_tot, ach_pct = await self._achievements(sid)

        pres_steam = "Yes" if profile.get("gameid") == str(APPID_RUST) else "No"
        bm_prof, *_ = await self._bm_info(sid)
        bm_online = bm_sessions = "N/A"
        if bm_prof:
            _, online, _, sessions, _ = await self._bm_sessions(bm_prof["id"])
            bm_online   = "Yes" if online else "No"
            bm_sessions = sessions

        # ─── detailed stats ────────────────────────────────────────
        ok, st = await self._rust_stats(sid)
        if not ok:
            return await inter.followup.send(
                "Detailed stats are private / unavailable.", ephemeral=True
            )

        # helpers & derived PvP numbers
        fmt = lambda n: "N/A" if n in (None, 0, "N/A") else f"{n:,}"
        b_fired, b_hit = st["shots_fired"], st["shots_hit"]
        a_fired, a_hit = st["arrow_fired"], st["arrow_hit"]

        bullet_acc = b_hit / b_fired if b_fired else 0
        arrow_acc  = a_hit / a_fired if a_fired else 0
        head_acc   = st["headshot_hits"] / b_hit if b_hit else 0
        kills, deaths = st["kill_player"], st["death_player"]
        kd = kills / deaths if deaths else (999 if kills else 0)

        # ─── risk assessment  (baseline z-scores + PvP caps) ───────
        BIG_Z, MID_Z, MIN_H = 3.5, 2.5, 10
        score, flags = 0, []

        if tot_h and tot_h >= MIN_H:
            for key, val in st.items():
                if key not in BASELINE: 
                    continue
                mu, sd = BASELINE[key]["mean"], BASELINE[key]["sd"]
                if sd < 1e-6: 
                    continue
                z = (val / tot_h - mu) / sd
                if z >= BIG_Z:
                    flags.append(f"🔴 {key} per-h very high (z={z:.1f})")
                    score += 2
                elif z <= -BIG_Z:
                    flags.append(f"🔴 {key} per-h very low (z={z:.1f})")
                    score += 2
                elif z >= MID_Z:
                    flags.append(f"⚠️ {key} per-h high (z={z:.1f})")
                    score += 1
                elif z <= -MID_Z:
                    flags.append(f"⚠️ {key} per-h low (z={z:.1f})")
                    score += 1

        def pvp_cap(name: str, val: float, thresh: float):
            nonlocal score
            if val >= thresh:
                flags.append(f"⚠️ {name} {val:.2f} ≥ {thresh}")
                score += 2
        pvp_cap("Bullet acc.", bullet_acc, 0.45)
        pvp_cap("Head-shot acc.", head_acc, 0.40)
        pvp_cap("Arrow acc.", arrow_acc, 0.60)
        pvp_cap("K/D", kd, 5.0)

        risk, colour = (
            ("🔴  HIGH RISK",     discord.Color.red())    if score >= 15 else
            ("🟠  MODERATE RISK", discord.Color.orange()) if score >= 7  else
            ("🟢  LOW RISK",      discord.Color.green())
        )

        # ─── embed ─────────────────────────────────────────────────
        e = (
            discord.Embed(
                title=f"Rust stats – [{profile.get('personaname')}]",
                url=profile.get("profileurl"),
                colour=colour,
                description=f"{risk}\n\n" +
                            (" ".join(flags) if flags else "No risk indicators triggered.")
            )
            .set_footer(text=f"SteamID64: {sid}  |  Score: {score}")
        )
        if profile.get("avatarfull"):
            e.set_thumbnail(url=profile["avatarfull"])

        # blocks (summary / PvP / PvE / resources / misc)
        summary = "\n".join([
            f"Total hrs  : {fmt(tot_h)}",
            f"2-wks hrs  : {fmt(twk_h)}",
            f"Last played: {last_play}",
            f"Achievement: {ach_unl}/{ach_tot} ({ach_pct})",
            f"Steam pres.: {pres_steam}",
            f"BM pres.   : {bm_online}",
            f"BM sessions: {fmt(bm_sessions)}",
        ])
        e.add_field(name="Summary", value=f"```ini\n{summary}\n```", inline=False)

        pvp_blk = "\n".join([
            f"Kills  : {fmt(kills)}",
            f"Deaths : {fmt(deaths)}   (K/D {kd:.2f})",
            f"Bullets: {fmt(b_hit)} / {fmt(b_fired)} ({bullet_acc*100:4.1f} %)",
            f"Head-shot acc.: {head_acc*100:4.1f} %",
            f"Arrows : {fmt(a_hit)} / {fmt(a_fired)} ({arrow_acc*100:4.1f} %)",
        ])
        e.add_field(name="PvP", value=f"```ini\n{pvp_blk}\n```", inline=False)

        pve = "\n".join([
            f"Scientists: {fmt(st['kill_scientist'])}",
            f"Bears     : {fmt(st['kill_bear'])}",
            f"Wolves    : {fmt(st['kill_wolf'])}",
            f"Boars     : {fmt(st['kill_boar'])}",
            f"Deer      : {fmt(st['kill_deer'])}",
            f"Horses    : {fmt(st['kill_horse'])}",
        ])
        other_deaths = "\n".join([
            f"Suicides: {fmt(st['death_suicide'])}",
            f"Falling : {fmt(st['death_fall'])}",
        ])
        e.add_field(name="PvE kills", value=f"```ini\n{pve}\n```", inline=True)
        e.add_field(name="Other deaths", value=f"```ini\n{other_deaths}\n```",
                    inline=True)
        e.add_field(name="\u200b", value="\u200b", inline=False)

        nodes = "\n".join([
            f"Wood      : {fmt(st['harvest_wood'])}",
            f"Stone     : {fmt(st['harvest_stones'])}",
            f"Metal ore : {fmt(st['harvest_metal_ore'])}",
            f"HQ ore    : {fmt(st['harvest_hq_metal_ore'])}",
            f"Sulfur ore: {fmt(st['harvest_sulfur_ore'])}",
        ])
        pickups = "\n".join([
            f"Low-grade : {fmt(st['acq_lowgrade'])}",
            f"Scrap     : {fmt(st['acq_scrap'])}",
            f"Cloth     : {fmt(st['acq_cloth'])}",
            f"Leather   : {fmt(st['acq_leather'])}",
        ])
        build = "\n".join([
            f"Blocks placed : {fmt(st['build_place'])}",
            f"Blocks upgrade: {fmt(st['build_upgrade'])}",
            f"Barrels broken: {fmt(st['barrels'])}",
            f"BPs learned   : {fmt(st['bps'])}",
        ])
        e.add_field(name="Resources (nodes)",
                    value=f"```ini\n{nodes}\n```", inline=True)
        e.add_field(name="Resources (pick-ups)",
                    value=f"```ini\n{pickups}\n```", inline=True)
        e.add_field(name="Building / Loot",
                    value=f"```ini\n{build}\n```", inline=True)
        e.add_field(name="\u200b", value="\u200b", inline=False)

        social = "\n".join([
            f"Wires conn.: {fmt(st['wires'])}",
            f"Pipes conn.: {fmt(st['pipes'])}",
            f"Friendly waves: {fmt(st['waves'])}",
        ])
        horses = "\n".join([
            f"Miles ridden : {fmt(st['horse_miles'])}",
            f"Horses ridden: {fmt(st['horses_ridden'])}",
        ])
        ui = "\n".join([
            f"Calories : {fmt(st['calories'])}",
            f"Water    : {fmt(st['water'])}",
            f"Map opens: {fmt(st['map_open'])}",
            f"Inv opens: {fmt(st['inv_open'])}",
            f"Crafted  : {fmt(st['items_crafted'])}",
        ])
        e.add_field(name="Electric / Social",
                    value=f"```ini\n{social}\n```", inline=True)
        e.add_field(name="Horses",
                    value=f"```ini\n{horses}\n```", inline=True)
        e.add_field(name="Consumption / UI",
                    value=f"```ini\n{ui}\n```", inline=True)

        await inter.followup.send(embed=e, ephemeral=True)

    # ═══════════════════════ helper methods ════════════════════════
    async def _resolve(self, raw: str):
        if raw.isdigit() and len(raw) >= 16:
            return raw
        m = PROFILE_RE.search(raw)
        if not m:
            return None
        vanity = m.group(1)
        if vanity.isdigit():
            return vanity
        url = ("https://api.steampowered.com/ISteamUser/ResolveVanityURL/v1/"
               f"?key={STEAM_API_KEY}&vanityurl={vanity}")
        async with aiohttp.ClientSession() as s, s.get(url) as r:
            data = await r.json()
        return data["response"].get("steamid")

    async def _steam_bans_and_profile(self, sid: str):
        async with aiohttp.ClientSession() as ses:
            url_b = ("https://api.steampowered.com/ISteamUser/GetPlayerBans/v1/"
                     f"?key={STEAM_API_KEY}&steamids={sid}")
            url_p = ("https://api.steampowered.com/ISteamUser/"
                     f"GetPlayerSummaries/v2/?key={STEAM_API_KEY}&steamids={sid}")
            async with ses.get(url_b) as r1, ses.get(url_p) as r2:
                bans = (await r1.json())["players"][0]
                prof = (await r2.json())["response"]["players"][0]
        return bans, prof

    async def _bm_info(self, sid: str):
        if not sid.isdigit():
            return None, [], None, []
        async with aiohttp.ClientSession() as ses:
            url = f"https://api.battlemetrics.com/players?filter[search]={sid}"
            async with ses.get(url, headers=BM_HEADERS) as r:
                data = await r.json()
        if not data.get("data"):
            return None, [], None, []
        prof = data["data"][0]
        pid  = prof["id"]
        async with aiohttp.ClientSession() as ses:
            url = (f"https://api.battlemetrics.com/bans?"
                   f"filter[player]={pid}&sort=-timestamp")
            async with ses.get(url, headers=BM_HEADERS) as r:
                bans = (await r.json()).get("data", [])
        flags = prof["attributes"].get("flags", [])
        eac   = any("eac" in (f or "").lower() for f in flags)
        names = [n.get("name", "Unknown")
                 for n in prof["attributes"].get("names", [])[::-1]]
        return prof, bans, eac, names

    async def _bm_sessions(self, pid: str):
        url = ("https://api.battlemetrics.com/sessions?"
               f"filter[player]={pid}&page[size]=100&include=server&sort=-start")
        async with aiohttp.ClientSession() as ses, ses.get(url, headers=BM_HEADERS) as r:
            data = await r.json()
        sess = data.get("data", [])
        srv_name = {i["id"]: i["attributes"]["name"]
                    for i in data.get("included", [])
                    if i["type"] == "server"}
        online = False
        current = None
        if sess and sess[0]["attributes"]["end"] is None:
            online = True
            sid = sess[0]["relationships"]["server"]["data"]["id"]
            current = srv_name.get(sid, "Unknown")
        return sess, online, current, len(sess), []

    async def _level_games_friends(self, sid: str):
        lvl = games = friends = None
        g_list = []
        async with aiohttp.ClientSession() as ses:
            try:
                async with ses.get(
                    "https://api.steampowered.com/IPlayerService/"
                    f"GetSteamLevel/v1/?key={STEAM_API_KEY}&steamid={sid}"
                ) as r:
                    lvl = (await r.json())["response"].get("player_level")
            except: pass
            try:
                async with ses.get(
                    "https://api.steampowered.com/IPlayerService/"
                    f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}"
                    "&include_appinfo=1"
                ) as r:
                    data = await r.json()
                    games  = data["response"].get("game_count")
                    g_list = data["response"].get("games", [])
            except: pass
            try:
                async with ses.get(
                    "https://api.steampowered.com/ISteamUser/"
                    f"GetFriendList/v1/?key={STEAM_API_KEY}&steamid={sid}"
                ) as r:
                    friends = len((await r.json())
                                  .get("friendslist", {}).get("friends", []))
            except: pass
        g_list.sort(key=lambda x: x.get("playtime_forever", 0), reverse=True)
        top_games = [{"name": g["name"],
                      "playtime": g["playtime_forever"] // 60}
                     for g in g_list[:5]]
        return lvl, games, friends, top_games

    async def _rust_hours(self, sid: str):
        async with aiohttp.ClientSession() as ses:
            try:
                url = ("https://api.steampowered.com/IPlayerService/"
                       f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
                async with ses.get(url) as r:
                    og = await r.json()
                for g in og["response"]["games"]:
                    if g["appid"] == APPID_RUST:
                        return (g["playtime_forever"] // 60,
                                g.get("playtime_2weeks", 0) // 60)
            except: pass
        return None, None

    async def _profile_comments(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                url = f"https://steamcommunity.com/profiles/{sid}/allcomments?xml=1"
                async with ses.get(url) as r:
                    text = await r.text()
            comments = re.findall(
                r"<comment thread='[^']+'>(.*?)</comment>",
                text, re.DOTALL)
            return [re.sub("<.*?>", "", c).strip()
                    for c in comments if c.strip()]
        except: return []

    async def _rustbans_info(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                async with ses.get(
                    f"https://rustbans.com/api/v2/ban/{sid}"
                ) as r:
                    if r.status == 200:
                        data = await r.json()
                        if data.get("banned"):
                            return ("Banned",
                                    data.get("reason"),
                                    data.get("timestamp", "")[:10])
        except: pass
        return None, None, None

    async def _steamrep_info(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                async with ses.get(
                    f"https://steamrep.com/api/beta4/reputation/{sid}?json=1"
                ) as r:
                    if r.status == 200:
                        data = await r.json()
                        if data.get("reputation", {}).get("summary"):
                            return data["reputation"]["summary"]
        except: pass
        return None

    # ════════════════ LONG _rust_stats helper (exactly as supplied) ════════════════
    async def _rust_stats(self, sid: str):
        """
        Return (ok: bool, stats: dict[str,int])
        Implements every rule from the specification you supplied.
        """
        async with aiohttp.ClientSession() as ses:
            url = ("https://api.steampowered.com/ISteamUserStats/"
                   f"GetUserStatsForGame/v2/?key={STEAM_API_KEY}&steamid={sid}&appid={APPID_RUST}")
            async with ses.get(url) as r:
                data = await r.json()

        raw_list = data.get("playerstats", {}).get("stats")
        if not raw_list:
            return False, {}
        raw = {s["name"]: s["value"] for s in raw_list}

        # helpers
        def _sum_prefix(pre: str) -> int:
            return sum(v for k, v in raw.items() if k.startswith(pre))

        def get(*vars: str, _sum=False, _scale=1):
            if _sum:
                tot = 0
                for v in vars:
                    tot += _sum_prefix(v[:-1]) if v.endswith("*") else raw.get(v, 0)
                return int(tot / _scale)
            for v in vars:
                val = _sum_prefix(v[:-1]) if v.endswith("*") else raw.get(v, 0)
                if val:
                    return int(val / _scale)
            return 0

        # combat
        bullets_fired = get("bullet_fired") + get("shotgun_fired")
        bullets_hit   = get("bullet_hit_*", "shotgun_hit_*", _sum=True)
        arrows_fired  = get("arrow_fired", "arrows_shot")
        arrows_hit    = get("arrow_hit_*", _sum=True)
        headshots     = get("headshot", "headshots")
        kills_player  = get("kill_player")
        deaths_player = get("death_player", "deaths")

        stats = {
            "kill_scientist": get("kill_scientist"),
            "kill_bear":      get("kill_bear"),
            "kill_wolf":      get("kill_wolf"),
            "kill_boar":      get("kill_boar"),
            "kill_deer":      get("kill_stag"),
            "kill_horse":     get("horse_mounted_count"),
            "death_suicide":  get("death_suicide", "death_selfinflicted"),
            "death_fall":     get("death_fall"),
        }

        # resources – nodes
        stats.update({
            "harvest_wood":   get("harvested_wood",  "harvest.wood"),
            "harvest_stones": get("harvested_stones","harvest.stones"),
            "harvest_metal_ore": get("acquired_metal.ore",
                                      "harvest.metal_ore", _sum=True),
            "harvest_hq_metal_ore": 0,
            "harvest_sulfur_ore":    0,
        })

        # resources – pick-ups
        stats.update({
            "acq_lowgrade": get("acquired_lowgradefuel"),
            "acq_scrap":    get("acquired_scrap"),
            "acq_cloth":    get("harvested_cloth","acquired_cloth","acquired_cloth.item"),
            "acq_leather":  get("harvested_leather","acquired_leather","acquired_leather.item"),
        })

        # building / loot / social
        stats.update({
            "build_place":   get("placed_blocks","building_blocks_placed",
                                 "buildings_placed","structure_built"),
            "build_upgrade": get("upgraded_blocks","building_blocks_upgraded",
                                 "buildings_upgraded","structure_upgrade"),
            "barrels":       get("destroyed_barrels","destroyed_barrel*", _sum=True),
            "bps":           get("blueprint_studied"),
            "pipes":         get("pipes_connected"),
            "wires":         get("wires_connected","tincanalarms_wired"),
            "waves":         get("gesture_wave_count","waved_at_players","gesture_wave"),
        })

        metres = get("horse_distance_ridden", _sum=True)
        km     = get("horse_distance_ridden_km")
        miles  = (metres / 1609.344) if metres else (km * 0.621371)
        stats.update({
            "horse_miles":   int(miles),
            "horses_ridden": get("horse_mounted_count"),
            "calories":      get("calories_consumed"),
            "water":         get("water_consumed"),
            "map_open":      get("MAP_OPENED","map_opened","map_open"),
            "inv_open":      get("INVENTORY_OPENED","inventory_opened"),
            "items_crafted": get("CRAFTING_OPENED","items_crafted","crafted_items"),
        })

        # core combat numbers
        stats.update({
            "shots_fired":   bullets_fired,
            "shots_hit":     bullets_hit,
            "arrow_fired":   arrows_fired,
            "arrow_hit":     arrows_hit,
            "headshot_hits": headshots,
            "kill_player":   kills_player,
            "death_player":  deaths_player,
        })

        return True, stats

# ════════════════════════════════════════
#            public entry-point
# ════════════════════════════════════════
async def setup(bot: commands.Bot, db=None):
    await bot.add_cog(StatsCog(bot))


FILE: cogs\steam_sync.py
----------------------------------------
# cogs/steam_sync.py
# ───────────────────────────────────────────────────────────────
#   • Periodically sync Discord nicknames with Steam names
#   • /link steam <url>   → users link / update their profile
#   • /steamsync now      → mods trigger instant sync
#   • Missing links: silent DM reminder, max once / 24 h
# ───────────────────────────────────────────────────────────────
from __future__ import annotations

import logging
import os
import time
from typing import Optional

import discord
from discord import app_commands
from discord.ext import commands, tasks

# Re-use helpers from member_forms
from cogs.member_forms import (                         # type: ignore
    extract_steam_id,
    get_steam_username,
    is_steam_profile_valid,
    ROLE_PREFIXES,
)

log = logging.getLogger("cog.steam_sync")

# ═══════════════════ CONFIG ═══════════════════════════════════
GUILD_ID          = int(os.getenv("GUILD_ID", 0))
SYNC_INTERVAL_MIN = int(os.getenv("STEAM_SYNC_MINUTES", 60))          # periodic loop
PING_COOLDOWN_H   = int(os.getenv("STEAM_PING_COOLDOWN_H", 24))       # DM rate-limit

OWNER_ROLE_ID     = 1383201150140022784  # exempt from auto-nick

# staff role-id → suffix
STAFF_SUFFIXES: dict[int, str] = {
    1377077466513932338: " | G L",
    1377084533706588201: " | P M",
    1377103244089622719: " | Admin",
    1410659214959054988: " | Rec",
}
STAR = "*"  # put in prefix to bump in voice

FOCUS_ROLE_IDS = {
    "Farming":      1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building":     1380233086544908428,
    "Electricity":  1380233234675400875,
    "PvP":          1408687710159245362,
}
# ══════════════════════════════════════════════════════════════


class SteamSyncCog(commands.Cog):
    """Automatically keeps nicknames in sync with Steam."""

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._last_ping: dict[int, float] = {}  # discord_id → last-DM ts
        self.sync_task.start()

    # ───────────────────────── /link steam ─────────────────────
    link_group = app_commands.Group(
        name="link", description="Link or update external accounts"
    )

    @link_group.command(name="steam")
    @app_commands.describe(url="Your steamcommunity.com profile URL")
    async def link_steam(self, i: discord.Interaction, url: str):
        """Store or update a member's Steam profile."""
        await i.response.defer(ephemeral=True)

        steam_id = await extract_steam_id(url)
        if not steam_id:
            return await i.followup.send(
                "❌ I couldn’t read that link. Use the full "
                "`steamcommunity.com/profiles/...` or `/id/...` URL.",
                ephemeral=True,
            )

        if not await is_steam_profile_valid(steam_id):
            return await i.followup.send(
                "❌ That Steam profile is not public or doesn’t meet the "
                "requirements (≥ 1 game, ≥ 1 friend, ≥ 1 h play-time).",
                ephemeral=True,
            )

        await self.db.set_steam_id(i.user.id, steam_id)
        await i.followup.send("✅ Steam account linked!", ephemeral=True)

    # ───────────────────────── /steamsync now ──────────────────
    steamsync_group = app_commands.Group(
        name="steamsync", description="Manually control Steam nickname sync"
    )

    @steamsync_group.command(
        name="now", description="Run the Steam nickname sync immediately"
    )
    async def steamsync_now(self, i: discord.Interaction):
        if not i.user.guild_permissions.manage_guild:
            return await i.response.send_message("No permission.", ephemeral=True)

        await i.response.defer(thinking=True, ephemeral=True)
        await self._sync_once()
        await i.followup.send("✅ Steam sync finished.", ephemeral=True)

    # ───────────────────────── periodic task ───────────────────
    @tasks.loop(minutes=SYNC_INTERVAL_MIN)
    async def sync_task(self):
        await self._sync_once()

    @sync_task.before_loop
    async def _wait_for_ready(self):
        await self.bot.wait_until_ready()

    # ========== core sync logic (used by task & /now) ==========
    async def _sync_once(self):
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        for member in guild.members:
            if member.bot or member.get_role(OWNER_ROLE_ID):
                continue

            steam_id: Optional[str] = await self.db.get_steam_id(member.id)
            if not steam_id:
                await self._remind_link(member)
                continue

            steam_name = await get_steam_username(steam_id)
            if not steam_name:
                await self._remind_link(member)
                continue

            target_nick = self._build_nickname(member, steam_name)
            if member.nick != target_nick:
                try:
                    await member.edit(nick=target_nick, reason="SteamSync")
                except (discord.Forbidden, discord.HTTPException):
                    pass  # no perms or hierarchy issue

    # ───────────────────────── helper: DM reminder ─────────────
    async def _remind_link(self, member: discord.Member):
        """DM the member at most once every PING_COOLDOWN_H hours (persistent)."""
        last_dt = await self.db.get_last_steam_ping(member.id)
        if last_dt:
            elapsed_h = (discord.utils.utcnow() - last_dt).total_seconds() / 3600
            if elapsed_h < PING_COOLDOWN_H:
                return  # still on cooldown

        try:
            await member.send(
                "Hi! I can't find a valid Steam profile linked to your account "
                "on the server. Please use the </link steam:…> command there "
                "to add or update it. Thanks!"
            )
            await self.db.set_last_steam_ping(member.id)  # record successful DM
        except discord.Forbidden:
            # DMs disabled → we still record the attempt so we don't spam publicly
            await self.db.set_last_steam_ping(member.id)

    # ───────────────────────── helper: nick builder ────────────
    def _build_nickname(self, member: discord.Member, steam_name: str) -> str:
        # focus prefix
        prefix = ""
        for focus, role_id in FOCUS_ROLE_IDS.items():
            if member.get_role(role_id):
                prefix = ROLE_PREFIXES.get(focus, "")
                break

        # star for staff
        if any(member.get_role(rid) for rid in STAFF_SUFFIXES):
            if prefix.startswith("[") and not prefix.startswith("[*"):
                prefix = prefix.replace("[", "[*", 1)

        # staff suffix
        suffix = ""
        for rid, txt in STAFF_SUFFIXES.items():
            if member.get_role(rid):
                suffix = txt
                break

        nick = f"{prefix} {steam_name}{suffix}".strip()
        return nick[:32]  # Discord limit

# ═══════════════════ setup entry-point ════════════════════════
async def setup(bot: commands.Bot, db):
    await bot.add_cog(SteamSyncCog(bot, db))


FILE: cogs\welcome_general.py
----------------------------------------
# cogs/welcome_general.py
#
# Handles:
#   • on_member_join   – add “Uncompleted application” role + public welcome
#   • on_member_remove – announce leave / kick
#   • on_member_ban    – announce ban
#
# NOTE: The existing cog `cogs/welcome_member.py` (accepted-member welcome)
#       stays unchanged – its listeners will run in parallel.

from __future__ import annotations

import contextlib
import logging
from typing import Optional

import discord
from discord.ext import commands

log = logging.getLogger("cog.welcome_general")

# ─────────────────────── constants (copy from main) ───────────────────────
GUILD_ID                = 1377035207777194005
WELCOME_CHANNEL_ID      = 1398659438960971876
APPLICATION_CH_ID       = 1378081331686412468
UNCOMPLETED_APP_ROLE_ID = 1390143545066917931
LEAVE_BAN_CH_ID         = 1404955868054814761
# ───────────────────────────────────────────────────────────────────────────


class WelcomeGeneralCog(commands.Cog):
    """Public join / leave / ban announcements (not accepted-member welcome)."""

    def __init__(self, bot: commands.Bot):
        self.bot = bot

    # ─────────────────── helper: deduplicate welcomes ───────────────────
    @staticmethod
    async def _clean_old_welcomes(
        channel: discord.TextChannel,
        member: discord.Member,
        marker: str = "👋 **Welcome",
    ):
        seen: list[discord.Message] = []
        async for msg in channel.history(limit=20):
            if (
                msg.author == channel.guild.me
                and marker in msg.content
                and member.mention in msg.content
            ):
                seen.append(msg)

        if len(seen) > 1:
            seen.sort(key=lambda m: m.created_at, reverse=True)
            for old in seen[1:]:
                with contextlib.suppress(Exception):
                    await old.delete()

    # ───────────────────── on_member_join ─────────────────────
    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        # ignore other guilds & bots
        if member.bot or member.guild.id != GUILD_ID:
            return

        guild = member.guild
        welcome_ch: Optional[discord.TextChannel] = guild.get_channel(WELCOME_CHANNEL_ID)  # type: ignore
        apply_ch  : Optional[discord.TextChannel] = guild.get_channel(APPLICATION_CH_ID)   # type: ignore

        # 1) add “Uncompleted application” role
        role = guild.get_role(UNCOMPLETED_APP_ROLE_ID)
        if role and role not in member.roles:
            try:
                await member.add_roles(role, reason="Joined – application not started")
            except discord.Forbidden:
                log.warning("[welcome] Can't add role to %s", member)
            except Exception as exc:
                log.exception("[welcome] Error adding role: %s", exc)

        # 2) send public welcome
        if welcome_ch and apply_ch:
            txt = (
                f"👋 **Welcome {member.mention}!**\n"
                f"To join CTFO, please run **`/memberform`** "
                f"in {apply_ch.mention} and fill out the quick application.\n"
                "If you have any questions, just ask a mod.  Enjoy your stay!"
            )
            try:
                await welcome_ch.send(txt)
            except Exception as exc:
                log.warning("[welcome] Failed to send message: %s", exc)

            # 3) delete duplicate welcomes
            try:
                await self._clean_old_welcomes(welcome_ch, member)
            except Exception as exc:
                log.debug("[welcome] Dedup error: %s", exc)
        else:
            log.info("[welcome] Welcome or application channel missing.")

    # ────────────────── on_member_remove ──────────────────
    @commands.Cog.listener()
    async def on_member_remove(self, member: discord.Member):
        if member.guild.id != GUILD_ID:
            return
        ch: Optional[discord.TextChannel] = member.guild.get_channel(LEAVE_BAN_CH_ID)  # type: ignore
        if ch:
            await ch.send(f"👋 **{member}** has left the server.")

    # ─────────────────── on_member_ban ────────────────────
    @commands.Cog.listener()
    async def on_member_ban(self, guild: discord.Guild, user: discord.User):
        if guild.id != GUILD_ID:
            return
        ch: Optional[discord.TextChannel] = guild.get_channel(LEAVE_BAN_CH_ID)  # type: ignore
        if ch:
            await ch.send(f"⛔ **{user}** has been banned from the server.")


# ═════════════ setup entry point ═════════════
async def setup(bot: commands.Bot, _db=None):
    await bot.add_cog(WelcomeGeneralCog(bot))


FILE: cogs\xp.py
----------------------------------------
"""
cogs.xp – v2.2
==============

Full XP / levelling system for *discord.py*.

Changes in v2.2
---------------
• New level-up embed: nicer layout, gradient colour, percentage sits
  directly next to the progress bar.
"""

from __future__ import annotations

import contextlib
import math
import random
import textwrap
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Tuple

import colorsys
import discord
from discord import app_commands
from discord.ext import commands, tasks

# ──────────────────────────── CONFIG ────────────────────────────────────
MSG_COOLDOWN_S = 45
MIN_CHARS = 5
MSG_XP_RANGE = (15, 25)

VOICE_XP_PER_MIN = 5
VOICE_TICK_SECONDS = 60

STREAK_BASE = 10
STREAK_PER_DAY = 5

LEADERBOARD_SIZE = 10
DECAY_AFTER_DAYS = 7
DECAY_FACTOR = 0.99
# ────────────────────────────────────────────────────────────────────────


# ══════════════════════════ EMBED HELPERS ══════════════════════════════
def _hsv_gradient(level: int) -> discord.Colour:
    """Return a pleasant hue that drifts as the level increases."""
    hue_deg = (level * 3) % 360  # 3° hue shift per level
    r, g, b = colorsys.hsv_to_rgb(hue_deg / 360, 0.65, 0.90)
    return discord.Colour.from_rgb(int(r * 255), int(g * 255), int(b * 255))


def build_levelup_embed(
    member: discord.Member, *, level: int, current_xp: int, next_level_xp: int
) -> discord.Embed:
    pct = current_xp / next_level_xp
    bar_len = 10
    bar = "▰" * int(pct * bar_len) + "▱" * (bar_len - int(pct * bar_len))
    percent_txt = f"{pct*100:4.1f}%"

    embed = discord.Embed(
        title=f"🎉  Level {level} unlocked!",
        description=f"{member.mention} reached a new level!",
        colour=_hsv_gradient(level),
        timestamp=datetime.now(timezone.utc),
    )
    embed.set_author(name=member.display_name, icon_url=member.display_avatar.url)
    embed.add_field(name="Current XP", value=f"{current_xp:,}", inline=True)
    embed.add_field(name="Next level XP", value=f"{next_level_xp:,}", inline=True)
    embed.add_field(
        name="Progress", value=f"{bar} **`{percent_txt}`**", inline=False
    )
    embed.set_footer(
        text="Keep chatting and hanging out in voice to earn more XP!"
    )
    return embed


# ═════════════════════════════ COG ═════════════════════════════════════
class XPCog(commands.Cog):
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self.voice_sessions: Dict[Tuple[int, int], datetime] = {}

        self._voice_tick.start()
        self._decay_loop.start()
        self._boost_watch.start()

    # ──────────────── maths & db helpers ───────────────────────────
    @staticmethod
    def level_from_xp(xp: int) -> int:
        return int(0.1 * math.sqrt(xp))

    @staticmethod
    def xp_for_next(level: int) -> int:
        return int(((level + 1) / 0.1) ** 2)

    async def _chan_mult(self, gid: int, cid: int) -> float:
        row = await self.db.fetch_one(
            "SELECT mult FROM xp_channel_mult WHERE guild_id=$1 AND channel_id=$2",
            gid,
            cid,
        )
        return float(row["mult"]) if row else 1.0

    async def _guild_boost(self, gid: int) -> float:
        row = await self.db.fetch_one(
            "SELECT multiplier, ends_at FROM xp_boosts WHERE guild_id=$1", gid
        )
        if not row or row["ends_at"] < datetime.now(timezone.utc):
            return 1.0
        return float(row["multiplier"])

    async def _lvl_channel_id(self, gid: int) -> Optional[int]:
        row = await self.db.fetch_one(
            "SELECT channel_id FROM xp_levelup_channel WHERE guild_id=$1", gid
        )
        return row["channel_id"] if row else None

    async def _voice_excluded(self, gid: int, cid: int) -> bool:
        return (
            await self.db.fetch_one(
                "SELECT 1 FROM xp_voice_excluded WHERE guild_id=$1 AND channel_id=$2",
                gid,
                cid,
            )
            is not None
        )

    # ─────────────────── TEXT XP LISTENER ────────────────────────
    @commands.Cog.listener("on_message")
    async def _text_xp(self, m: discord.Message):
        if m.author.bot or m.guild is None or len(m.content) < MIN_CHARS:
            return

        gid, uid, now = m.guild.id, m.author.id, datetime.now(timezone.utc)
        rec = await self.db.fetch_one(
            "SELECT xp, level, last_msg, streak FROM xp_members "
            "WHERE guild_id=$1 AND user_id=$2",
            gid,
            uid,
        )

        if rec and rec["last_msg"]:
            if (now - rec["last_msg"]).total_seconds() < MSG_COOLDOWN_S:
                return

        base = random.randint(*MSG_XP_RANGE)
        base = int(
            base
            * await self._chan_mult(gid, m.channel.id)
            * await self._guild_boost(gid)
        )

        streak, bonus = (rec["streak"] if rec else 0), 0
        if rec and rec["last_msg"]:
            gap = (now.date() - rec["last_msg"].date()).days
            if gap == 1:
                streak += 1
                bonus = STREAK_BASE + streak * STREAK_PER_DAY
            elif gap > 1:
                streak = 1
        else:
            streak = 1

        delta = base + bonus
        new_xp = delta + (rec["xp"] if rec else 0)
        new_lvl = self.level_from_xp(new_xp)
        old_lvl = rec["level"] if rec else 0

        await self.db.execute(
            """
            INSERT INTO xp_members (guild_id,user_id,xp,level,last_msg,streak)
            VALUES ($1,$2,$3,$4,$5,$6)
            ON CONFLICT (guild_id,user_id)
            DO UPDATE SET xp=$3, level=$4, last_msg=$5, streak=$6
            """,
            gid,
            uid,
            new_xp,
            new_lvl,
            now,
            streak,
        )
        await self.db.execute(
            "INSERT INTO xp_log (guild_id,user_id,delta,reason) "
            "VALUES ($1,$2,$3,'message')",
            gid,
            uid,
            delta,
        )

        if new_lvl > old_lvl:
            await self._announce_level_up(m.author, new_lvl, m.channel)

    # ─────────────────── VOICE XP TRACKING ────────────────────────
    @commands.Cog.listener("on_voice_state_update")
    async def _voice_state(self, m: discord.Member, before, after):
        key = (m.guild.id, m.id)

        # leaving / switching out of an included room
        if before.channel and key in self.voice_sessions:
            mins = int(
                (
                    datetime.now(timezone.utc) - self.voice_sessions.pop(key)
                ).total_seconds()
                / 60
            )
            if mins:
                await self._grant_voice_xp(m, mins)

        # joined / switched into an included room
        if after.channel and not await self._voice_excluded(
            m.guild.id, after.channel.id
        ):
            self.voice_sessions[key] = datetime.now(timezone.utc)

    async def _grant_voice_xp(self, m: discord.Member, mins: int):
        if mins <= 0:
            return

        delta = int(
            mins * VOICE_XP_PER_MIN * await self._guild_boost(m.guild.id)
        )
        rec = await self.db.fetch_one(
            "SELECT xp, level FROM xp_members WHERE guild_id=$1 AND user_id=$2",
            m.guild.id,
            m.id,
        )
        new_xp = delta + (rec["xp"] if rec else 0)
        new_lvl = self.level_from_xp(new_xp)
        old_lvl = rec["level"] if rec else 0

        await self.db.execute(
            """
            INSERT INTO xp_members (guild_id,user_id,xp,level,last_msg)
            VALUES ($1,$2,$3,$4,$5)
            ON CONFLICT (guild_id,user_id) DO UPDATE SET xp=$3, level=$4
            """,
            m.guild.id,
            m.id,
            new_xp,
            new_lvl,
            datetime.now(timezone.utc),
        )
        await self.db.execute(
            "INSERT INTO xp_log (guild_id,user_id,delta,reason) "
            "VALUES ($1,$2,$3,'voice')",
            m.guild.id,
            m.id,
            delta,
        )

        if new_lvl > old_lvl:
            chan = next(
                (
                    c
                    for c in m.guild.text_channels
                    if c.permissions_for(m.guild.me).send_messages
                ),
                None,
            )
            if chan:
                await self._announce_level_up(m, new_lvl, chan)

    @tasks.loop(seconds=VOICE_TICK_SECONDS)
    async def _voice_tick(self):
        now = datetime.now(timezone.utc)
        for (gid, uid), last in list(self.voice_sessions.items()):
            mins = int((now - last).total_seconds() / 60)
            if mins <= 0:
                continue

            guild = self.bot.get_guild(gid)
            member = guild and guild.get_member(uid)
            if not member or not member.voice:
                self.voice_sessions.pop((gid, uid), None)
                continue

            if await self._voice_excluded(gid, member.voice.channel.id):
                self.voice_sessions.pop((gid, uid), None)
                continue

            await self._grant_voice_xp(member, mins)
            self.voice_sessions[(gid, uid)] = now

    @_voice_tick.before_loop
    async def _voice_ready(self):
        await self.bot.wait_until_ready()

    # ──────────────────────── LEVEL UP ────────────────────────────
    async def _announce_level_up(
        self,
        member: discord.Member,
        level: int,
        origin_channel: discord.TextChannel,
    ):
        # get current XP for the embed
        rec = await self.db.fetch_one(
            "SELECT xp FROM xp_members WHERE guild_id=$1 AND user_id=$2",
            member.guild.id,
            member.id,
        )
        current_xp = rec["xp"] if rec else 0
        next_xp = self.xp_for_next(level)

        embed = build_levelup_embed(
            member,
            level=level,
            current_xp=current_xp,
            next_level_xp=next_xp,
        )

        # role rewards
        rows = await self.db.fetch_all(
            "SELECT role_id FROM xp_roles WHERE guild_id=$1 AND min_level <= $2",
            member.guild.id,
            level,
        )
        for r in rows:
            role = member.guild.get_role(r["role_id"])
            if role and role not in member.roles:
                with contextlib.suppress(discord.Forbidden):
                    await member.add_roles(role, reason="XP reward")

        pub_id = await self._lvl_channel_id(member.guild.id)
        if pub_id:
            pub = member.guild.get_channel(pub_id)
            if isinstance(pub, discord.TextChannel):
                with contextlib.suppress(discord.Forbidden):
                    await pub.send(embed=embed)

        try:
            await member.send(embed=embed)
        except discord.Forbidden:
            with contextlib.suppress(discord.Forbidden):
                await origin_channel.send(member.mention, embed=embed)

    # ───────────────────── USER COMMANDS ─────────────────────────
    @app_commands.command(name="rank", description="Show your level / XP")
    async def rank(
        self, inter: discord.Interaction, member: Optional[discord.Member] = None
    ):
        member = member or inter.user
        rec = await self.db.fetch_one(
            "SELECT xp, level, streak FROM xp_members "
            "WHERE guild_id=$1 AND user_id=$2",
            inter.guild.id,
            member.id,
        )
        if not rec:
            return await inter.response.send_message(
                f"{member.mention} has no XP yet.", ephemeral=True
            )

        next_xp = self.xp_for_next(rec["level"])
        pct = rec["xp"] / next_xp
        bar = "▰" * int(pct * 10) + "▱" * (10 - int(pct * 10))

        embed = discord.Embed(
            title=f"Rank for {member.display_name}",
            colour=discord.Colour.dark_embed(),
            description=textwrap.dedent(
                f"""
                Level **{rec['level']}**
                XP **{rec['xp']} / {next_xp}**
                {bar} **`{pct*100:4.1f}%`**
                Daily streak **{rec['streak']}**
                """
            ),
        ).set_thumbnail(url=member.display_avatar.url)
        await inter.response.send_message(embed=embed)

    @app_commands.command(name="leaderboard", description="Top XP users")
    async def leaderboard(
        self,
        inter: discord.Interaction,
        length: app_commands.Range[int, 1, 25] = LEADERBOARD_SIZE,
    ):
        rows = await self.db.fetch_all(
            "SELECT user_id, xp, level FROM xp_members "
            "WHERE guild_id=$1 ORDER BY xp DESC LIMIT $2",
            inter.guild.id,
            length,
        )
        if not rows:
            return await inter.response.send_message(
                "Nobody has XP yet.", ephemeral=True
            )

        lines = []
        for rank, r in enumerate(rows, 1):
            user = inter.guild.get_member(r["user_id"]) or f"<@{r['user_id']}>"
            lines.append(
                f"`#{rank:02}` **{user}** — L{r['level']} ({r['xp']} XP)"
            )

        embed = discord.Embed(
            title=f"Top {len(rows)} — {inter.guild.name}",
            description="\n".join(lines),
            colour=discord.Colour.blurple(),
            timestamp=datetime.now(timezone.utc),
        )
        await inter.response.send_message(embed=embed)

    # ───────────────────── ADMIN SUB-GROUP ───────────────────────
    xp_admin = app_commands.Group(
        name="xpadmin", description="XP admin tools", guild_only=True
    )

    # multiplier
    @xp_admin.command(
        name="multiplier", description="Set per-channel XP multiplier (0-5)"
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    async def adm_multiplier(
        self,
        inter: discord.Interaction,
        channel: discord.TextChannel,
        value: app_commands.Range[float, 0, 5],
    ):
        await self.db.execute(
            """
            INSERT INTO xp_channel_mult (guild_id,channel_id,mult)
            VALUES ($1,$2,$3)
            ON CONFLICT (guild_id,channel_id) DO UPDATE SET mult=$3
            """,
            inter.guild.id,
            channel.id,
            value,
        )
        await inter.response.send_message(
            f"Multiplier for {channel.mention} set to ×{value}."
        )

    # grantrole
    @xp_admin.command(
        name="grantrole",
        description="Auto-grant a role once a member reaches a level",
    )
    @app_commands.checks.has_permissions(manage_roles=True)
    async def adm_grantrole(
        self,
        inter: discord.Interaction,
        role: discord.Role,
        min_level: app_commands.Range[int, 1, 200],
    ):
        await self.db.execute(
            """
            INSERT INTO xp_roles (guild_id,role_id,min_level)
            VALUES ($1,$2,$3)
            ON CONFLICT (guild_id,role_id) DO UPDATE SET min_level=$3
            """,
            inter.guild.id,
            role.id,
            min_level,
        )
        await inter.response.send_message(
            f"{role.mention} will now be granted at level {min_level}."
        )

    # level-up channel
    @xp_admin.command(
        name="setlevelupchannel",
        description="Set the channel where level-up cards are posted",
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    async def adm_set_lvl_channel(
        self, inter: discord.Interaction, channel: discord.TextChannel
    ):
        await self.db.execute(
            """
            INSERT INTO xp_levelup_channel (guild_id,channel_id)
            VALUES ($1,$2)
            ON CONFLICT (guild_id) DO UPDATE SET channel_id=$2
            """,
            inter.guild.id,
            channel.id,
        )
        await inter.response.send_message(
            f"Level-up cards will be posted in {channel.mention}."
        )

    # boost
    @xp_admin.command(
        name="boost", description="Activate a temporary global XP boost"
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    @app_commands.describe(
        multiplier="Boost factor (1-10)",
        minutes="Duration (1-1440)",
        announce_channel="Where to announce (defaults to current)",
        message="Optional extra text",
    )
    async def adm_boost(
        self,
        inter: discord.Interaction,
        multiplier: app_commands.Range[float, 1.0, 10.0],
        minutes: app_commands.Range[int, 1, 1440],
        announce_channel: Optional[discord.TextChannel] = None,
        message: Optional[str] = None,
    ):
        ends = datetime.now(timezone.utc) + timedelta(minutes=minutes)

        await self.db.execute(
            """
            INSERT INTO xp_boosts (guild_id,multiplier,ends_at,message,
                                   announce_channel_id,announce_msg_id)
            VALUES ($1,$2,$3,$4,NULL,NULL)
            ON CONFLICT (guild_id) DO UPDATE
            SET multiplier=$2, ends_at=$3, message=$4,
                announce_channel_id=NULL, announce_msg_id=NULL
            """,
            inter.guild.id,
            multiplier,
            ends,
            message,
        )

        ch = announce_channel or inter.channel
        emb = discord.Embed(
            title="🚀 XP BOOST ACTIVE",
            description=f"All XP gains are multiplied by **×{multiplier}** "
            f"for the next **{minutes} minutes**!",
            colour=discord.Colour.gold(),
            timestamp=datetime.now(timezone.utc),
        )
        if message:
            emb.add_field(name="Info", value=message, inline=False)

        msg = await ch.send(embed=emb)

        await self.db.execute(
            """
            UPDATE xp_boosts
            SET announce_channel_id=$1, announce_msg_id=$2
            WHERE guild_id=$3
            """,
            ch.id,
            msg.id,
            inter.guild.id,
        )
        await inter.response.send_message("Boost activated!", ephemeral=True)

    # exclude
    @xp_admin.command(
        name="exclude",
        description="Enable / disable XP in a text or voice channel",
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    @app_commands.describe(
        channel="Channel to toggle",
        enabled="True = enable XP, False = disable (default)",
    )
    async def adm_exclude(
        self,
        inter: discord.Interaction,
        channel: discord.abc.GuildChannel,
        enabled: bool = False,
    ):
        if isinstance(channel, discord.TextChannel):
            if enabled:
                await self.db.execute(
                    "DELETE FROM xp_channel_mult WHERE guild_id=$1 AND channel_id=$2",
                    inter.guild.id,
                    channel.id,
                )
            else:
                await self.db.execute(
                    """
                    INSERT INTO xp_channel_mult (guild_id,channel_id,mult)
                    VALUES ($1,$2,0.0)
                    ON CONFLICT (guild_id,channel_id) DO UPDATE SET mult=0.0
                    """,
                    inter.guild.id,
                    channel.id,
                )
        elif isinstance(channel, discord.VoiceChannel):
            if enabled:
                await self.db.execute(
                    "DELETE FROM xp_voice_excluded WHERE guild_id=$1 AND channel_id=$2",
                    inter.guild.id,
                    channel.id,
                )
            else:
                await self.db.execute(
                    """
                    INSERT INTO xp_voice_excluded (guild_id,channel_id)
                    VALUES ($1,$2)
                    ON CONFLICT DO NOTHING
                    """,
                    inter.guild.id,
                    channel.id,
                )
        else:
            return await inter.response.send_message(
                "Unsupported channel type.", ephemeral=True
            )

        state = "enabled" if enabled else "disabled"
        await inter.response.send_message(f"XP {state} in {channel.mention}.")

    # ────────────────── BACKGROUND MAINTENANCE ───────────────────
    @tasks.loop(hours=24)
    async def _decay_loop(self):
        cutoff = datetime.now(timezone.utc) - timedelta(days=DECAY_AFTER_DAYS)
        await self.db.execute(
            "UPDATE xp_members SET xp=floor(xp*$1) WHERE last_msg<$2",
            DECAY_FACTOR,
            cutoff,
        )

    @_decay_loop.before_loop
    async def _decay_ready(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=1)
    async def _boost_watch(self):
        rows = await self.db.fetch_all(
            "SELECT guild_id,announce_channel_id,announce_msg_id "
            "FROM xp_boosts WHERE ends_at < $1",
            datetime.now(timezone.utc),
        )
        for r in rows:
            g = self.bot.get_guild(r["guild_id"])
            ch = g and g.get_channel(r["announce_channel_id"])
            if isinstance(ch, discord.TextChannel) and r["announce_msg_id"]:
                with contextlib.suppress(Exception):
                    msg = await ch.fetch_message(r["announce_msg_id"])
                    await msg.edit(content="🟢 Boost ended.", embed=None)
        if rows:
            await self.db.execute(
                "DELETE FROM xp_boosts WHERE ends_at < $1",
                datetime.now(timezone.utc),
            )

    @_boost_watch.before_loop
    async def _boost_ready(self):
        await self.bot.wait_until_ready()

    # ────────────────── graceful unload ────────────────────────
    def cog_unload(self):
        self._voice_tick.cancel()
        self._decay_loop.cancel()
        self._boost_watch.cancel()


# ═════════════════════ EXTENSION ENTRY ═════════════════════════
async def setup(bot: commands.Bot, db):
    cog = XPCog(bot, db)
    await bot.add_cog(cog)
    if bot.tree.get_command("xpadmin") is None:
        bot.tree.add_command(cog.xp_admin)


FILE: ctfobot2_0.py
----------------------------------------
# ctfobot2_0.py – CTFO Discord bot (core launcher)
# =================================================
from __future__ import annotations

import asyncio
import logging
import os
import sys
from importlib import import_module
from types import ModuleType
from typing import Sequence

import discord
from discord.ext import commands
from dotenv import load_dotenv

from db import Database

# ─────────────────────────── log / env ────────────────────────────
load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-8s | %(name)s | %(message)s",
    stream=sys.stdout,
    force=True,
)

BOT_TOKEN: str | None = os.getenv("BOT_TOKEN")
DATABASE_URL: str | None = os.getenv("DATABASE_URL")
if not BOT_TOKEN or not DATABASE_URL:
    raise RuntimeError("Set BOT_TOKEN and DATABASE_URL in .env!")

# ─────────────────────────── database ─────────────────────────────
db = Database(DATABASE_URL)

# ─────────────────────────── shared constants ─────────────────────
GUILD_ID = int(os.getenv("GUILD_ID", "1377035207777194005"))

WELCOME_CHANNEL_ID      = 1398659438960971876
APPLICATION_CH_ID       = 1378081331686412468
UNCOMPLETED_APP_ROLE_ID = 1390143545066917931
COMPLETED_APP_ROLE_ID   = 1398708167525011568
ACCEPT_ROLE_ID          = 1377075930144571452

REGION_ROLE_IDS = {
    "North America": 1411364406096433212,
    "Europe":        1411364744484491287,
    "Asia":          1411364982117105684,
    "Other":         1411365034440921260,
}
FOCUS_ROLE_IDS = {
    "Farming":      1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building":     1380233086544908428,
    "Electricity":  1380233234675400875,
    "PvP":          1408687710159245362,
}

TEMP_BAN_SECONDS  = 7 * 24 * 60 * 60
GIVEAWAY_ROLE_ID  = 1403337937722019931
GIVEAWAY_CH_ID    = 1413929735658016899
EMBED_TITLE       = "🎉 GIVEAWAY 🎉"

ADMIN_ID        = 1377103244089622719
ELECTRICIAN_ID  = 1380233234675400875
GROUP_LEADER_ID = 1377077466513932338
PLAYER_MGMT_ID  = 1377084533706588201
TRUSTED_ID      = 1400584430900219935

CODE_NAMES = ["Master", "Guest", "Electrician", "Other"]

STAFF_BONUS_ROLE_IDS = {
    ADMIN_ID,
    GROUP_LEADER_ID,
    PLAYER_MGMT_ID,
    1410659214959054988,  # recruitment
}

BOOST_BONUS_PER_WEEK = 3
STAFF_BONUS_PER_WEEK = 3
STREAK_BONUS_PER_SET = 3

# ─────────────────────────── bot instance ─────────────────────────
intents = discord.Intents.default()
intents.members = True
intents.messages = True
intents.message_content = True  # needed for XP + moderation

bot = commands.Bot(command_prefix="!", intents=intents)

# ─────────────────────────── slash-cmd error ──────────────────────
@bot.tree.error
async def app_command_error(inter: discord.Interaction, err: Exception):
    logging.error("Slash-cmd error: %s – %s", type(err).__name__, err)

# ─────────────────────────── on_ready (sync) ──────────────────────
@bot.event
async def on_ready() -> None:
    logging.info("Logged in as %s (%s)", bot.user, bot.user.id)

    guild = discord.Object(id=GUILD_ID)
    bot.tree.copy_global_to(guild=guild)
    await bot.tree.sync(guild=guild)
    logging.info("Slash-commands synced for guild %s", GUILD_ID)

# ─────────────────────────── helper: cog loader ───────────────────
async def load_cogs(bot_: commands.Bot, db_: Database, paths: Sequence[str]) -> None:
    for dotted in paths:
        try:
            module: ModuleType = import_module(dotted)
            if not hasattr(module, "setup"):
                logging.warning("Module %s has no setup() – skipped", dotted)
                continue
            await module.setup(bot_, db_)
            logging.info("Loaded cog %s", dotted)
        except Exception:
            logging.exception("Failed to load cog %s", dotted)

# ─────────────────────────── main runner ──────────────────────────
async def _run_bot() -> None:
    await db.connect()                      # 1) DB
    await load_cogs(                        # 2) Cogs
        bot,
        db,
        (
            "cogs.codes",
            "cogs.feedback",
            "cogs.member_forms",
            "cogs.recruit_reminder",
            "cogs.staff_applications",
            "cogs.stats",
            "cogs.steam_sync",
            "cogs.welcome_general",
            "cogs.cleanup",
            "cogs.xp",
        ),
    )
    await bot.start(BOT_TOKEN)              # 3) live

# ─────────────────────────── entry-point ──────────────────────────
def main() -> None:
    try:
        asyncio.run(_run_bot())
    except KeyboardInterrupt:
        logging.info("Bot stopped by user")
    finally:
        # Close the DB pool cleanly
        try:
            asyncio.run(db.close())  # type: ignore[arg-type]
        except RuntimeError:
            # event-loop already closed (windows quirk)
            pass


if __name__ == "__main__":
    main()


FILE: db.py
----------------------------------------
# db.py – central async-pg helper for CTFO bot
# ===============================================================
# Last update: 2024-10-08
#
# • generic helpers  fetch_one / fetch_all / execute / close
# • full XP-system schema (xp_members, xp_boosts, …)
# • keeps **all** previously-public methods unchanged
#
# Tips:
#   await db.connect()   → open pool + run migrations
#   await db.close()     → graceful shutdown
# ===============================================================
from __future__ import annotations

import json
from typing import Any, Dict, List, Sequence, Set, Optional

import asyncpg


class Database:
    """Thin wrapper around an async-pg pool + convenience helpers."""

    # ───────────────────────────────────────────────────────────
    # INIT / POOL
    # ───────────────────────────────────────────────────────────
    def __init__(self, dsn: str) -> None:
        self.dsn = dsn
        self.pool: asyncpg.Pool | None = None

    async def connect(self) -> None:
        """Open pool and run idempotent migrations."""
        self.pool = await asyncpg.create_pool(self.dsn, min_size=1, max_size=5)
        await self._init_tables()

    async def close(self) -> None:
        """Gracefully close the connection-pool (call on shutdown)."""
        if self.pool and not self.pool.closed:
            await self.pool.close()

    # ───────────────────────────────────────────────────────────
    # GENERIC SMALL HELPERS  (used by newer cogs)
    # ───────────────────────────────────────────────────────────
    async def fetch_one(self, sql: str, *args) -> Dict[str, Any] | None:
        """Return first row as dict or None."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            row = await conn.fetchrow(sql, *args)
            return dict(row) if row else None

    async def fetch_all(self, sql: str, *args) -> List[Dict[str, Any]]:
        """Return all rows as list[dict]."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            rows: Sequence[asyncpg.Record] = await conn.fetch(sql, *args)
            return [dict(r) for r in rows]

    async def execute(self, sql: str, *args) -> None:
        """Run statement that does not return rows."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            await conn.execute(sql, *args)

    # ───────────────────────────────────────────────────────────
    # MIGRATIONS
    # ───────────────────────────────────────────────────────────
    async def _init_tables(self) -> None:
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            await conn.execute(
                """
-- ═════════════════════ Core / legacy tables ═════════════════════
CREATE TABLE IF NOT EXISTS codes (
    name   TEXT PRIMARY KEY,
    pin    VARCHAR(4) NOT NULL,
    public BOOLEAN     NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS reviewers ( user_id BIGINT PRIMARY KEY );

CREATE TABLE IF NOT EXISTS activity (
    user_id BIGINT PRIMARY KEY,
    streak  INTEGER,
    date    DATE,
    warned  BOOLEAN,
    last    TIMESTAMP
);

CREATE TABLE IF NOT EXISTS giveaways (
    id         SERIAL PRIMARY KEY,
    channel_id BIGINT,
    message_id BIGINT,
    prize      TEXT,
    start_ts   BIGINT,
    end_ts     BIGINT,
    active     BOOLEAN,
    note       TEXT
);
ALTER TABLE giveaways ADD COLUMN IF NOT EXISTS start_ts BIGINT;
ALTER TABLE giveaways ADD COLUMN IF NOT EXISTS note TEXT;

CREATE TABLE IF NOT EXISTS member_forms (
    id         SERIAL PRIMARY KEY,
    user_id    BIGINT,
    created_at TIMESTAMP DEFAULT now(),
    data       JSONB,
    status     TEXT NOT NULL DEFAULT 'pending',
    message_id BIGINT,
    region     TEXT,
    focus      TEXT
);

CREATE TABLE IF NOT EXISTS staff_applications (
    id         SERIAL PRIMARY KEY,
    user_id    BIGINT,
    role       TEXT,
    message_id BIGINT,
    status     TEXT NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS inactive_members (
    user_id  BIGINT PRIMARY KEY,
    until_ts BIGINT
);

CREATE TABLE IF NOT EXISTS exempt_users ( user_id BIGINT PRIMARY KEY );

CREATE TABLE IF NOT EXISTS activity_audit (
    id SERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    event_type VARCHAR(32) NOT NULL,
    timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
    details TEXT
);

CREATE TABLE IF NOT EXISTS todo_tasks (
    id          SERIAL PRIMARY KEY,
    guild_id    BIGINT,
    creator_id  BIGINT,
    description TEXT      NOT NULL,
    max_claims  INTEGER   NOT NULL DEFAULT 0,
    claimed     BIGINT[]  NOT NULL DEFAULT '{}',
    message_id  BIGINT,
    completed   BOOLEAN   NOT NULL DEFAULT FALSE,
    created_at  TIMESTAMP NOT NULL DEFAULT NOW()
);

-- ═════════════════════ Feedback tables ═════════════════════
CREATE TABLE IF NOT EXISTS anon_feedback_cooldown (
    user_id BIGINT PRIMARY KEY,
    last_ts TIMESTAMPTZ NOT NULL
);

CREATE TABLE IF NOT EXISTS feedback (
    id              SERIAL PRIMARY KEY,
    msg_id          BIGINT      NOT NULL,
    author_id       BIGINT      NOT NULL,   -- 0 == anonymous
    category        TEXT,
    target_id       BIGINT,
    text            TEXT,
    rating          INT,
    attachment_urls TEXT[],
    status          TEXT        NOT NULL DEFAULT 'Open',
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ═════════════════════ XP system (NEW) ═════════════════════
CREATE TABLE IF NOT EXISTS xp_members (
    guild_id BIGINT NOT NULL,
    user_id  BIGINT NOT NULL,
    xp       BIGINT  NOT NULL DEFAULT 0,
    level    INTEGER NOT NULL DEFAULT 0,
    last_msg TIMESTAMPTZ,
    streak   INTEGER NOT NULL DEFAULT 0,
    voice_secs BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, user_id)
);

CREATE INDEX IF NOT EXISTS xp_members_xp_idx
          ON xp_members (guild_id, xp DESC);

CREATE TABLE IF NOT EXISTS xp_log (
    id       BIGSERIAL PRIMARY KEY,
    guild_id BIGINT NOT NULL,
    user_id  BIGINT NOT NULL,
    delta    INTEGER NOT NULL,
    reason   TEXT,
    ts       TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS xp_channel_mult (
    guild_id  BIGINT NOT NULL,
    channel_id BIGINT NOT NULL,
    mult      NUMERIC(4,2) NOT NULL DEFAULT 1.0,
    PRIMARY KEY (guild_id, channel_id)
);

CREATE TABLE IF NOT EXISTS xp_roles (
    guild_id BIGINT NOT NULL,
    role_id  BIGINT NOT NULL,
    min_level INTEGER NOT NULL,
    PRIMARY KEY (guild_id, role_id)
);

CREATE TABLE IF NOT EXISTS xp_levelup_channel (
    guild_id   BIGINT PRIMARY KEY,
    channel_id BIGINT NOT NULL
);

CREATE TABLE IF NOT EXISTS xp_boosts (
    guild_id            BIGINT PRIMARY KEY,
    multiplier          NUMERIC(4,2) NOT NULL,
    ends_at             TIMESTAMPTZ  NOT NULL,
    message             TEXT,
    announce_channel_id BIGINT,
    announce_msg_id     BIGINT
);

CREATE TABLE IF NOT EXISTS xp_voice_excluded (
    guild_id   BIGINT NOT NULL,
    channel_id BIGINT NOT NULL,
    PRIMARY KEY (guild_id, channel_id)
);

-- ═════════════════════ Steam links (NEW) ═════════════════════
CREATE TABLE IF NOT EXISTS steam_links (
    discord_id BIGINT PRIMARY KEY,
    steam_id64 VARCHAR(17) NOT NULL
);

-- ═════════════════════ Steam-Sync cooldown (NEW) ═════════════════════
CREATE TABLE IF NOT EXISTS steam_ping_cooldown (
    discord_id BIGINT PRIMARY KEY,
    last_ts    TIMESTAMPTZ NOT NULL
);

"""
            )

    # ═══════════════════ CODES ═══════════════════
    async def get_codes(self, *, only_public: bool = False) -> Dict[str, tuple[str, bool]]:
        q = "SELECT name, pin, public FROM codes"
        if only_public:
            q += " WHERE public=TRUE"
        q += " ORDER BY name"
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(q)
            return {r["name"]: (r["pin"], r["public"]) for r in rows}

    async def add_code(self, name: str, pin: str, public: bool):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO codes (name, pin, public)
                VALUES ($1,$2,$3)
                ON CONFLICT(name) DO UPDATE SET pin=$2, public=$3
                """,
                name,
                pin,
                public,
            )

    async def edit_code(self, name: str, pin: str, public: bool | None = None):
        async with self.pool.acquire() as conn:
            if public is None:
                await conn.execute("UPDATE codes SET pin=$2 WHERE name=$1", name, pin)
            else:
                await conn.execute(
                    "UPDATE codes SET pin=$2, public=$3 WHERE name=$1",
                    name,
                    pin,
                    public,
                )

    async def remove_code(self, name: str):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM codes WHERE name=$1", name)

    # ═══════════════════ REVIEWERS ═══════════════════
    async def get_reviewers(self) -> Set[int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT user_id FROM reviewers")
            return {r["user_id"] for r in rows}

    async def add_reviewer(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO reviewers (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
                uid,
            )

    async def remove_reviewer(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM reviewers WHERE user_id=$1", uid)

    # ═══════════════════ ACTIVITY ═══════════════════
    async def get_activity(self, uid: int) -> Dict[str, Any] | None:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM activity WHERE user_id=$1", uid)
            return dict(row) if row else None

    async def set_activity(self, uid, streak, date_, warned, last):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO activity (user_id, streak, date, warned, last)
                VALUES ($1,$2,$3,$4,$5)
                ON CONFLICT(user_id) DO UPDATE
                  SET streak=$2, date=$3, warned=$4, last=$5
                """,
                uid,
                streak,
                date_,
                warned,
                last,
            )

    async def get_all_activity(self) -> Dict[int, Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT * FROM activity")
            return {r["user_id"]: dict(r) for r in rows}

    # ═══════════════════ INACTIVE MEMBERS ═══════════════════
    async def add_inactive(self, uid: int, until_ts: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO inactive_members (user_id, until_ts)
                VALUES ($1,$2)
                ON CONFLICT(user_id) DO UPDATE SET until_ts=$2
                """,
                uid,
                until_ts,
            )

    async def remove_inactive(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM inactive_members WHERE user_id=$1", uid)

    async def get_expired_inactive(self, now_ts: int) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT * FROM inactive_members WHERE until_ts <= $1", now_ts
            )
            return [dict(r) for r in rows]

    # ═══════════════════ MEMBER FORMS ═══════════════════
    async def add_member_form(self, uid, data: dict, message_id: int | None = None):
        async with self.pool.acquire() as conn:
            d = json.loads(json.dumps(data))  # ensure JSON-serialisable
            await conn.execute(
                """
                INSERT INTO member_forms (user_id, data, region, focus, message_id, status)
                VALUES ($1,$2,$3,$4,$5,'pending')
                """,
                uid,
                json.dumps(d),
                d.get("region"),
                d.get("focus"),
                message_id,
            )

    async def update_member_form_status(self, message_id: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE member_forms SET status=$1 WHERE message_id=$2",
                status,
                message_id,
            )

    async def get_pending_member_forms(self) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM member_forms
                WHERE status='pending' AND message_id IS NOT NULL
                """
            )
            return [dict(r) for r in rows]

    # ═══════════════════ STAFF APPLICATIONS ═══════════════════
    async def add_staff_app(self, uid: int, role: str, msg_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO staff_applications (user_id, role, message_id)
                VALUES ($1,$2,$3)
                """,
                uid,
                role,
                msg_id,
            )

    async def update_staff_app_status(self, msg_id: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE staff_applications SET status=$1 WHERE message_id=$2",
                status,
                msg_id,
            )

    async def get_pending_staff_apps(self) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT * FROM staff_applications WHERE status='pending'"
            )
            return [dict(r) for r in rows]

    # ═══════════════════ ACTIVITY EXEMPT / AUDIT ═══════════════════
    async def add_exempt_user(self, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO exempt_users (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
                user_id,
            )

    async def remove_exempt_user(self, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM exempt_users WHERE user_id=$1", user_id)

    async def get_exempt_users(self) -> Set[int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT user_id FROM exempt_users")
            return {r["user_id"] for r in rows}

    async def log_activity_event(self, user_id: int, event_type: str, details: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO activity_audit (user_id, event_type, details)
                VALUES ($1,$2,$3)
                """,
                user_id,
                event_type,
                details,
            )

    # ═══════════════════ TO-DO LIST ═══════════════════
    async def add_todo(
        self,
        guild_id: int,
        creator_id: int,
        description: str,
        max_claims: int,
        message_id: int,
    ):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO todo_tasks
                  (guild_id, creator_id, description,
                   max_claims, message_id)
                VALUES ($1,$2,$3,$4,$5)
                """,
                guild_id,
                creator_id,
                description,
                max_claims,
                message_id,
            )

    async def list_open_todos(self, guild_id: int) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM todo_tasks
                 WHERE guild_id=$1 AND completed=FALSE
                 ORDER BY id
                """,
                guild_id,
            )
            return [dict(r) for r in rows]

    async def claim_todo(self, task_id: int, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE todo_tasks
                   SET claimed = array_append(claimed, $2)
                 WHERE id=$1
                   AND completed=FALSE
                   AND NOT (claimed @> ARRAY[$2])
                   AND (max_claims=0 OR array_length(claimed,1) < max_claims)
                """,
                task_id,
                user_id,
            )

    async def unclaim_todo(self, task_id: int, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE todo_tasks
                   SET claimed = array_remove(claimed, $2)
                 WHERE id=$1 AND completed=FALSE
                """,
                task_id,
                user_id,
            )

    async def complete_todo(self, task_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE todo_tasks SET completed=TRUE WHERE id=$1", task_id
            )

    async def remove_todo(self, task_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM todo_tasks WHERE id=$1", task_id)

    async def count_open_claims(self, guild_id: int, user_id: int) -> int:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT COUNT(*) AS n
                  FROM todo_tasks
                 WHERE guild_id=$1
                   AND completed=FALSE
                   AND $2 = ANY(claimed)
                """,
                guild_id,
                user_id,
            )
        return row["n"] if row else 0

    async def todo_bonus_map(self, guild_id: int) -> Dict[int, int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT claimed FROM todo_tasks
                 WHERE guild_id=$1
                   AND completed=FALSE
                   AND max_claims>0
                """,
                guild_id,
            )
        bonus: Dict[int, int] = {}
        for r in rows:
            for uid in r["claimed"]:
                bonus[uid] = min(3, bonus.get(uid, 0) + 1)
        return bonus

    # ═══════════════════ FEEDBACK (NEW) ═══════════════════
    # -- anon cooldown --
    async def get_last_anon_ts(self, user_id: int):
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT last_ts FROM anon_feedback_cooldown WHERE user_id=$1",
                user_id,
            )
            return row["last_ts"] if row else None

    async def set_last_anon_ts(self, user_id: int, ts):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO anon_feedback_cooldown (user_id, last_ts)
                VALUES ($1,$2)
                ON CONFLICT (user_id) DO UPDATE SET last_ts=$2
                """,
                user_id,
                ts,
            )

    # -- record feedback --
    async def record_feedback(
        self,
        *,
        msg_id: int,
        author_id: int,
        category: str,
        target_id: int | None,
        text: str,
        rating: int | None,
        attachment_urls: list[str] | None,
    ) -> int:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO feedback
                  (msg_id, author_id, category, target_id,
                   text, rating, attachment_urls)
                VALUES ($1,$2,$3,$4,$5,$6,$7)
                RETURNING id
                """,
                msg_id,
                author_id,
                category,
                target_id,
                text,
                rating,
                attachment_urls,
            )
        return row["id"]

    async def update_feedback_status(self, fid: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE feedback SET status=$2 WHERE id=$1",
                fid,
                status,
            )

    async def list_feedback_by_author(
        self, author_id: int, limit: int = 25
    ) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT id, created_at, category, status
                  FROM feedback
                 WHERE author_id=$1
                 ORDER BY id DESC
                 LIMIT $2
                """,
                author_id,
                limit,
            )
            return [dict(r) for r in rows]

    # ═══════════════════ STEAM LINKS (NEW) ═══════════════════
    async def get_steam_id(self, discord_id: int) -> Optional[str]:
        """Return the linked 64-bit Steam-ID or None if none stored."""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT steam_id64 FROM steam_links WHERE discord_id = $1",
                discord_id,
            )
            return row["steam_id64"] if row else None

    async def set_steam_id(self, discord_id: int, steam_id: str) -> None:
        """Store / overwrite the Steam-ID for a Discord user."""
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO steam_links (discord_id, steam_id64)
                VALUES ($1, $2)
                ON CONFLICT (discord_id) DO UPDATE
                  SET steam_id64 = EXCLUDED.steam_id64
                """,
                discord_id,
                steam_id,
            )

    # ═══════════════════ STEAM SYNC (NEW) ═══════════════════
    async def get_last_steam_ping(self, discord_id: int):
        """Return datetime of the last DM reminder or None."""
        row = await self.fetch_one(
            "SELECT last_ts FROM steam_ping_cooldown WHERE discord_id=$1",
            discord_id,
        )
        return row["last_ts"] if row else None

    async def set_last_steam_ping(self, discord_id: int):
        """Upsert NOW() as the last DM timestamp."""
        await self.execute(
            """
            INSERT INTO steam_ping_cooldown (discord_id, last_ts)
            VALUES ($1, NOW())
            ON CONFLICT (discord_id) DO UPDATE SET last_ts = NOW()
            """,
            discord_id,
        )


FILE: nixpacks.toml
----------------------------------------
# Forces Python 3.11 (default may eventually change)
[build]
pythonVersion = "3.11"



FILE: railway.json
----------------------------------------
{
  "build": {
    "builder": "NIXPACKS"
  },

  "volumes": [
    {
      "name": "data",
      "mountPath": "/data",
      "sizeGb": 1
    }
  ]
}



FILE: requirements.txt
----------------------------------------
discord.py[voice]>=2.3.2,<3.0
python-dotenv>=1.0
asyncpg
fastapi
uvicorn
jinja2
python-multipart
itsdangerous>=2.1
httpx
passlib[bcrypt]>=1.7.4
bcrypt<4.0
cachetools==5.3.2
requests


FILE: static\css\style.css
----------------------------------------
/* CTFO Dark theme & Neon accents */
:root {
  --bg:   #121212;        /* dark grey */
  --card: #1e1e1e;        /* card surface */

  /* new accent colours */
  --neon:      #ff2e2e;   /* vibrant red */
  --neon-glow: #ff8c0045; /* translucent orange glow */

  --ctfo-bg:        #0e0e0f;
  --ctfo-panel:     #1a1a1c;
  --ctfo-border:    #262629;
  --ctfo-red:       #ff3030;
  --ctfo-green:     #2ecc71;
  --ctfo-amber:     #f1c40f;
  --ctfo-yellow:    #f1c40f;
  --ctfo-blue:      #2980b9;

  --bs-body-bg:     var(--ctfo-bg);      /* override bootstrap var */
  --bs-body-color:  #ddd;
}

html,body {
  height: 100%;
  background: var(--bg);
  color: #fff;
  font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
}
body { background: var(--ctfo-bg); color: var(--bs-body-color); }

/* Navbar --------------------------------------------------- */
.navbar-brand,
.nav-link,
.navbar-text { color: #eee !important; }

.navbar-brand {
  font-weight: 700;
  letter-spacing: 1px;
  color: var(--neon) !important;
  text-shadow: 0 0 6px var(--neon), 0 0 12px var(--neon-glow);
}

/* Neon Button ---------------------------------------------- */
.neon-btn {
  background: var(--neon);
  border: none;
  color: #fff;
  font-weight: 600;
  box-shadow: 0 0 10px var(--neon), 0 0 4px var(--neon-glow);
  transition: transform .15s;
}
.neon-btn:hover {
  transform: translateY(-2px);
  background: var(--neon);
  box-shadow: 0 0 15px var(--neon), 0 0 6px var(--neon-glow);
}
.neon-btn:active { transform: translateY(0); }

/* Cards / lists -------------------------------------------- */
.card {
  background: var(--card);
  border: none;
  box-shadow: 0 0 12px #000 inset, 0 0 6px var(--neon-glow);
  border-radius: 14px;
}
.list-group-item {
  background: #272727;
  border: none;
  color: #eee;
}
.badge-priv {
  background: #f0ad4e;
}

/* Utilities ------------------------------------------------- */
.center-vh {
  min-height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Accordion / Panel (member forms) -------------------------- */
.accordion-item {
    background: var(--ctfo-panel);
    border: 1px solid var(--ctfo-border);
    border-radius: .35rem;
}
.accordion-button {
    background: var(--ctfo-panel);
    color: #ddd;
    padding: .6rem 1rem;
}
.accordion-button:not(.collapsed) {
    background: var(--ctfo-panel);
    box-shadow: inset 0 -1px 0 rgba(255,255,255,.05);
}
.accordion-button::after { filter: invert(90%); }  /* arrow icon */

.badge-status {
    width: 22px; height: 22px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: .85rem; border-radius: 50%;
}
.badge-pending  { background: var(--ctfo-amber); }
.badge-accepted { background: var(--ctfo-green); }
.badge-denied   { background: var(--ctfo-red);   }

textarea.form-control {
    background: #111215;
    color: #eee;
    border: 1px solid var(--ctfo-border);
}

.btn-primary  { background: var(--ctfo-blue);   border: none; }
.btn-success  { background: var(--ctfo-green);  border: none; }
.btn-warning  { background: var(--ctfo-amber);  border: none; color:#000; }
.btn-danger   { background: var(--ctfo-red);    border: none; }

.btn-primary:disabled,
.btn-warning:disabled {
    opacity: .4;
}

/* make bottom padding so last item doesn't hug footer */
#formAcc { padding-bottom: 1rem; }

/* DataTables/Member Forms custom styles --------------------- */
.table thead{background:#121216;}
table.dataTable tbody td,
table.dataTable thead th{color:#fff !important;}

td.details-control{cursor:pointer;text-align:center;width:28px;}
td.details-control i{color:var(--ctfo-red);filter:drop-shadow(0 0 3px var(--ctfo-red));
                     transition:transform .25s;}
tr.shown td.details-control i{transform:rotate(90deg);}

/* status badge (DataTable size) */
.badge-status{width:26px;height:26px;display:flex;align-items:center;justify-content:center;
              border-radius:50%;font-size:.8rem;}
.badge-pending {background:var(--ctfo-yellow);}
.badge-accepted{background:var(--ctfo-green);}
.badge-denied  {background:var(--ctfo-red);box-shadow:0 0 6px var(--ctfo-red);}

/* buttons for DataTable actions */
.btn-success{background:var(--ctfo-green);border:0;}        /* green accept */
.btn-warning{background:var(--ctfo-yellow);border:0;color:#000;}
.btn-danger {background:var(--ctfo-red);border:0;box-shadow:0 0 6px rgba(255,48,48,.5);}
.btn:disabled{opacity:.35!important;}

/* DataTables search / length controls */
.dataTables_wrapper .form-select,
.dataTables_wrapper .dataTables_filter input{background:#1c1c1f;border:1px solid #444;color:#fff;}

/* child row -----------------------------------------------------*/
tr.child td{background:transparent;border:0;padding:0 !important;}

.child-panel{
  width:100%;box-sizing:border-box;
  background:var(--ctfo-panel);
  border-left:4px solid var(--ctfo-red);
  box-shadow:0 0 8px rgba(255,48,48,.6);

  margin-top:10px;                       /* gap reduced to 10 px */
  padding:1.2rem 1.4rem 1.2rem 70px;     /* indent clears caret+badge */
}
.field-card .label{
  font-size:.72rem;text-transform:uppercase;color:#ccc;letter-spacing:.4px;
}
.field-card .label i{color:#ccc;}
.field-card .value{
  font-weight:600;color:var(--ctfo-red);text-shadow:0 0 5px var(--ctfo-red);
  word-break:break-word;
}

/* Responsive tweaks ------------------------------------------ */
@media (max-width: 991px){
  .child-panel .col-lg-3 { flex: 0 0 50%; max-width: 50%; }
}
@media (max-width: 575px){
  .child-panel .col-6, .child-panel .col-lg-3 { flex: 0 0 100%; max-width: 100%; }
}


FILE: templates\admin.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Admin Panel | CTFO{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.8/css/dataTables.bootstrap5.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
{% endblock %}

{% block content %}
<section class="container py-5">

  <!-- Tabs -->
  <ul class="nav nav-tabs mb-4">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#codes">Codes</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#forms">Member&nbsp;Forms</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#giveaways">Giveaways</button></li>
  </ul>

  <div class="tab-content">

    <!-- CODES -->
    <div class="tab-pane fade show active" id="codes">
      {% include "partials/admin_codes.html" %}
    </div>

    <!-- MEMBER FORMS: DataTable -->
    <div class="tab-pane fade" id="forms">
      <table id="formsTable" class="table table-striped align-middle w-100">
        <thead>
          <tr>
            <th></th>
            <th>Status</th>
            <th>ID</th>
            <th>User&nbsp;ID</th>
            <th>Created</th>
            <th style="width:110px;">Actions</th>
          </tr>
        </thead>
        <tbody>
          {% if forms %}
            {% for f in forms %}
              {% set badge =
                'badge-pending'  if f.status=='pending' else
                'badge-accepted' if f.status=='accepted' else
                'badge-denied'   %}
              <tr data-form='{{ f.data|tojson | safe }}'>
                <td class="details-control"><i class="fa-solid fa-caret-right fa-lg"></i></td>
                <td>
                  <span class="badge-status {{badge}}">
                    {% if f.status=='pending' %}<i class="fa fa-hourglass-half"></i>
                    {% elif f.status=='accepted' %}<i class="fa fa-check"></i>
                    {% else %}<i class="fa fa-ban"></i>{% endif %}
                  </span>
                </td>
                <td>{{f.id}}</td>
                <td>{{f.user_id}}</td>
                <td>
                  {% if f.created_at %}
                    {{ f.created_at.strftime('%Y-%m-%d %H:%M') }}
                  {% else %}
                    N/A
                  {% endif %}
                </td>
                <td class="d-flex gap-1">
                  <button class="btn btn-sm btn-success action-btn" data-id="{{f.id}}" data-action="accept"
                    {% if f.status!='pending' %}disabled{% endif %}>
                    <i class="fa fa-check"></i>
                  </button>
                  <button class="btn btn-sm btn-warning action-btn" data-id="{{f.id}}" data-action="deny"
                    {% if f.status!='pending' %}disabled{% endif %}>
                    <i class="fa fa-ban"></i>
                  </button>
                  <button class="btn btn-sm btn-danger action-btn" data-id="{{f.id}}" data-action="delete">
                    <i class="fa fa-trash"></i>
                  </button>
                </td>
              </tr>
            {% endfor %}
          {% else %}
            <tr>
              <td colspan="6" class="text-center text-muted">No member forms stored.</td>
            </tr>
          {% endif %}
        </tbody>
      </table>
    </div>

    <!-- GIVEAWAYS -->
    <div class="tab-pane fade" id="giveaways">
      {% if gws %}
        <div class="table-responsive">
          <table class="table table-dark table-striped align-middle">
            <thead>
              <tr><th>ID</th><th>Prize</th><th>Ends&nbsp;(unix)</th><th>Active?</th><th>Note</th><th>Actions</th></tr>
            </thead>
            <tbody>
              {% for g in gws %}
                <tr>
                  <form method="post" action="/giveaways/update">
                    <td><code>{{ g.id }}</code></td>
                    <td><input name="prize" class="form-control form-control-sm" value="{{ g.prize }}"></td>
                    <td><input name="end_ts" class="form-control form-control-sm" type="number" value="{{ g.end_ts }}"></td>
                    <td>{{ '✅' if g.active else '⛔' }}</td>
                    <td><input name="note" class="form-control form-control-sm" value="{{ g.note or '' }}"></td>
                    <td class="d-flex gap-2">
                      <input type="hidden" name="id" value="{{ g.id }}">
                      <button class="btn btn-sm btn-success">Save</button>
                  </form>
                  <form method="post" action="/giveaways/end">
                      <input type="hidden" name="id" value="{{ g.id }}">
                      <button class="btn btn-sm btn-warning" {% if not g.active %}disabled{% endif %}>End</button>
                  </form>
                    </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      {% else %}
        <div class="alert alert-info">No giveaways yet.</div>
      {% endif %}
    </div>
  </div>

  <footer class="text-muted text-center mt-5">&copy; {{ year }} CTFO Gaming</footer>
</section>
{% endblock %}

{% block extra_js %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/dataTables.bootstrap5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js"></script>
<script>
const ICON = {
  age      :['fa-calendar',    'Age'],
  region   :['fa-globe',       'Region'],
  bans     :['fa-ban',         'Bans'],
  ban_explanation:['fa-note-sticky','Ban explanation'],
  focus    :['fa-bullseye',    'Focus'],
  skill    :['fa-star',        'Skill'],
  steam    :['fa-link',        'Steam'],
  hours    :['fa-clock',       'Hours'],
  heard    :['fa-bullhorn',    'Heard'],
  referral :['fa-handshake',   'Referral'],
  gender   :['fa-person',      'Gender']
};
const ORDER = [
  "steam", "age", "region", "bans", "ban_explanation", "focus",
  "skill", "hours", "heard", "referral", "gender"
];

function card(k, v) {
  const [ico, label] = ICON[k] ?? ['fa-circle-question', k];
  return `<div class="col-6 col-lg-3 field-card mb-3">
    <div class="label"><i class="fa ${ico} me-1"></i>${label}</div>
    <div class="value">${v ?? 'N/A'}</div>
  </div>`;
}
function makeChild(form_data) {
  let html = '<div class="child-panel row g-4">';
  for (const k of ORDER) if (k in form_data) html += card(k, form_data[k]);
  for (const k of Object.keys(form_data)) if (!ORDER.includes(k)) html += card(k, form_data[k]);
  return html + '</div>';
}

$(function() {
  const table = $('#formsTable').DataTable({
    order: [[2, 'desc']], pageLength: 25,
    columnDefs: [{targets:[0,1,5], orderable:false}]
  });

  $('#formsTable tbody').on('click','td.details-control',function(){
     const tr = $(this).closest('tr');
     const row = table.row(tr);
     const formData = JSON.parse(tr.attr('data-form') || '{}');
     row.child.isShown()
       ? (row.child.hide(), tr.removeClass('shown'))
       : (row.child(makeChild(formData)).show(), tr.addClass('shown'));
  });

  // AJAX actions for Accept/Deny/Delete
  $('#formsTable').on('click', '.action-btn', function() {
    const id = $(this).data('id');
    const action = $(this).data('action');
    if(!id || !action) return;
    let url = `/forms/${action}`;
    let btn = $(this);
    btn.prop('disabled', true);

    $.post(url, {id: id})
      .done(function(resp) {
        const row = btn.closest('tr');
        if(action === 'delete') {
          table.row(row).remove().draw();
        } else if(resp && resp.status) {
          // Update badge
          let badgeCell = row.find('td').eq(1).find('.badge-status');
          if(action === 'accept') {
            badgeCell.removeClass().addClass('badge-status badge-accepted').html('<i class="fa fa-check"></i>');
          } else if(action === 'deny') {
            badgeCell.removeClass().addClass('badge-status badge-denied').html('<i class="fa fa-ban"></i>');
          }
          // Disable all except delete button
          row.find('.action-btn').not('[data-action="delete"]').prop('disabled', true);
        } else if(resp && resp.error) {
          alert(resp.error);
          btn.prop('disabled', false);
        }
      })
      .fail(function(xhr) {
        let msg = "Error processing action.";
        if(xhr.responseJSON && xhr.responseJSON.error) msg = xhr.responseJSON.error;
        alert(msg);
        btn.prop('disabled', false);
      });
  });
});
</script>
{% endblock %}


FILE: templates\base.html
----------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{% block title %}CTFO{% endblock %}</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
        rel="stylesheet">
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/static/css/style.css">

  {% block extra_head %}{% endblock %}
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-black px-4">
    <a class="navbar-brand" href="/">CTFO</a>
    <button class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#nav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div id="nav" class="collapse navbar-collapse">
      <ul class="navbar-nav me-auto">
        <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
        {% if user %}
          <li class="nav-item"><a class="nav-link" href="/admin">Admin</a></li>
        {% endif %}
      </ul>
      <span class="navbar-text">
        {% if user %}
          Logged in as <strong>{{ user }}</strong> |
          <a href="/logout" class="nav-link d-inline p-0">Logout</a>
        {% else %}
          <a class="nav-link d-inline p-0" href="/login">Login</a>
        {% endif %}
      </span>
    </div>
  </nav>

  {% block content %}{% endblock %}

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  {% block extra_js %}{% endblock %}
</body>
</html>


FILE: templates\login.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Login | CTFO{% endblock %}

{% block content %}
<div class="center-vh">
  <div class="card p-4" style="width:360px">
    <h3 class="text-center mb-3" style="color:var(--neon)">Admin Login</h3>
    {% if pending %}
      <div class="alert alert-info">Account created! Waiting for owner approval.</div>
    {% endif %}
    <form method="post">
      <div class="mb-3">
        <input class="form-control" placeholder="Username" name="username" required>
      </div>
      <div class="mb-3">
        <input class="form-control" type="password" placeholder="Password" name="password" required>
      </div>
      <button class="neon-btn w-100 btn">Login</button>
    </form>
    <div class="mt-3 text-center">
      <a href="/signup">Need an account? Sign up</a>
    </div>
  </div>
</div>
{% endblock %}


FILE: templates\partials\admin_codes.html
----------------------------------------
<h2 class="mb-4" style="color:var(--neon)">Codes</h2>
<div class="card p-4 mx-auto" style="max-width:560px">
  {% if codes %}
    <ul class="list-group mb-4">
      {% for c in codes %}
        <li class="list-group-item d-flex justify-content-between align-items-center">
          <span>
            <strong>{{ c['name'] }}</strong> : <code>{{ c['pin'] }}</code>
            {% if not c['public'] %}
              <span class="badge badge-priv">priv</span>
            {% endif %}
          </span>
          <form method="post" action="/codes/remove" class="m-0">
            <input type="hidden" name="name" value="{{ c['name'] }}">
            <button class="btn btn-sm btn-outline-danger">Delete</button>
          </form>
        </li>
      {% endfor %}
    </ul>
  {% else %}
    <div class="alert alert-warning text-center">No codes yet.</div>
  {% endif %}

  <form class="row g-2 align-items-center" method="post" action="/codes/add">
    <div class="col-4"><input name="name" class="form-control" placeholder="Name" required></div>
    <div class="col-3"><input name="pin" class="form-control" placeholder="1234" pattern="\d{4}" required></div>
    <div class="col-3 form-check">
      <input class="form-check-input" type="checkbox" id="pub" name="public">
      <label class="form-check-label" for="pub">Public</label>
    </div>
    <div class="col-2 d-grid"><button class="neon-btn btn">Save</button></div>
  </form>
</div>


FILE: templates\signup.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Sign Up | CTFO Admin{% endblock %}

{% block content %}
<div class="center-vh">
  <div class="card p-4" style="width:360px">
    <h3 class="text-center mb-3" style="color:var(--neon)">Admin Sign-up</h3>
    <form method="post">
      <div class="mb-3">
        <input class="form-control" placeholder="Username" name="username" required>
      </div>
      <div class="mb-3">
        <input class="form-control" type="password" placeholder="Password" name="password" required>
      </div>
      <button class="neon-btn w-100 btn">Create Account</button>
    </form>
    <div class="mt-3 text-center">
      <a href="/login">Already have one? Login</a>
    </div>
  </div>
</div>
{% endblock %}


FILE: templates\welcome.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Welcome | CTFO{% endblock %}

{% block content %}
<section class="container text-center py-5">
  <h1 class="display-4 mb-3"
      style="color:var(--neon);text-shadow:0 0 9px var(--neon);">
    Welcome to CTFO Gaming
  </h1>
  <p class="lead mb-4">Rust community focused on mega builds, PvP and good vibes.</p>

  <a href="https://discord.gg/YOUR_INVITE" class="btn neon-btn btn-lg mb-5">
    Join our Discord
  </a>

  <div class="row justify-content-center">
    <div class="col-md-6">
      <div class="card p-4">
        <h4 class="mb-2" style="color:var(--neon)">About Us</h4>
        <p>We are a tight-knit group of Rust players specialising in base
           design, electricity, farming and raids.  Apply today and find your new team.</p>
        <hr>
        <h5>Current Member Count</h5>
        <p class="display-6">{{ members }}</p>
      </div>
    </div>
  </div>

  <footer class="text-muted mt-5">&copy; {{ year }} CTFO Gaming</footer>
</section>
{% endblock %}


FILE: web.py
----------------------------------------
"""
FastAPI control-panel for CTFO bot
──────────────────────────────────
• Runs next to the Discord bot but as a separate Railway service.
• Importing ctfobot2_0 is safe because the bot starts only when
  botmod.main() is invoked (never at mere import).
"""

from __future__ import annotations

import os, json, datetime, asyncio, inspect, httpx, asyncpg
from pathlib import Path
from typing import Callable, Awaitable, Any

from itsdangerous import URLSafeSerializer, BadSignature
from passlib.context import CryptContext
from asyncpg import UniqueViolationError

from fastapi import (
    FastAPI,
    Request,
    Form,
    Response,
    HTTPException,
)
from fastapi.responses import RedirectResponse, HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

import discord

# ─────────────────────────────────────────────────────────────
#  BOT  (import-safe thanks to guard in ctfobot2_0.py)
# ─────────────────────────────────────────────────────────────
import ctfobot2_0 as botmod

BOT_TOKEN = botmod.BOT_TOKEN
GUILD_ID  = botmod.GUILD_ID

# ─────────────────────────────────────────────────────────────
#  CONFIG
# ─────────────────────────────────────────────────────────────
DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is required for the web service")

WEB_SECRET  = os.getenv("WEB_SECRET", "CHANGE_ME")
OWNER_KEY   = os.getenv("OWNER_KEY",  "OWNER_ONLY")
COOKIE_NAME = "ctfo_admin"

pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")
signer  = URLSafeSerializer(WEB_SECRET)

# ─────────────────────────────────────────────────────────────
#  FASTAPI
# ─────────────────────────────────────────────────────────────
app       = FastAPI(debug=False)
templates = Jinja2Templates(directory="templates")

static_path = Path("static")
if static_path.is_dir():
    app.mount("/static", StaticFiles(directory=static_path), name="static")

db: asyncpg.Pool | None = None        # initialised on startup

# ═════════════════════════════  HELPERS  ══════════════════════════════
async def current_user(request: Request) -> str | None:
    """
    Return username stored in signed cookie **if** that user exists in DB
    and is approved; otherwise None.
    """
    if db is None:
        return None

    token = request.cookies.get(COOKIE_NAME)
    if not token:
        return None
    try:
        username = signer.loads(token)
    except BadSignature:
        return None

    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT username, approved FROM admins WHERE username=$1",
            username
        )
    return row["username"] if row and row["approved"] else None


def login_required(fn: Callable[..., Awaitable[Any]]):
    """
    Decorator that
      • verifies cookie,
      • redirects unauthenticated users to /login,
      • injects a `user` argument (str) into the endpoint.
    """
    sig      = inspect.signature(fn)
    params   = list(sig.parameters.values())

    async def wrapper(request: Request, *args, **kwargs):   # type: ignore
        user = await current_user(request)
        if not user:
            return RedirectResponse("/login", status_code=303)
        return await fn(request, user, *args, **kwargs)

    wrapper.__name__      = fn.__name__
    wrapper.__doc__       = fn.__doc__
    wrapper.__signature__ = inspect.Signature(
        parameters=[p for p in params if p.name != "user"]
    )
    return wrapper


def _build_role_list(guild: discord.Guild, data: dict[str, str]):
    roles: list[discord.Role] = []
    if (r := guild.get_role(botmod.ACCEPT_ROLE_ID)):                               roles.append(r)
    if (r := guild.get_role(botmod.REGION_ROLE_IDS.get(data.get("region"), 0))):   roles.append(r)
    if (r := guild.get_role(botmod.FOCUS_ROLE_IDS.get(data.get("focus"), 0))):     roles.append(r)
    return roles

# ═════════════════════════════  START-UP  ═════════════════════════════
@app.on_event("startup")
async def init_database():
    global db
    db = await asyncpg.create_pool(DATABASE_URL)
    async with db.acquire() as conn:
        await conn.execute("""
        CREATE TABLE IF NOT EXISTS admins (
            username TEXT PRIMARY KEY,
            pwd_hash TEXT NOT NULL,
            approved BOOLEAN NOT NULL DEFAULT FALSE
        );""")
        await conn.execute("""
        CREATE TABLE IF NOT EXISTS codes (
            name TEXT PRIMARY KEY,
            pin  TEXT NOT NULL,
            public BOOLEAN NOT NULL DEFAULT FALSE
        );""")
    print("[web] DB pool ready")


@app.on_event("startup")
async def launch_discord_bot():
    """
    Start the Discord bot in *this* process **only if** BOT_TOKEN is set.
    botmod.main() is synchronous; it schedules the async start coroutine
    on the already-running FastAPI loop.
    """
    if BOT_TOKEN:
        botmod.main()                        # no create_task needed
        print("[web] Discord bot task scheduled")


@app.on_event("shutdown")
async def stop_discord_bot():
    if not botmod.bot.is_closed():
        await botmod.bot.close()
        print("[web] Discord bot stopped")

# ═════════════════════════════  DATA QUERIES  ═════════════════════════
async def all_admin_data():
    """Fetch codes, member_forms, giveaways for the admin dashboard."""
    async with db.acquire() as conn:
        codes = await conn.fetch("SELECT * FROM codes ORDER BY name")
        forms = await conn.fetch(
            "SELECT * FROM member_forms ORDER BY created_at DESC"
        )
        gws   = await conn.fetch(
            "SELECT * FROM giveaways ORDER BY end_ts DESC"
        )

    forms_parsed = []
    for rec in forms:
        d = dict(rec)
        if isinstance(d["data"], str):
            try:
                d["data"] = json.loads(d["data"])
            except json.JSONDecodeError:
                d["data"] = {}
        forms_parsed.append(d)
    return codes, forms_parsed, gws

# ═════════════════════════════  PUBLIC PAGE  ══════════════════════════
@app.get("/", response_class=HTMLResponse)
async def welcome(request: Request):
    """Landing page that shows live guild member count via widget."""
    member_count = "?"
    try:
        async with httpx.AsyncClient() as cli:
            r = await cli.get(
                f"https://discord.com/api/guilds/{GUILD_ID}/widget.json",
                timeout=5
            )
            if r.status_code == 200:
                member_count = len(r.json()["members"])
    except Exception:
        pass

    return templates.TemplateResponse(
        "welcome.html",
        {
            "request": request,
            "year": datetime.datetime.now().year,
            "members": member_count,
        },
    )

# ═════════════════════════════  ADMIN PANEL  ══════════════════════════
@app.get("/admin", response_class=HTMLResponse)
@login_required
async def admin_panel(request: Request, user: str):
    codes, forms, gws = await all_admin_data()
    return templates.TemplateResponse(
        "admin.html",
        {
            "request": request,
            "codes": codes,
            "forms": forms,
            "gws":   gws,
            "user":  user,
            "year":  datetime.datetime.now().year,
        },
    )

# ═════════════════════════════  SIGN-UP / LOGIN  ══════════════════════
async def _get_admin_row(username: str):
    async with db.acquire() as conn:
        return await conn.fetchrow(
            "SELECT * FROM admins WHERE username=$1", username
        )

@app.get("/signup", response_class=HTMLResponse)
async def signup_get(request: Request):
    return templates.TemplateResponse("signup.html", {"request": request})


@app.post("/signup")
async def signup_post(username: str = Form(...), password: str = Form(...)):
    hash_ = pwd_ctx.hash(password)
    async with db.acquire() as conn:
        try:
            await conn.execute(
                "INSERT INTO admins (username, pwd_hash) VALUES ($1,$2)",
                username, hash_
            )
        except UniqueViolationError:
            raise HTTPException(400, "Username already exists.")
    return RedirectResponse("/login?pending=1", status_code=303)


@app.get("/login", response_class=HTMLResponse)
async def login_get(request: Request, pending: int | None = None):
    return templates.TemplateResponse(
        "login.html", {"request": request, "pending": pending}
    )

@app.post("/login")
async def login_post(
    response: Response,
    username: str = Form(...),
    password: str = Form(...)
):
    row = await _get_admin_row(username)
    if (not row
            or not row["approved"]
            or not pwd_ctx.verify(password, row["pwd_hash"])):
        raise HTTPException(403, "Invalid credentials or not yet approved.")

    resp = RedirectResponse("/admin", status_code=303)
    resp.set_cookie(
        COOKIE_NAME, signer.dumps(username),
        httponly=True, max_age=7 * 86400
    )
    return resp

@app.get("/logout")
async def logout():
    resp = RedirectResponse("/", status_code=303)
    resp.delete_cookie(COOKIE_NAME)
    return resp

# ═══════════════════════════  OWNER-ONLY ENDPOINT  ════════════════════
@app.post("/approve")
async def approve_user(request: Request, username: str = Form(...)):
    if request.headers.get("X-OWNER-KEY") != OWNER_KEY:
        raise HTTPException(403, "Bad owner key.")
    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE admins SET approved=TRUE WHERE username=$1", username
        )
    return "approved"

# ═════════════════════════════  CODE MANAGEMENT  ══════════════════════
@app.post("/codes/add")
@login_required
async def add_code(
    request: Request,
    user: str,
    name: str = Form(...),
    pin: str  = Form(...),
    public: str | None = Form(None)
):
    if not (pin.isdigit() and len(pin) == 4):
        raise HTTPException(400, "Pin must be 4 digits.")
    async with db.acquire() as conn:
        await conn.execute("""
            INSERT INTO codes (name, pin, public)
            VALUES ($1,$2,$3)
            ON CONFLICT(name) DO UPDATE SET pin=$2, public=$3
        """, name, pin, public is not None)
    return RedirectResponse("/admin", status_code=303)


@app.post("/codes/remove")
@login_required
async def remove_code(request: Request, user: str, name: str = Form(...)):
    async with db.acquire() as conn:
        await conn.execute("DELETE FROM codes WHERE name=$1", name)
    return RedirectResponse("/admin", status_code=303)

# ═════════════════════════════  MEMBER-FORM CRUD  ═════════════════════
@app.post("/forms/update")
@login_required
async def update_form(
    request: Request,
    user: str,
    id: int = Form(...),
    json_text: str = Form(..., alias="json")
):
    try:
        parsed = json.loads(json_text)
    except json.JSONDecodeError:
        raise HTTPException(400, "Not valid JSON.")

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET data=$2 WHERE id=$1",
            id, parsed
        )
    return JSONResponse({"status": "updated"})


@app.post("/forms/accept")
@login_required
async def accept_member(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT user_id, data, status FROM member_forms WHERE id=$1", id
        )
    if not row or row["status"] != "pending":
        raise HTTPException(400, "Form not found or already handled")

    data: dict = json.loads(row["data"]) if isinstance(row["data"], str) else row["data"]
    uid: int   = row["user_id"]

    guild = botmod.bot.get_guild(GUILD_ID)
    if not guild:
        raise HTTPException(503, "Discord bot not ready")

    try:
        member = await guild.fetch_member(uid)
    except discord.NotFound:
        raise HTTPException(404, "User left the guild")

    roles = _build_role_list(guild, data)
    if not roles:
        raise HTTPException(500, "Required roles missing in guild")
    await member.add_roles(*roles, reason=f"Accepted via web panel ({user})")

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET status='accepted' WHERE id=$1", id
        )
    return JSONResponse({"status": "accepted"})


@app.post("/forms/deny")
@login_required
async def deny_member(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT user_id, status FROM member_forms WHERE id=$1", id
        )
    if not row or row["status"] != "pending":
        raise HTTPException(400, "Form not found or already handled")

    uid: int = row["user_id"]
    guild    = botmod.bot.get_guild(GUILD_ID)
    if not guild:
        raise HTTPException(503, "Discord bot not ready")

    await guild.ban(
        discord.Object(id=uid),
        reason=f"Application denied via web panel by {user} (temp-ban)",
        delete_message_seconds=0
    )

    async def unban_later():
        await asyncio.sleep(botmod.TEMP_BAN_SECONDS)
        try:
            await guild.unban(discord.Object(id=uid), reason="Temp ban expired")
        except discord.HTTPException:
            pass
    asyncio.create_task(unban_later())

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET status='denied' WHERE id=$1", id
        )
    return JSONResponse({"status": "denied"})


@app.post("/forms/delete")
@login_required
async def delete_form(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        await conn.execute("DELETE FROM member_forms WHERE id=$1", id)
    return JSONResponse({"status": "deleted"})

# ═════════════════════════════  GIVEAWAYS  ════════════════════════════
@app.post("/giveaways/update")
@login_required
async def update_giveaway(
    request: Request,
    user: str,
    id: int = Form(...),
    prize: str = Form(...),
    end_ts: int = Form(...),
    note: str = Form("")
):
    async with db.acquire() as conn:
        await conn.execute("""
            UPDATE giveaways
               SET prize=$2, end_ts=$3, note=$4
             WHERE id=$1
        """, id, prize, end_ts, note)
    return RedirectResponse("/admin#giveaways", status_code=303)


@app.post("/giveaways/end")
@login_required
async def end_giveaway(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE giveaways SET active=FALSE WHERE id=$1", id
        )
    return RedirectResponse("/admin#giveaways", status_code=303)

