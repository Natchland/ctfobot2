====================================
PROJECT STRUCTURE AND CONTENTS
====================================

PROJECT STRUCTURE:
==================
â”œâ”€â”€ .gitignore
â”œâ”€â”€ ctfobot2_0.py
â”œâ”€â”€ db.py
â”œâ”€â”€ nixpacks.toml
â”œâ”€â”€ railway.json
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ web.py
â”œâ”€â”€ cogs/
â”‚   â”œâ”€â”€ codes.py
â”‚   â”œâ”€â”€ feedback.py
â”‚   â”œâ”€â”€ giveaways.py
â”‚   â”œâ”€â”€ member_forms.py
â”‚   â”œâ”€â”€ quota.py
â”‚   â”œâ”€â”€ recruit_reminder.py
â”‚   â”œâ”€â”€ staff_applications.py
â”‚   â”œâ”€â”€ stats.py
â”‚   â”œâ”€â”€ stay_or_go.py
â”‚   â”œâ”€â”€ steam_sync.py
â”‚   â”œâ”€â”€ todo.py
â”‚   â”œâ”€â”€ warnings.py
â”‚   â”œâ”€â”€ welcome_general.py
â”‚   â”œâ”€â”€ welcome_member.py
â”‚   â””â”€â”€ xp.py
â”œâ”€â”€ static/
â”‚   â””â”€â”€ css/
â”‚       â””â”€â”€ style.css
â””â”€â”€ templates/
    â”œâ”€â”€ admin.html
    â”œâ”€â”€ base.html
    â”œâ”€â”€ login.html
    â”œâ”€â”€ signup.html
    â”œâ”€â”€ welcome.html
    â””â”€â”€ partials/
        â””â”€â”€ admin_codes.html

FILE CONTENTS:
==============

FILE: cogs\codes.py
----------------------------------------
# cogs/codes.py
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Access-Code system  â€“  /codes slash-commands + single embed
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from __future__ import annotations

import os
import asyncio
import contextlib
from datetime import datetime, timezone
from typing import Dict, Optional

import asyncpg
import discord
from discord import app_commands
from discord.ext import commands

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CODES_CH_ID  = 1398667158237483138                 # channel that holds the embed
STORE_PATH   = "/data/codes_msg_id.txt"            # remembers embed message-id
DATABASE_URL = os.getenv("DATABASE_URL")           # for LISTEN codes_changed
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Embed builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _build_embed(codes: Dict[str, tuple[str, bool]]) -> discord.Embed:
    e = discord.Embed(
        title="ğŸ”‘ Access Codes",
        description="Codes with ğŸ”’ are **private** (hidden from `/codes list`).",
        colour=discord.Color.blue(),
        timestamp=datetime.now(timezone.utc),
    )
    if not codes:
        e.description += "\n\n*No codes configured yet.*"
    else:
        for name, (pin, public) in codes.items():
            lock = "" if public else " ğŸ”’"
            e.add_field(name=f"{name}{lock}", value=f"`{pin}`", inline=False)
    return e


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CodesCog(commands.Cog):
    """/codes command group, single embed upkeep, Postgres listener."""

    # group is auto-registered when cog is injected
    codes_group = app_commands.Group(name="codes", description="Manage / view access codes")

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._lock = asyncio.Lock()
        self._listener_task: Optional[asyncio.Task] = None
        self._ready = False                        # run on_ready once

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLEAN-UP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def cog_unload(self):
        if self._listener_task:
            self._listener_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._listener_task

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AFTER LOGIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready:
            return
        self._ready = True

        # wait until the core bot has created the asyncpg pool
        while self.db.pool is None:
            await asyncio.sleep(0.5)

        await self._refresh_embed()
        self._listener_task = asyncio.create_task(self._listen_pg())

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UTILITIES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _channel(self) -> Optional[discord.TextChannel]:
        ch = self.bot.get_channel(CODES_CH_ID)
        return ch if isinstance(ch, discord.TextChannel) else None

    @staticmethod
    def _valid_pin(pin: str) -> bool:
        return pin.isdigit() and len(pin) == 4

    async def _is_staff(self, i: discord.Interaction) -> bool:
        reviewers = await self.db.get_reviewers()
        return i.user.guild_permissions.administrator or i.user.id in reviewers

    # â•â•â•â•â•â•â•â•â•â•â•â•â• EMBED REFRESH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _refresh_embed(self):
        async with self._lock:                     # debounce
            try:
                ch = await self._channel()
                if ch is None:
                    print("[codes] Codes channel not found!")
                    return

                # ----- find existing embed -----
                msg: Optional[discord.Message] = None
                if os.path.exists(STORE_PATH):
                    try:
                        mid = int(open(STORE_PATH).read())
                        msg = await ch.fetch_message(mid)
                    except (ValueError, discord.NotFound, discord.HTTPException):
                        msg = None
                if msg is None:
                    async for m in ch.history(limit=50):
                        if (m.author == self.bot.user
                                and m.embeds
                                and m.embeds[0].title.startswith("ğŸ”‘ Access Codes")):
                            msg = m
                            break

                embed = _build_embed(await self.db.get_codes())

                if msg:
                    await msg.edit(embed=embed)
                    mid = msg.id
                else:
                    msg = await ch.send(embed=embed)
                    mid = msg.id

                os.makedirs(os.path.dirname(STORE_PATH), exist_ok=True)
                with open(STORE_PATH, "w") as f:
                    f.write(str(mid))

                print(f"[codes] Embed refreshed (message {mid})")
            except Exception as exc:
                print(f"[codes] refresh error: {type(exc).__name__}: {exc}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â• SLASH COMMANDS â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    @codes_group.command(name="add", description="Add a new access code")
    @app_commands.describe(name="Code name", pin="4-digit number", public="Visible in /codes list?")
    async def add_code(self, i: discord.Interaction, name: str, pin: str, public: bool = False):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if not self._valid_pin(pin):
            return await i.response.send_message("PIN must be 4 digits.", ephemeral=True)
        if name in await self.db.get_codes():
            return await i.response.send_message("Name already exists.", ephemeral=True)

        await self.db.add_code(name, pin, public)
        await self._refresh_embed()
        await i.response.send_message("Code added.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="edit", description="Edit an existing code")
    @app_commands.describe(name="Existing name", pin="New 4-digit pin", public="Leave blank to keep current visibility")
    async def edit_code(self, i: discord.Interaction, name: str, pin: str, public: Optional[bool] = None):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if not self._valid_pin(pin):
            return await i.response.send_message("PIN must be 4 digits.", ephemeral=True)
        if name not in await self.db.get_codes():
            return await i.response.send_message("No such code.", ephemeral=True)

        await self.db.edit_code(name, pin, public)
        await self._refresh_embed()
        await i.response.send_message("Code updated.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="remove", description="Delete a code")
    async def remove_code(self, i: discord.Interaction, name: str):
        if not await self._is_staff(i):
            return await i.response.send_message("Permission denied.", ephemeral=True)
        if name not in await self.db.get_codes():
            return await i.response.send_message("No such code.", ephemeral=True)

        await self.db.remove_code(name)
        await self._refresh_embed()
        await i.response.send_message("Code removed.", ephemeral=True)

    # -------------------------------------------------------
    @codes_group.command(name="list", description="Show public codes")
    async def list_codes(self, i: discord.Interaction):
        pub = await self.db.get_codes(only_public=True)
        if not pub:
            return await i.response.send_message("No public codes.", ephemeral=True)
        await i.response.send_message(
            "\n".join(f"â€¢ **{n}**: `{pin}`" for n, (pin, _) in pub.items()),
            ephemeral=True
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â• Postgres LISTEN â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _listen_pg(self):
        if not DATABASE_URL:
            print("[codes] DATABASE_URL not set â€“ listener disabled")
            return
        try:
            conn: asyncpg.Connection = await asyncpg.connect(DATABASE_URL)
            await conn.add_listener(
                "codes_changed",
                lambda *_: asyncio.create_task(self._refresh_embed())
            )
            print("[codes] LISTEN codes_changed attached")

            while True:
                await asyncio.sleep(3600)          # keep task alive
        except asyncio.CancelledError:
            pass
        except Exception as exc:
            print(f"[codes] listener error: {type(exc).__name__}: {exc}")
        finally:
            with contextlib.suppress(Exception):
                await conn.close()


# â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db):
    await bot.add_cog(CodesCog(bot, db))


FILE: cogs\feedback.py
----------------------------------------
# cogs/feedback.py
# =============================================================
# /feedback â†’ embed to staff channel + private per-case channel
# Category auto-created if missing.  âœ… Resolved deletes channel.
# =============================================================
from __future__ import annotations

import contextlib
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, cast

import discord
from discord import app_commands
from discord.ext import commands

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FEEDBACK_CH_ID   = 1413188006499586158      # staff feedback channel
THREAD_CAT_NAME  = "Feedback Threads"       # created/used automatically
ANON_RATE        = timedelta(hours=24)      # 1 anonymous post / 24 h

CAT_COMPLAINT = "Staff / Member complaint"
CAT_DISCORD   = "Discord issue"
CAT_OTHER     = "Other"
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


# â•â•â• helper â€“ ensure category exists â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def ensure_case_category(
    guild: discord.Guild, staff_tpl: discord.TextChannel
) -> discord.CategoryChannel:
    for cat in guild.categories:
        if cat.name.lower() == THREAD_CAT_NAME.lower():
            return cat

    overwrites = {k: v for k, v in staff_tpl.overwrites.items()}
    overwrites.setdefault(
        guild.default_role, discord.PermissionOverwrite(view_channel=False)
    )

    return await guild.create_category(
        name=THREAD_CAT_NAME,
        overwrites=overwrites,
        reason="Initial feedback case category",
    )


# â•â•â• Modal (body only) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class BodyModal(discord.ui.Modal):
    def __init__(
        self,
        cog: "FeedbackCog",
        *,
        category_label: str,
        target: Optional[discord.Member],
        anonymous: bool,
    ):
        super().__init__(title="Describe your feedback")
        self.cog, self.cat, self.target, self.anon = (
            cog, category_label, target, anonymous
        )
        self.body = discord.ui.TextInput(
            label="Details (max 2000 chars)",
            style=discord.TextStyle.paragraph,
            max_length=2000,
        )
        self.add_item(self.body)

    async def on_submit(self, inter: discord.Interaction):
        await self.cog._finalise_feedback(
            inter,
            category_label=self.cat,
            target=self.target,
            anonymous=self.anon,
            text=self.body.value,
        )


# â•â•â• helper â€“ create per-case channel â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def create_case_channel(
    guild: discord.Guild,
    fid: int,
    *,
    staff_tpl: discord.TextChannel,
) -> discord.TextChannel:
    category = await ensure_case_category(guild, staff_tpl)

    overwrites = {k: v for k, v in staff_tpl.overwrites.items()}
    overwrites[guild.default_role] = discord.PermissionOverwrite(view_channel=False)

    return await guild.create_text_channel(
        name=f"feedback-{fid}",
        category=category,
        overwrites=overwrites,
        topic=f"Private discussion for feedback #{fid}",
        reason="New feedback received",
    )


# â•â•â• Staff triage / Contact view â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TriageView(discord.ui.View):
    def __init__(self, db, fid: int, author_id: int, case_chan_id: int):
        super().__init__(timeout=None)
        self.db, self.fid, self.author_id, self.case_chan_id = (
            db, fid, author_id, case_chan_id
        )
        if author_id == 0:
            self.contact.disabled = True  # anonymous

    async def _set_status(self, inter, status, colour):
        if not (
            inter.user.guild_permissions.manage_messages
            or inter.user.guild_permissions.administrator
        ):
            return await inter.response.send_message("No permission.", ephemeral=True)

        emb = inter.message.embeds[0]
        emb.colour = colour
        emb.set_footer(
            text=f"Status: {status} â€¢ by {inter.user}",
            icon_url=inter.user.display_avatar.url,
        )
        await inter.message.edit(embed=emb, view=self)
        await self.db.update_feedback_status(self.fid, status)

        # Auto-delete when resolved
        if status == "Resolved":
            chan = inter.guild and inter.guild.get_channel(self.case_chan_id)
            if isinstance(chan, discord.TextChannel):
                with contextlib.suppress(discord.Forbidden, discord.HTTPException):
                    await chan.delete(reason="Feedback resolved")

        await inter.response.send_message("Status updated.", ephemeral=True)

    @discord.ui.button(label="Ack", style=discord.ButtonStyle.gray, emoji="ğŸ‘€")
    async def ack(self, i, _): await self._set_status(i, "Ack", discord.Color.yellow())

    @discord.ui.button(label="WIP", style=discord.ButtonStyle.blurple, emoji="ğŸ”§")
    async def wip(self, i, _): await self._set_status(i, "WIP", discord.Color.blue())

    @discord.ui.button(label="Resolved", style=discord.ButtonStyle.green, emoji="âœ…")
    async def res(self, i, _): await self._set_status(i, "Resolved", discord.Color.green())

    # ---- Contact button -------------------------------------
    @discord.ui.button(label="Contact", style=discord.ButtonStyle.gray, emoji="âœ‰ï¸")
    async def contact(self, inter: discord.Interaction, _):
        if self.author_id == 0:
            return await inter.response.send_message("Author is anonymous.", ephemeral=True)

        guild = inter.guild
        chan  = guild and guild.get_channel(self.case_chan_id)
        if chan is None:
            return await inter.response.send_message("Case channel missing.", ephemeral=True)

        author_obj: discord.abc.Snowflake = (
            guild.get_member(self.author_id)
            or await inter.client.fetch_user(self.author_id)
        )

        try:
            await chan.set_permissions(
                author_obj,
                overwrite=discord.PermissionOverwrite(view_channel=True,
                                                      send_messages=True),
            )
        except discord.Forbidden:
            return await inter.response.send_message(
                "Cannot edit channel permissions.", ephemeral=True
            )

        await chan.send(
            f"{author_obj.mention} â€“ staff member {inter.user.mention} would like "
            "to discuss your feedback. Please reply here."
        )
        await inter.response.send_message(f"Author invited! â†’ {chan.mention}", ephemeral=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Cog â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FeedbackCog(commands.Cog):
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        if not hasattr(bot, "last_anonymous_time"):
            bot.last_anonymous_time = cast(Dict[int, datetime], {})

    # ---------- /feedback command ----------------------------
    @app_commands.command(name="feedback", description="Send feedback to the staff")
    @app_commands.describe(
        category="Select a category",
        target="User you're complaining about (if Complaint)",
        anonymous="Hide your name from staff?",
    )
    @app_commands.choices(
        category=[
            app_commands.Choice(name=CAT_COMPLAINT, value="complaint"),
            app_commands.Choice(name=CAT_DISCORD,   value="discord"),
            app_commands.Choice(name=CAT_OTHER,     value="other"),
        ]
    )
    async def feedback(
        self, inter: discord.Interaction,
        *, category: app_commands.Choice[str],
        anonymous: bool = False,
        target: Optional[discord.Member] = None,
    ):
        if category.value == "complaint" and target is None:
            return await inter.response.send_message(
                "Please choose a target user for complaints.", ephemeral=True
            )

        # anon cooldown
        if anonymous:
            now = datetime.now(timezone.utc)
            last = self.bot.last_anonymous_time.get(inter.user.id) \
                   or await self.db.get_last_anon_ts(inter.user.id)
            if last:
                self.bot.last_anonymous_time[inter.user.id] = last
            if last and now - last < ANON_RATE:
                rem = ANON_RATE - (now - last)
                h, r = divmod(rem.seconds, 3600); m, _ = divmod(r, 60)
                return await inter.response.send_message(
                    f"You can post anonymously again in {rem.days}d {h}h {m}m.",
                    ephemeral=True,
                )

        await inter.response.send_modal(
            BodyModal(self,
                      category_label=category.name,
                      target=target,
                      anonymous=anonymous)
        )

    # ---------- modal callback -------------------------------
    async def _finalise_feedback(
        self, inter: discord.Interaction,
        *, category_label: str, target: Optional[discord.Member],
        anonymous: bool, text: str,
    ):
        colour = discord.Color.light_gray() if anonymous else discord.Color.blue()
        embed = discord.Embed(title=category_label, description=text,
                              colour=colour, timestamp=datetime.now(timezone.utc))
        if target:
            embed.add_field(name="Target", value=target.mention, inline=False)

        if anonymous:
            embed.set_footer(text="Sent anonymously")
            author_id_db = 0
        else:
            embed.set_author(name=str(inter.user),
                             icon_url=inter.user.display_avatar.url)
            author_id_db = inter.user.id

        staff_chan = inter.client.get_channel(FEEDBACK_CH_ID)  # type: ignore
        if not isinstance(staff_chan, discord.TextChannel):
            return await inter.response.send_message(
                "Staff feedback channel missing.", ephemeral=True
            )

        msg = await staff_chan.send(embed=embed)

        fid = await self.db.record_feedback(
            msg_id=msg.id,
            author_id=author_id_db,
            category=category_label,
            target_id=target.id if target else None,
            text=text,
            rating=None,
            attachment_urls=None,
        )

        case_chan = await create_case_channel(
            guild=staff_chan.guild,
            fid=fid,
            staff_tpl=staff_chan,
        )

        await msg.edit(view=TriageView(self.db, fid, author_id_db, case_chan.id))

        if anonymous:
            now = datetime.now(timezone.utc)
            self.bot.last_anonymous_time[inter.user.id] = now
            await self.db.set_last_anon_ts(inter.user.id, now)

        await inter.response.send_message("âœ…  Thanks for the feedback!", ephemeral=True)

    # ---------- /myfeedback ----------------------------------
    @app_commands.command(name="myfeedback", description="DM your last 25 feedback submissions")
    async def myfeedback(self, inter: discord.Interaction):
        rows = await self.db.list_feedback_by_author(inter.user.id, 25)
        if not rows:
            return await inter.response.send_message(
                "You have no feedback entries.", ephemeral=True
            )

        summary = "\n".join(
            f"- {r['created_at']:%Y-%m-%d} â€¢ {r['category']} â€¢ {r['status']} (ID {r['id']})"
            for r in rows
        )
        await inter.user.send(summary)
        await inter.response.send_message("ğŸ“¨  Sent to your DMs.", ephemeral=True)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ setup entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def setup(bot, db):
    await bot.add_cog(FeedbackCog(bot, db))


FILE: cogs\giveaways.py
----------------------------------------
# cogs/giveaways.py  â€“  production-ready giveaway cog
# Updated 2024-10-08
#
# â€¢ To-Do bonuses (+1 / claim, cap +3)
# â€¢ Manual ticket commands  /giveaway entries add|clear|list
# â€¢ NEW  /giveaway exclude add|remove|list   (hard-ban from giveaway)
# â€¢ Start-timestamp restored on reboot â†’ ticket totals persist.
# --------------------------------------------------------------------

from __future__ import annotations

import asyncio
import datetime as dt
import random
from typing import Dict, Optional, TYPE_CHECKING

import asyncpg
import discord
from discord import app_commands
from discord.ext import commands, tasks

if TYPE_CHECKING:      # only for type-checkers
    from ctfobot2_0 import Database


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• constants â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GUILD_ID            = 1377035207777194005
GIVEAWAY_CHANNEL_ID = 1413929735658016899
ACTIVE_ROLE_ID      = 1403337937722019931

ADMIN_ROLE_IDS = {1377103244089622719}

STAFF_BONUS_ROLE_IDS = {
    1377077466513932338,
    1377084533706588201,
    1410659214959054988,
}

STREAK_BONUS_PER_SET = 3
STAFF_BONUS_PER_WEEK = 1
BOOST_BONUS_PER_WEEK = 2
TODO_BONUS_CAP       = 3

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SQL setup â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE_MANUAL_SQL = """
CREATE TABLE IF NOT EXISTS giveaway_manual_entries (
    message_id BIGINT,
    user_id    BIGINT,
    tickets    INTEGER,
    PRIMARY KEY (message_id, user_id)
);
"""

CREATE_EXCL_SQL = """
CREATE TABLE IF NOT EXISTS giveaway_excluded (
    message_id BIGINT,
    user_id    BIGINT,
    PRIMARY KEY (message_id, user_id)
);
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• helper functions â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def _fmt_left(td: dt.timedelta) -> str:
    sec = max(int(td.total_seconds()), 0)
    d, sec = divmod(sec, 86_400)
    h, sec = divmod(sec, 3_600)
    m, s   = divmod(sec, 60)
    if d:  return f"{d}d {h}h {m}m"
    if h:  return f"{h}h {m}m {s}s"
    if m:  return f"{m}m {s}s"
    return f"{s}s"

def _is_admin(m: discord.Member) -> bool:
    return (
        m.guild_permissions.administrator
        or m.id == m.guild.owner_id
        or any(r.id in ADMIN_ROLE_IDS for r in m.roles)
    )

async def _activity_map(pool: asyncpg.Pool) -> dict[int, dict]:
    rows = await pool.fetch("SELECT * FROM activity")
    return {r["user_id"]: dict(r) for r in rows}

async def _todo_bonus_map(pool: asyncpg.Pool, guild_id: int) -> dict[int, int]:
    rows = await pool.fetch(
        "SELECT claimed FROM todo_tasks "
        "WHERE guild_id=$1 AND completed=FALSE AND max_claims>0",
        guild_id,
    )
    bonus: dict[int, int] = {}
    for r in rows:
        for uid in r["claimed"]:
            bonus[uid] = min(TODO_BONUS_CAP, bonus.get(uid, 0) + 1)
    return bonus

async def _manual_bonus_map(pool: asyncpg.Pool, msg_id: int) -> dict[int, int]:
    rows = await pool.fetch(
        "SELECT user_id, tickets FROM giveaway_manual_entries WHERE message_id=$1",
        msg_id,
    )
    return {r["user_id"]: r["tickets"] for r in rows}

async def _excluded_set(pool: asyncpg.Pool, msg_id: int) -> set[int]:
    rows = await pool.fetch(
        "SELECT user_id FROM giveaway_excluded WHERE message_id=$1", msg_id
    )
    return {r["user_id"] for r in rows}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Giveaway object â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Giveaway:
    instances: Dict[int, "Giveaway"] = {}          # message_id â†’ instance

    def __init__(self, prize: str, ends_at: dt.datetime,
                 *, started_at: Optional[dt.datetime] = None):
        self.prize      = prize
        self.ends_at    = ends_at
        self.started_at = started_at or dt.datetime.utcnow().replace(
            tzinfo=dt.timezone.utc
        )

        self.message: Optional[discord.Message] = None
        self.entrants: Dict[int, int] = {}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ticket maths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _tickets_for(self, m: discord.Member, act: dict[int, dict]) -> int:
        if ACTIVE_ROLE_ID not in [r.id for r in m.roles]:
            return 0

        now     = dt.datetime.utcnow().replace(tzinfo=dt.timezone.utc)
        tickets = 1

        if rec := act.get(m.id):
            days_since_start = (now.date() - self.started_at.date()).days + 1
            effective_streak = min(rec["streak"], days_since_start)
            tickets += (effective_streak // 3) * STREAK_BONUS_PER_SET

        if m.premium_since:
            effective = max(m.premium_since, self.started_at)
            tickets += ((now - effective).days // 7) * BOOST_BONUS_PER_WEEK

        if any(r.id in STAFF_BONUS_ROLE_IDS for r in m.roles):
            tickets += ((now - self.started_at).days // 7) * STAFF_BONUS_PER_WEEK

        return tickets

    async def recompute(self, guild: discord.Guild, pool: asyncpg.Pool):
        act      = await _activity_map(pool)
        todo_b   = await _todo_bonus_map(pool, guild.id)
        manual_b = await _manual_bonus_map(pool, self.message.id)
        excl_set = await _excluded_set(pool, self.message.id)

        self.entrants.clear()
        for m in guild.members:
            if m.bot or m.id in excl_set:
                continue
            t = await self._tickets_for(m, act)
            t += todo_b.get(m.id, 0) + manual_b.get(m.id, 0)
            if t:
                self.entrants[m.id] = t

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ embeds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _embed(self, guild: discord.Guild,
               *, ended=False, winner: Optional[discord.Member]=None) -> discord.Embed:
        e = discord.Embed(title="ğŸ‰ GIVEAWAY ğŸ‰",
                          colour=discord.Color.blurple())
        e.add_field(name="Prize", value=f"**{self.prize}**", inline=False)

        if ended:
            e.add_field(name="Time left", value="**Ended**", inline=False)
        else:
            left = self.ends_at - dt.datetime.utcnow().replace(
                tzinfo=dt.timezone.utc
            )
            e.add_field(name="Time left", value=f"**{_fmt_left(left)}**",
                        inline=False)

        e.add_field(name="Eligibility",
                    value=f"Only <@&{ACTIVE_ROLE_ID}> can win.",
                    inline=False)

        if ended:
            e.add_field(name="Winner",
                        value=winner.mention if winner else "Cancelled",
                        inline=False)
        else:
            listing = (
                "\n".join(
                    f"â€¢ {guild.get_member(uid).mention} â€“ **{t}**"
                    for uid, t in sorted(self.entrants.items(),
                                         key=lambda kv: (-kv[1], kv[0]))
                )
                or "*None yet*"
            )
            e.add_field(name="Eligible Entrants", value=listing, inline=False)
        return e

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DB helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _insert_row(self, pool: asyncpg.Pool, ch_id: int):
        await pool.execute(
            """
            INSERT INTO giveaways
              (channel_id, message_id, prize,
               start_ts, end_ts, active)
            VALUES ($1,$2,$3,$4,$5,TRUE)
            """,
            ch_id, self.message.id, self.prize,
            int(self.started_at.timestamp()),
            int(self.ends_at.timestamp()),
        )

    async def _close_row(self, pool: asyncpg.Pool, winner_id: Optional[int]):
        await pool.execute(
            "UPDATE giveaways SET active=FALSE, note=$1 WHERE message_id=$2",
            str(winner_id) if winner_id else "cancelled",
            self.message.id,
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def start(self, ch: discord.TextChannel, pool: asyncpg.Pool):
        await self.recompute(ch.guild, pool)
        self.message = await ch.send(
            embed=self._embed(ch.guild), view=_GwButtons(self, pool)
        )
        Giveaway.instances[self.message.id] = self
        await self._insert_row(pool, ch.id)

    async def cancel(self, guild: discord.Guild, pool: asyncpg.Pool):
        await self._close_row(pool, None)
        await self.message.edit(embed=self._embed(guild, ended=True), view=None)

    async def draw(self, guild: discord.Guild,
                   pool: asyncpg.Pool) -> Optional[discord.Member]:
        await self.recompute(guild, pool)
        if not self.entrants:
            return None
        ids, weights = zip(*self.entrants.items())
        return guild.get_member(random.choices(ids, weights)[0])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• admin buttons â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class _GwButtons(discord.ui.View):
    def __init__(self, gw: Giveaway, pool: asyncpg.Pool):
        super().__init__(timeout=None)
        self.gw, self.pool = gw, pool

    async def interaction_check(self, inter: discord.Interaction) -> bool:
        if not _is_admin(inter.user):
            await inter.response.send_message("Not authorised.",
                                              ephemeral=True)
            return False
        return True

    @discord.ui.button(label="ğŸ End & Draw",
                       style=discord.ButtonStyle.green)
    async def _end(self, inter: discord.Interaction, _):
        winner = await self.gw.draw(inter.guild, self.pool)
        await self.gw._close_row(self.pool, winner.id if winner else None)
        await self.gw.message.edit(
            embed=self.gw._embed(inter.guild, True, winner), view=None
        )
        if winner:
            await inter.channel.send(
                f"ğŸ‰ Congratulations {winner.mention}! "
                f"You won **{self.gw.prize}**!"
            )
        await inter.response.send_message("Giveaway ended.", ephemeral=True)

    @discord.ui.button(label="âŒ Cancel", style=discord.ButtonStyle.danger)
    async def _cancel(self, inter: discord.Interaction, _):
        await self.gw.cancel(inter.guild, self.pool)
        await inter.response.send_message("Cancelled.", ephemeral=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Cog â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class GiveawayCog(commands.Cog):
    def __init__(self, bot: commands.Bot, db: Database):
        self.bot, self.db = bot, db
        self._resume_started = False

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ main slash group â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    giveaway_group = app_commands.Group(name="giveaway", description="Giveaway tools")

    @giveaway_group.command(name="create", description="Create a giveaway")
    @app_commands.describe(prize="Prize", duration="Duration in hours (1-720)")
    async def giveaway_create(
        self, inter: discord.Interaction,
        prize: str,
        duration: app_commands.Range[int, 1, 720],
    ):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        await inter.response.defer(ephemeral=True)

        ch = inter.guild.get_channel(GIVEAWAY_CHANNEL_ID)
        if not ch:
            return await inter.followup.send("Giveaway channel missing.", ephemeral=True)

        ends_at = dt.datetime.utcnow().replace(tzinfo=dt.timezone.utc) + dt.timedelta(hours=duration)
        gw = Giveaway(prize, ends_at)
        await gw.start(ch, self.db.pool)
        self._background(gw).start()

        await inter.followup.send("Giveaway created!", ephemeral=True)

    # â•â•â•â•â•â•â•â•â• manual ticket sub-group â•â•â•â•â•â•â•â•â•
    entries_group = app_commands.Group(
        name="entries", description="Manual ticket management",
        parent=giveaway_group
    )

    @entries_group.command(name="add", description="Add extra tickets for a user")
    @app_commands.describe(
        giveaway="Message link or ID",
        user="Member",
        tickets="Tickets to add (1-100)"
    )
    async def entries_add(self, inter: discord.Interaction,
                          giveaway: str, user: discord.Member,
                          tickets: app_commands.Range[int, 1, 100]):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_MANUAL_SQL)
        await self.db.pool.execute(
            """
            INSERT INTO giveaway_manual_entries (message_id, user_id, tickets)
            VALUES ($1,$2,$3)
            ON CONFLICT (message_id,user_id) DO UPDATE SET tickets=$3
            """, msg_id, user.id, tickets
        )
        await inter.response.send_message(f"Set **{tickets}** tickets for {user.mention}.", ephemeral=True)

        if gw := Giveaway.instances.get(msg_id):
            await gw.recompute(inter.guild, self.db.pool)
            await gw.message.edit(embed=gw._embed(inter.guild))

    @entries_group.command(name="clear", description="Remove manual tickets for a user")
    async def entries_clear(self, inter: discord.Interaction,
                            giveaway: str, user: discord.Member):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_MANUAL_SQL)
        await self.db.pool.execute(
            "DELETE FROM giveaway_manual_entries WHERE message_id=$1 AND user_id=$2",
            msg_id, user.id
        )
        await inter.response.send_message("Manual tickets cleared.", ephemeral=True)

        if gw := Giveaway.instances.get(msg_id):
            await gw.recompute(inter.guild, self.db.pool)
            await gw.message.edit(embed=gw._embed(inter.guild))

    @entries_group.command(name="list", description="List manual tickets for a giveaway")
    async def entries_list(self, inter: discord.Interaction,
                           giveaway: str):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_MANUAL_SQL)
        rows = await self.db.pool.fetch(
            "SELECT user_id, tickets FROM giveaway_manual_entries WHERE message_id=$1",
            msg_id
        )
        if not rows:
            return await inter.response.send_message("No manual entries.", ephemeral=True)

        txt = "\n".join(f"â€¢ <@{r['user_id']}> â€“ **{r['tickets']}**" for r in rows)
        await inter.response.send_message(txt, ephemeral=True)

    # â•â•â•â•â•â•â•â•â• exclude (ban) sub-group â•â•â•â•â•â•â•â•â•
    exclude_group = app_commands.Group(
        name="exclude", description="Ban / unban participants",
        parent=giveaway_group
    )

    @exclude_group.command(name="add", description="Ban a member from this giveaway")
    async def exclude_add(self, inter: discord.Interaction,
                          giveaway: str, user: discord.Member):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_EXCL_SQL)
        await self.db.pool.execute(
            "INSERT INTO giveaway_excluded (message_id, user_id) VALUES ($1,$2) "
            "ON CONFLICT DO NOTHING", msg_id, user.id
        )
        # also delete manual tickets if any
        await self.db.pool.execute(
            "DELETE FROM giveaway_manual_entries WHERE message_id=$1 AND user_id=$2",
            msg_id, user.id
        )
        await inter.response.send_message(f"{user.mention} is now excluded.", ephemeral=True)

        if gw := Giveaway.instances.get(msg_id):
            await gw.recompute(inter.guild, self.db.pool)
            await gw.message.edit(embed=gw._embed(inter.guild))

    @exclude_group.command(name="remove", description="Unban a member")
    async def exclude_remove(self, inter: discord.Interaction,
                             giveaway: str, user: discord.Member):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_EXCL_SQL)
        await self.db.pool.execute(
            "DELETE FROM giveaway_excluded WHERE message_id=$1 AND user_id=$2",
            msg_id, user.id
        )
        await inter.response.send_message(f"{user.mention} re-added to giveaway.", ephemeral=True)

        if gw := Giveaway.instances.get(msg_id):
            await gw.recompute(inter.guild, self.db.pool)
            await gw.message.edit(embed=gw._embed(inter.guild))

    @exclude_group.command(name="list", description="List currently banned users")
    async def exclude_list(self, inter: discord.Interaction, giveaway: str):
        if not _is_admin(inter.user):
            return await inter.response.send_message("Admins only.", ephemeral=True)

        msg_id = _extract_msg_id(giveaway)
        if msg_id is None:
            return await inter.response.send_message("Bad link / ID.", ephemeral=True)

        await self.db.pool.execute(CREATE_EXCL_SQL)
        rows = await self.db.pool.fetch(
            "SELECT user_id FROM giveaway_excluded WHERE message_id=$1", msg_id
        )
        if not rows:
            return await inter.response.send_message("No one is excluded.", ephemeral=True)

        await inter.response.send_message(
            "\n".join(f"â€¢ <@{r['user_id']}>" for r in rows), ephemeral=True
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 15-sec updater loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _background(self, gw: Giveaway):
        @tasks.loop(seconds=15)
        async def _loop():
            now = dt.datetime.utcnow().replace(tzinfo=dt.timezone.utc)
            if now >= gw.ends_at:
                winner = await gw.draw(gw.message.guild, self.db.pool)
                await gw._close_row(self.db.pool, winner.id if winner else None)
                await gw.message.edit(embed=gw._embed(gw.message.guild, True, winner),
                                      view=None)
                if winner:
                    await gw.message.channel.send(
                        f"ğŸ‰ {winner.mention} wins **{gw.prize}**!"
                    )
                _loop.cancel()
                return

            await gw.recompute(gw.message.guild, self.db.pool)
            await gw.message.edit(embed=gw._embed(gw.message.guild))

        return _loop

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ resume on reboot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _resume(self):
        await self.bot.wait_until_ready()
        while self.db.pool is None:
            await asyncio.sleep(1)

        await self.db.pool.execute(CREATE_MANUAL_SQL)
        await self.db.pool.execute(CREATE_EXCL_SQL)

        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        rows = await self.db.pool.fetch("SELECT * FROM giveaways WHERE active=TRUE")
        for r in rows:
            chan = guild.get_channel(r["channel_id"])
            if not chan:
                continue
            try:
                msg = await chan.fetch_message(r["message_id"])
            except discord.NotFound:
                await self.db.pool.execute(
                    "UPDATE giveaways SET active=FALSE WHERE message_id=$1",
                    r["message_id"]
                )
                continue

            gw = Giveaway(
                r["prize"],
                dt.datetime.fromtimestamp(r["end_ts"], tz=dt.timezone.utc),
                started_at=dt.datetime.fromtimestamp(r["start_ts"], tz=dt.timezone.utc)
            )
            gw.message = msg
            Giveaway.instances[msg.id] = gw
            await msg.edit(view=_GwButtons(gw, self.db.pool))
            self._background(gw).start()
        print("[giveaways] resume finished")

    @commands.Cog.listener()
    async def on_ready(self):
        if not self._resume_started:
            self._resume_started = True
            asyncio.create_task(self._resume())

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• utility â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def _extract_msg_id(text: str) -> Optional[int]:
    if text.isdigit():
        return int(text)
    parts = text.strip("/").split("/")
    if parts and parts[-1].isdigit():
        return int(parts[-1])
    return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db: Database):
    await bot.add_cog(GiveawayCog(bot, db))


FILE: cogs\member_forms.py
----------------------------------------
# cogs/member_forms.py
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Member registration workflow + reviewer commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import os
import re
from typing import Dict, Optional

import httpx
import discord
from discord import app_commands
from discord.ext import commands

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ log setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log = logging.getLogger("cog.member_forms")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ENV / CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
try:
    # Optional â€“ load .env if python-dotenv is installed
    from dotenv import load_dotenv

    load_dotenv()
except Exception:
    pass


def req(name: str) -> str:
    """Get a required env-var or raise & log clearly."""
    value = os.getenv(name)
    if not value:
        log.error("[member_forms] REQUIRED env variable %s missing - cog disabled", name)
        raise RuntimeError(f"Missing env {name}")
    return value


STEAM_API_KEY = req("STEAM_API_KEY")
GUILD_ID = int(req("GUILD_ID"))

# The rest are optional â€“ fall back to literal IDs if not found
MEMBER_FORM_CH = int(os.getenv("MEMBER_FORM_CH", "1378118620873494548"))
UNCOMPLETED_APP_ROLE_ID = int(os.getenv("UNCOMPLETED_APP_ROLE_ID", "1390143545066917931"))
COMPLETED_APP_ROLE_ID = int(os.getenv("COMPLETED_APP_ROLE_ID", "1398708167525011568"))
ACCEPT_ROLE_ID = int(os.getenv("ACCEPT_ROLE_ID", "1377075930144571452"))

ROLE_PREFIXES = {
    "PvP": "[P]",
    "Farming": "[F]",
    "Electricity": "[E]",
    "Building": "[B]",
    "Base Sorting": "[BB]",
}

REGION_ROLE_IDS = {
    "North America": 1411364406096433212,
    "Europe": 1411364744484491287,
    "Asia": 1411364982117105684,
    "Other": 1411365034440921260,
}
FOCUS_ROLE_IDS = {
    "Farming": 1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building": 1380233086544908428,
    "Electricity": 1380233234675400875,
    "PvP": 1408687710159245362,
}
TEMP_BAN_SECONDS = 7 * 24 * 60 * 60
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STEAM API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASE_URL = "https://api.steampowered.com"


async def _steam_get(client: httpx.AsyncClient, endpoint: str, params: dict) -> dict:
    """Call Steam Web API endpoint with given params. Never raise; return {} on error.
    The API key is passed as a param and never logged.
    """
    try:
        r = await client.get(f"{BASE_URL}/{endpoint}", params=params, timeout=6.0)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as exc:
        status = exc.response.status_code
        # Avoid logging the key; show endpoint only
        if status == 403:
            log.warning("Steam request 403 Forbidden on %s", endpoint)
        else:
            log.warning("Steam request failed (%s) on %s: %s", status, endpoint, exc)
        return {}
    except Exception as exc:
        log.warning("Steam request error on %s: %s", endpoint, exc)
        return {}


async def extract_steam_id(url: str) -> Optional[str]:
    """Extract a 64-bit SteamID from a profile URL. Resolve vanity if needed."""
    url = url.strip().lower()

    # /profiles/<64-bit>
    if (m := re.search(r"steamcommunity\.com/profiles/(\d{17})", url)):
        return m.group(1)

    # /id/<vanity>  â†’ ResolveVanityURL
    if (m := re.search(r"steamcommunity\.com/id/([\w\-]+)", url)):
        vanity = m.group(1)
        async with httpx.AsyncClient() as client:
            data = await _steam_get(
                client,
                "ISteamUser/ResolveVanityURL/v1/",
                {"key": STEAM_API_KEY, "vanityurl": vanity},
            )
        return data.get("response", {}).get("steamid")

    return None


async def is_steam_profile_valid(steam_id: str) -> bool:
    """
    Requirements for a *valid* profile:
      â€¢ profile visibility  == public (3)
      â€¢ at least 1 owned game  AND  at least 1 h (â‰¥60 min) on ANY game
      â€¢ friends list not empty
    """
    async with httpx.AsyncClient() as client:
        summary, games, friends = await asyncio.gather(
            _steam_get(
                client,
                "ISteamUser/GetPlayerSummaries/v2/",
                {"key": STEAM_API_KEY, "steamids": steam_id},
            ),
            _steam_get(
                client,
                "IPlayerService/GetOwnedGames/v1/",
                {"key": STEAM_API_KEY, "steamid": steam_id, "include_appinfo": 0},
            ),
            _steam_get(
                client,
                "ISteamUser/GetFriendList/v1/",
                {"key": STEAM_API_KEY, "steamid": steam_id},
            ),
        )

    # 1) profile visibility
    player = (summary.get("response", {}).get("players") or [{}])[0]
    if player.get("communityvisibilitystate") != 3:
        return False

    # 2) games + â‰¥1 h play-time
    g_resp = games.get("response", {})
    if g_resp.get("game_count", 0) == 0:
        return False

    games_list = g_resp.get("games", [])
    has_1h = any((g.get("playtime_forever") or 0) >= 60 for g in games_list)
    if not has_1h:
        return False

    # 3) friends not empty
    if not friends.get("friendslist", {}).get("friends"):
        return False

    return True


async def get_steam_username(steam_id: str) -> Optional[str]:
    async with httpx.AsyncClient() as client:
        data = await _steam_get(
            client,
            "ISteamUser/GetPlayerSummaries/v2/",
            {"key": STEAM_API_KEY, "steamids": steam_id},
        )
    player = (data.get("response", {}).get("players") or [{}])[0]
    return player.get("personaname")


def _opts(*lbl: str) -> list[discord.SelectOption]:
    return [discord.SelectOption(label=l, value=l) for l in lbl]


async def safe_fetch(guild: discord.Guild, uid: int) -> Optional[discord.Member]:
    try:
        return await guild.fetch_member(uid)
    except (discord.NotFound, discord.HTTPException):
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MemberFormCog(commands.Cog):
    """Member registration workflow + reviewer helper commands."""

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._ready_once = False

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ on_ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready_once:
            return
        self._ready_once = True
        await self._restore_action_views()
        log.info("[member_forms] persistent ActionViews reattached")

    async def _restore_action_views(self):
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        chan = guild.get_channel(MEMBER_FORM_CH)
        if not isinstance(chan, discord.TextChannel):
            return

        for row in await self.db.get_pending_member_forms():
            try:
                await chan.fetch_message(row["message_id"])
            except discord.NotFound:
                continue  # message gone

            region = row.get("region")
            focus = row.get("focus")

            if not region or not focus:
                raw = row.get("data") or {}
                if isinstance(raw, str):
                    with contextlib.suppress(json.JSONDecodeError):
                        raw = json.loads(raw)
                region = region or raw.get("region")
                focus = focus or raw.get("focus")

            if not region or not focus:
                continue

            self.bot.add_view(
                ActionView(guild, row["user_id"], region, focus, self.db),
                message_id=row["message_id"],
            )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ reviewer cmds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @app_commands.command(name="addreviewer", description="Add a reviewer")
    async def add_reviewer(self, i: discord.Interaction, member: discord.Member):
        if not i.user.guild_permissions.administrator:
            return await i.response.send_message("No permission.", ephemeral=True)
        await self.db.add_reviewer(member.id)
        await i.response.send_message("Added.", ephemeral=True)

    @app_commands.command(name="removereviewer", description="Remove a reviewer")
    async def remove_reviewer(self, i: discord.Interaction, member: discord.Member):
        if not i.user.guild_permissions.administrator:
            return await i.response.send_message("No permission.", ephemeral=True)
        await self.db.remove_reviewer(member.id)
        await i.response.send_message("Removed.", ephemeral=True)

    @app_commands.command(name="reviewers", description="List reviewers")
    async def list_reviewers(self, i: discord.Interaction):
        reviewers = await self.db.get_reviewers()
        txt = ", ".join(f"<@{u}>" for u in reviewers) or "None."
        await i.response.send_message(txt, ephemeral=True)

    # /memberform entry-point
    @app_commands.command(name="memberform", description="Start member registration")
    async def memberform(self, i: discord.Interaction):
        await i.response.send_message(
            "Click below to begin registration:",
            view=MemberRegistrationView(self.db),
            ephemeral=True,
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  REGISTRATION UI  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MemberRegistrationView(discord.ui.View):
    """Five dropdowns â†’ then Submit button."""

    def __init__(self, db):
        super().__init__(timeout=300)
        self.db = db
        self.data: Dict[str, str] = {}
        self.user: Optional[discord.User] = None
        self.start_msg: Optional[discord.Message] = None
        self.submit_msg: Optional[discord.Message] = None
        self.submit_sent = False

    # first button
    @discord.ui.button(label="Start Registration", style=discord.ButtonStyle.primary)
    async def start(self, i: discord.Interaction, _):
        self.user = i.user
        self.clear_items()
        self.add_item(SelectAge(self))
        self.add_item(SelectRegion(self))
        self.add_item(SelectBans(self))
        self.add_item(SelectFocus(self))
        self.add_item(SelectSkill(self))
        await i.response.edit_message(
            content="Fill each dropdown â€“ **Submit** appears when all done.",
            view=self,
        )
        self.start_msg = await i.original_response()


# ---------- generic dropdown base ----------
class _BaseSelect(discord.ui.Select):
    def __init__(self, v: MemberRegistrationView, key: str, **kw):
        self.v, self.key = v, key
        super().__init__(**kw)

    async def callback(self, i: discord.Interaction):
        self.v.data[self.key] = self.values[0]
        self.placeholder = self.values[0]
        await i.response.edit_message(view=self.v)
        if (
            not self.v.submit_sent
            and all(k in self.v.data for k in ("age", "region", "bans", "focus", "skill"))
        ):
            self.v.submit_sent = True
            self.v.submit_msg = await i.followup.send(
                "All set â€“ click **Submit**:",
                view=SubmitView(self.v),
                ephemeral=True,
                wait=True,
            )


# ---------- concrete dropdowns ----------
class SelectAge(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "age", placeholder="Age", options=_opts("12-14", "15-17", "18-21", "21+"))


class SelectRegion(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "region", placeholder="Region", options=_opts("North America", "Europe", "Asia", "Other"))


class SelectBans(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "bans", placeholder="Any bans?", options=_opts("Yes", "No"))


class SelectFocus(_BaseSelect):
    def __init__(self, v):
        super().__init__(
            v,
            "focus",
            placeholder="Main focus",
            options=_opts("PvP", "Farming", "Base Sorting", "Building", "Electricity"),
        )


class SelectSkill(_BaseSelect):
    def __init__(self, v):
        super().__init__(v, "skill", placeholder="Skill level", options=_opts("Beginner", "Intermediate", "Advanced", "Expert"))


# ---------- submit helper view ----------
class SubmitView(discord.ui.View):
    def __init__(self, v: MemberRegistrationView):
        super().__init__(timeout=300)
        self.v = v

    @discord.ui.button(label="Submit", style=discord.ButtonStyle.success)
    async def submit(self, i: discord.Interaction, _):
        await i.response.send_modal(FinalRegistrationModal(self.v))


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  FINAL MODAL  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class FinalRegistrationModal(discord.ui.Modal):
    def __init__(self, v: MemberRegistrationView):
        self.v = v
        needs_ban = v.data.get("bans") == "Yes"
        super().__init__(title="More Details" if needs_ban else "Additional Info")

        self.steam = discord.ui.TextInput(label="Steam Profile Link", placeholder="https://steamcommunity.com/â€¦")
        self.hours = discord.ui.TextInput(label="Hours in Rust")
        self.heard = discord.ui.TextInput(label="Where did you hear about us?")

        self.ban_expl = self.gender = self.referral = None
        if needs_ban:
            self.ban_expl = discord.ui.TextInput(label="Ban Explanation", style=discord.TextStyle.paragraph)
            self.referral = discord.ui.TextInput(label="Referral (optional)", required=False)
            comps = (self.steam, self.hours, self.heard, self.ban_expl, self.referral)
        else:
            self.referral = discord.ui.TextInput(label="Referral (optional)", required=False)
            self.gender = discord.ui.TextInput(label="Gender (optional)", required=False)
            comps = (self.steam, self.hours, self.heard, self.referral, self.gender)
        for c in comps:
            self.add_item(c)

    # ------------------------------------------------------------
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)

        d = self.v.data
        user = self.v.user or interaction.user
        link = self.steam.value.strip()

        steam_id = await extract_steam_id(link)
        if not steam_id:
            return await interaction.followup.send(
                "âš ï¸ I couldn't read that Steam link â€“ make sure it's a full profile URL "
                "(`/profiles/â€¦` or `/id/â€¦`).", ephemeral=True
            )

        if not await is_steam_profile_valid(steam_id):
            return await interaction.followup.send(
                "âš ï¸ Your Steam profile must be **fully public** and show at least "
                "one game, at least one friend, and **at least one hour of play-time**.\n"
                "Please adjust your privacy settings and try again.",
                ephemeral=True,
    )

        # â”€â”€â”€â”€â”€ Build reviewer embed â”€â”€â”€â”€â”€
        e = (
            discord.Embed(
                title="ğŸ“‹ NEW MEMBER REGISTRATION",
                colour=discord.Color.gold(),
                timestamp=interaction.created_at,
            )
            .set_author(name=str(user), icon_url=user.display_avatar.url)
        )
        e.add_field(name="ğŸ‘¤ User",   value=user.mention, inline=False)
        e.add_field(name="ğŸ”— Steam",  value=link,         inline=False)
        e.add_field(name="ğŸ—“ï¸ Age",   value=d["age"],     inline=True)
        e.add_field(name="ğŸŒ Region", value=d["region"],  inline=True)
        e.add_field(name="ğŸš« Bans",   value=d["bans"],    inline=True)
        if d["bans"] == "Yes" and self.ban_expl:
            e.add_field(name="ğŸ“ Ban Explanation", value=self.ban_expl.value, inline=False)
        e.add_field(name="ğŸ¯ Focus",  value=d["focus"],   inline=True)
        e.add_field(name="â­ Skill",  value=d["skill"],   inline=True)
        e.add_field(name="â±ï¸ Hours", value=self.hours.value, inline=True)
        e.add_field(name="ğŸ“¢ Heard about us", value=self.heard.value, inline=False)
        e.add_field(name="ğŸ¤ Referral", value=self.referral.value if self.referral else "N/A", inline=True)
        if self.gender:
            e.add_field(name="âš§ï¸ Gender", value=self.gender.value or "N/A", inline=True)

        review_ch: discord.TextChannel = interaction.client.get_channel(MEMBER_FORM_CH)  # type: ignore
        msg = await review_ch.send(
            embed=e,
            view=ActionView(interaction.guild, user.id, d["region"], d["focus"], self.v.db),
        )

        # â”€â”€â”€â”€â”€ DB save â”€â”€â”€â”€â”€
        await self.v.db.add_member_form(
            user.id,
            {
                **d,
                "steam": link,
                "hours": self.hours.value,
                "heard": self.heard.value,
                "referral": self.referral.value if self.referral else None,
                "gender":   self.gender.value   if self.gender   else None,
                "ban_explanation": self.ban_expl.value if self.ban_expl else None,
            },
            message_id=msg.id,
        )

        # swap roles
        try:
            member = await interaction.guild.fetch_member(user.id)
            unc    = interaction.guild.get_role(UNCOMPLETED_APP_ROLE_ID)
            comp   = interaction.guild.get_role(COMPLETED_APP_ROLE_ID)
            if comp and comp not in member.roles:
                await member.add_roles(comp, reason="Application submitted")
            if unc and unc in member.roles:
                await member.remove_roles(unc, reason="Application submitted")
        except discord.Forbidden:
            pass

        await interaction.followup.send("âœ… Registration submitted â€“ thank you!", ephemeral=True)

        # tidy helper messages
        async def tidy():
            await asyncio.sleep(2)
            for m in (self.v.start_msg, self.v.submit_msg):
                if m:
                    with contextlib.suppress(discord.HTTPException):
                        await m.delete()
        asyncio.create_task(tidy())


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  REVIEWER ActionView  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ActionView(discord.ui.View):
    # unchanged __init__
    def __init__(self, guild: discord.Guild, uid: int, region: str, focus: str, db):
        super().__init__(timeout=None)
        self.guild, self.uid, self.region, self.focus, self.db = guild, uid, region, focus, db

    async def _reviewers(self) -> set[int]:
        return await self.db.get_reviewers()

    async def _finish(
        self,
        interaction: discord.Interaction,
        txt: str,
        colour: discord.Colour,
    ):
        """Disable buttons, recolour embed, then send confirmation."""
        emb = interaction.message.embeds[0]
        emb.colour = colour

        for c in self.children:
            c.disabled = True
        await interaction.message.edit(embed=emb, view=self)

        # choose response vs follow-up
        if interaction.response.is_done():
            await interaction.followup.send(txt, ephemeral=True)
        else:
            await interaction.response.send_message(txt, ephemeral=True)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Accept â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @discord.ui.button(
        label="Accept",
        style=discord.ButtonStyle.success,
        emoji="âœ…",
        custom_id="memberform_accept",
    )
    async def accept(self, interaction: discord.Interaction, _):
        # Acknowledge as early as possible
        await interaction.response.defer(ephemeral=True)

        if (
            interaction.user.id not in await self._reviewers()
            and not interaction.user.guild_permissions.manage_roles
        ):
            return await interaction.followup.send("Not authorised.", ephemeral=True)

        mem = await safe_fetch(self.guild, self.uid)
        if not mem:
            return await interaction.followup.send("Member left.", ephemeral=True)

        # â”€â”€ nickname â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        steam_link = next(
            (f.value for f in interaction.message.embeds[0].fields
             if f.name.startswith("ğŸ”—")),
            None,
        )
        steam_username = None
        if steam_link:
            if (steam_id := await extract_steam_id(steam_link)):
                steam_username = await get_steam_username(steam_id)

        prefix = ROLE_PREFIXES.get(self.focus, "")
        nick   = f"{prefix} {steam_username or mem.display_name}".strip()[:32]
        with contextlib.suppress(discord.Forbidden):
            await mem.edit(nick=nick)

        # â”€â”€ roles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        roles = [
            r for r in (
                self.guild.get_role(ACCEPT_ROLE_ID),
                self.guild.get_role(REGION_ROLE_IDS.get(self.region, 0)),
                self.guild.get_role(FOCUS_ROLE_IDS.get(self.focus, 0)),
            ) if r
        ]
        with contextlib.suppress(discord.Forbidden):
            if roles:
                await mem.add_roles(*roles, reason="Application accepted")

        await self.db.update_member_form_status(interaction.message.id, "accepted")
        await self._finish(interaction, f"{mem.mention} accepted âœ…", discord.Color.green())

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Deny â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @discord.ui.button(
        label="Deny",
        style=discord.ButtonStyle.danger,
        emoji="â›”",
        custom_id="memberform_deny",
    )
    async def deny(self, interaction: discord.Interaction, _):
        # Defer immediately
        await interaction.response.defer(ephemeral=True)

        # permission check
        if (
            interaction.user.id not in await self._reviewers()
            and not interaction.user.guild_permissions.ban_members
        ):
            return await interaction.followup.send("Not authorised.", ephemeral=True)

        # fetch applicant
        mem = await safe_fetch(self.guild, self.uid)
        if mem:
            with contextlib.suppress(discord.Forbidden):
                await self.guild.ban(
                    mem,
                    reason="Application denied â€“ temp ban",
                    delete_message_seconds=0,
                )

            # schedule un-ban
            async def unban_later():
                await asyncio.sleep(TEMP_BAN_SECONDS)
                with contextlib.suppress(Exception):
                    await self.guild.unban(discord.Object(self.uid))

            asyncio.create_task(unban_later())

        # DB + UI
        await self.db.update_member_form_status(interaction.message.id, "denied")
        await self._finish(
            interaction,
            "Application denied â›”",
            discord.Color.red(),
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db):
    await bot.add_cog(MemberFormCog(bot, db))


FILE: cogs\quota.py
----------------------------------------
# cogs/quota.py
from __future__ import annotations

import asyncio
import logging
import os
import re
import time
import uuid
from collections import defaultdict
from datetime import datetime, timedelta, timezone
from typing import Callable, Dict, List, Optional

import discord
from discord import app_commands
from discord.ext import commands, tasks

log = logging.getLogger(__name__)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GROUP_LEADER_ROLE_ID = 1377077466513932338
PLAYER_MGMT_ROLE_ID  = 1377084533706588201
ADMIN_ROLE_ID        = 1377103244089622719

QUOTA_REVIEW_CH_ID = 1421920458437169254
PUBLIC_QUOTA_CH_ID = 1421945592522739824

RESOURCES          = ["wood", "stone", "metal", "sulfur"]
PROGRESS_BAR_LEN   = 25
TASK_TOP_LIMIT     = 5
GLOBAL_LB_SIZE     = 15
LB_REFRESH_SECONDS = 15
QUOTA_IMAGE_DIR    = "/data/quota_images"

RESET_WEEKDAY  = 3   # Thursday
RESET_HOUR_UTC = 14  # 14:00 UTC (15:00 BST)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SQL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE_SQL = """
CREATE TABLE IF NOT EXISTS default_quotas (
    resource TEXT PRIMARY KEY,
    weekly   INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS quotas (
    user_id  BIGINT,
    resource TEXT,
    weekly   INTEGER NOT NULL,
    PRIMARY KEY (user_id, resource)
);
CREATE TABLE IF NOT EXISTS quota_submissions (
    id        SERIAL PRIMARY KEY,
    user_id   BIGINT,
    resource  TEXT,
    amount    INTEGER,
    image_url TEXT,
    reviewed  BOOLEAN DEFAULT FALSE,
    week_ts   DATE DEFAULT CURRENT_DATE
);
CREATE TABLE IF NOT EXISTS quota_tasks (
    id         SERIAL PRIMARY KEY,
    name       TEXT,
    start_sub  INTEGER,
    completed  BOOLEAN DEFAULT FALSE,
    message_id BIGINT
);
CREATE TABLE IF NOT EXISTS quota_task_needs (
    task_id  INTEGER REFERENCES quota_tasks(id) ON DELETE CASCADE,
    resource TEXT,
    required INTEGER,
    PRIMARY KEY (task_id, resource)
);
CREATE TABLE IF NOT EXISTS quota_weekly_lb (
    id         INT PRIMARY KEY CHECK(id=1),
    message_id BIGINT
);
"""

SET_DEFAULT_SQL = """
INSERT INTO default_quotas (resource,weekly)
VALUES ($1,$2)
ON CONFLICT(resource) DO UPDATE SET weekly=$2
"""
SET_USER_SQL = """
INSERT INTO quotas (user_id,resource,weekly)
VALUES ($1,$2,$3)
ON CONFLICT(user_id,resource) DO UPDATE SET weekly=$3
"""

PENDING_GROUP_SQL = """
SELECT user_id,
       jsonb_object_agg(resource,total) AS res_totals,
       array_agg(id)                    AS ids
FROM (
    SELECT user_id,resource,SUM(amount) total,array_agg(id) id
    FROM quota_submissions
    WHERE reviewed=FALSE
    GROUP BY user_id,resource
) t
GROUP BY user_id
ORDER BY user_id
"""

MARK_MANY_SQL = "UPDATE quota_submissions SET reviewed=TRUE WHERE id = ANY($1::INT[])"

GLOBAL_LB_SQL = """
SELECT user_id,SUM(amount) AS total
FROM quota_submissions
WHERE reviewed=TRUE AND week_ts>=CURRENT_DATE - INTERVAL '6 days'
GROUP BY user_id
ORDER BY total DESC
LIMIT $1
"""

RESOURCE_TOT_SQL = """
SELECT resource,SUM(amount) total
FROM quota_submissions
WHERE reviewed=TRUE AND week_ts>=CURRENT_DATE - INTERVAL '6 days'
GROUP BY resource
"""

PURGE_OLD_SQL = "DELETE FROM quota_submissions WHERE week_ts < CURRENT_DATE - INTERVAL '15 days'"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _has(member: discord.Member, *ids: int) -> bool:
    return any(r.id in ids for r in member.roles)

def role_check(*ids: int) -> Callable:
    async def predicate(inter: discord.Interaction) -> bool:
        if isinstance(inter.user, discord.Member) and _has(inter.user, *ids):
            return True
        raise app_commands.CheckFailure("You don't have permission for that command.")
    return app_commands.check(predicate)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class QuotaCog(commands.Cog):
    # ---------------- Review Buttons ----------------
    class AcceptUserBtn(discord.ui.Button):
        def __init__(self, ids: List[int], outer: "QuotaCog"):
            super().__init__(label="Accept âœ…", style=discord.ButtonStyle.success)
            self.ids, self.outer = ids, outer
        async def callback(self, inter: discord.Interaction):
            await self.outer.db.pool.execute(MARK_MANY_SQL, self.ids)
            await inter.response.send_message("Reviewed.", ephemeral=True)
            self.disabled, self.label = True, "Reviewed"
            await inter.message.edit(view=self.view)
            await self.outer.refresh_everything()

    class ReviewUsersView(discord.ui.View):
        def __init__(self, rows, outer: "QuotaCog"):
            super().__init__(timeout=600)
            for r in rows:
                self.add_item(QuotaCog.AcceptUserBtn(r["ids"], outer))

    class SingleAcceptBtn(discord.ui.Button):
        def __init__(self, ids: List[int], outer: "QuotaCog"):
            super().__init__(label="Accept âœ…", style=discord.ButtonStyle.success)
            self.ids, self.outer = ids, outer
        async def callback(self, inter: discord.Interaction):
            await self.outer.db.pool.execute(MARK_MANY_SQL, self.ids)
            await inter.response.send_message("Marked reviewed.", ephemeral=True)
            self.disabled, self.label = True, "Reviewed"
            await inter.message.edit(view=self.view, content="**(reviewed)**")
            await self.outer.refresh_everything()

    class SingleAcceptView(discord.ui.View):
        def __init__(self, outer: "QuotaCog", ids: List[int]):
            super().__init__(timeout=None)
            self.add_item(QuotaCog.SingleAcceptBtn(ids, outer))

    class ResetConfirmBtn(discord.ui.Button):
        def __init__(self, outer: "QuotaCog"):
            super().__init__(label="Wipe All Data", style=discord.ButtonStyle.danger)
            self.outer = outer
        async def callback(self, inter: discord.Interaction):
            await self.outer._wipe_all_data()
            await inter.response.edit_message(content="âœ… Data wiped.", embed=None, view=None)

    class ResetConfirmView(discord.ui.View):
        def __init__(self, outer: "QuotaCog"):
            super().__init__(timeout=60)
            self.add_item(QuotaCog.ResetConfirmBtn(outer))

    # ---------------- Init ----------------
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._table_ready = asyncio.Event()
        os.makedirs(QUOTA_IMAGE_DIR, exist_ok=True)
        asyncio.create_task(self._prepare_db())
        self.lb_refresher.start()
        self.weekly_cleanup.start()

    async def _prepare_db(self):
        while self.db.pool is None:
            await asyncio.sleep(1)
        async with self.db.pool.acquire() as conn:
            await conn.execute(CREATE_SQL)
        self._table_ready.set()
        await self.refresh_everything()

    # ---------------- Small utilities ----------------
    @staticmethod
    def _bar(have: int, need: int, length: int = PROGRESS_BAR_LEN) -> str:
        pct = 0 if need == 0 else min(1, have / need)
        filled = round(pct * length)
        return f"{'â–°'*filled}{'â–±'*(length-filled)}  {pct*100:5.1f}%"

    @staticmethod
    def _box(n: int, width: int = 9) -> str:
        return f"{n:,}".ljust(width)

    @staticmethod
    def _next_reset(now: datetime) -> datetime:
        days = (RESET_WEEKDAY - now.weekday()) % 7
        reset = datetime(year=now.year, month=now.month, day=now.day,
                         hour=RESET_HOUR_UTC, tzinfo=timezone.utc) + timedelta(days=days)
        if reset <= now:
            reset += timedelta(days=7)
        return reset

    def _countdown(self) -> str:
        delta = self._next_reset(datetime.now(timezone.utc)) - datetime.now(timezone.utc)
        d, rem = divmod(int(delta.total_seconds()), 86400)
        h, rem = divmod(rem, 3600)
        m = rem // 60
        return f"{d}d {h}h {m}m"

    async def _save_images(self, atts: List[discord.Attachment], res: str, uid: int):
        for att in atts[:10]:
            if att.content_type and att.content_type.startswith("image/"):
                ext = os.path.splitext(att.filename)[1] or ".png"
                name = f"{int(time.time())}_{uid}_{res}_{uuid.uuid4().hex[:8]}{ext}"
                await att.save(os.path.join(QUOTA_IMAGE_DIR, name))

    async def _notify_staff(self, member: discord.Member, pairs: Dict[str, int],
                            images: List[discord.Attachment], ids: List[int]):
        ch = self.bot.get_channel(QUOTA_REVIEW_CH_ID)
        if not ch:
            return
        desc = "\n".join(f"â€¢ **{r}** `{a}`" for r, a in pairs.items())
        embed = discord.Embed(title="New Submission", description=desc, colour=discord.Color.green())
        await ch.send(content=f"Submission from {member.mention}",
                      embed=embed,
                      file=await images[0].to_file(),
                      view=QuotaCog.SingleAcceptView(self, ids),
                      allowed_mentions=discord.AllowedMentions(users=True))

    # ---------------- Top-level refresh wrappers ----------------
    async def refresh_everything(self):
        await self.refresh_all_tasks()
        await self.refresh_weekly_leaderboard()

    # ---------------- TASK EMBEDS ----------------
    async def refresh_all_tasks(self):
        await self._table_ready.wait()
        async with self.db.pool.acquire() as conn:
            rows = await conn.fetch("SELECT * FROM quota_tasks WHERE completed=FALSE")
            for t in rows:
                await self._refresh_task_embed(conn, t)

    async def _refresh_task_embed(self, conn, task):
        task_id, start = task["id"], task["start_sub"]
        needs = await conn.fetch("SELECT resource,required FROM quota_task_needs WHERE task_id=$1", task_id)
        prog = {n["resource"]: 0 for n in needs}
        for n in needs:
            prog[n["resource"]] = await conn.fetchval(
                "SELECT COALESCE(SUM(amount),0) FROM quota_submissions "
                "WHERE reviewed=TRUE AND resource=$1 AND id>$2",
                n["resource"], start) or 0
        completed = all(prog[n["resource"]] >= n["required"] for n in needs)

        lb = await conn.fetch(
            "SELECT user_id,SUM(amount) total FROM quota_submissions "
            "WHERE reviewed=TRUE AND id>$1 GROUP BY user_id "
            "ORDER BY total DESC LIMIT $2",
            start, TASK_TOP_LIMIT)

        embed = discord.Embed(
            title="âœ… COMPLETED" if completed else f"Task: {task['name']}",
            colour=discord.Color.green() if completed else discord.Color.blue())

        need_sum = sum(n["required"] for n in needs)
        have_sum = sum(min(prog[n["resource"]], n["required"]) for n in needs)
        embed.description = f"**Overall Progress**\n`{have_sum:,}` / `{need_sum:,}`\n{self._bar(have_sum, need_sum)}"
        embed.clear_fields()
        for n in needs:
            r = n["resource"]
            need = n["required"]
            have = min(prog[r], need)
            embed.add_field(name=r.title(),
                            value=f"`{have:,}` / `{need:,}`\n{self._bar(have, need)}",
                            inline=False)

        if lb:
            embed.add_field(
                name="Top 5",
                value="\n".join(
                    f"**{i+1}.** <@{r['user_id']}> `{r['total']:,}`"
                    for i, r in enumerate(lb, 1)),
                inline=False)

        ch = self.bot.get_channel(PUBLIC_QUOTA_CH_ID)
        if ch:
            try:
                m = await ch.fetch_message(task["message_id"])
                await m.edit(embed=embed)
            except (discord.NotFound, discord.HTTPException):
                pass
        if completed and not task["completed"]:
            await conn.execute("UPDATE quota_tasks SET completed=TRUE WHERE id=$1", task_id)

    # ---------------- WEEKLY LEADERBOARD ----------------
    async def refresh_weekly_leaderboard(self):
        try:
            await self._table_ready.wait()
            ch = self.bot.get_channel(PUBLIC_QUOTA_CH_ID)
            if not isinstance(ch, discord.TextChannel):
                return

            async with self.db.pool.acquire() as conn:
                row = await conn.fetchrow("SELECT message_id FROM quota_weekly_lb WHERE id=1")
                msg: Optional[discord.Message] = None
                if row:
                    try:
                        msg = await ch.fetch_message(row["message_id"])
                    except discord.NotFound:
                        msg = None

                quotas = {r["resource"]: r["weekly"] for r in await conn.fetch("SELECT * FROM default_quotas")}
                totals = {r["resource"]: r["total"] for r in await conn.fetch(RESOURCE_TOT_SQL)}

                embed = discord.Embed(
                    title="Weekly Leaderboard",
                    description=f"**Weekly reset:** Thu 15:00 BST / 14:00 UTC\nResets in **{self._countdown()}**",
                    colour=discord.Color.purple())

                overall_have = sum(totals.get(r, 0) for r in RESOURCES)
                overall_need = sum(quotas.get(r, 0) for r in RESOURCES) or 1
                embed.add_field(name="Overall",
                                value=f"`{overall_have:,}` / `{overall_need:,}`\n"
                                      f"{self._bar(overall_have, overall_need)}",
                                inline=False)

                for r in RESOURCES:
                    have = totals.get(r, 0)
                    need = quotas.get(r, max(have, 1))
                    embed.add_field(name=r.title(),
                                    value=f"`{have:,}` / `{need:,}`\n{self._bar(have, need)}",
                                    inline=False)

                users = await conn.fetch(GLOBAL_LB_SQL, GLOBAL_LB_SIZE)
                if users:
                    header = "#  User (Top 15)             Total"
                    guild = ch.guild
                    rows = []
                    for i, u in enumerate(users, 1):
                        disp = (guild.get_member(u["user_id"]).display_name
                                if guild and guild.get_member(u["user_id"])
                                else f"ID:{u['user_id']}")
                        rows.append(f"{str(i).ljust(2)} {disp[:25].ljust(25)} {self._box(u['total'])}")
                    embed.add_field(name="Top Contributors",
                                    value="```text\n" + "\n".join([header, *rows]) + "\n```",
                                    inline=False)
                else:
                    embed.add_field(name="Top Contributors",
                                    value="No reviewed submissions yet.", inline=False)

                try:
                    if msg:
                        await msg.edit(embed=embed)
                    else:
                        new_msg = await ch.send(embed=embed)
                        await conn.execute(
                            "INSERT INTO quota_weekly_lb (id,message_id) VALUES (1,$1) "
                            "ON CONFLICT(id) DO UPDATE SET message_id=$1",
                            new_msg.id)
                except discord.HTTPException as ex:
                    log.warning("Failed to edit/send weekly leaderboard: %s", ex)
        except Exception:
            log.exception("refresh_weekly_leaderboard failed")

    # ---------------- BACKGROUND TASKS ----------------
    @tasks.loop(seconds=LB_REFRESH_SECONDS)
    async def lb_refresher(self):
        try:
            await self.refresh_weekly_leaderboard()
        except Exception:
            log.exception("lb_refresher iteration failed")

    @tasks.loop(hours=1)
    async def weekly_cleanup(self):
        await self._table_ready.wait()
        now = datetime.now(timezone.utc)
        if now.weekday() == RESET_WEEKDAY and now.hour == RESET_HOUR_UTC:
            async with self.db.pool.acquire() as conn:
                row = await conn.fetchrow("SELECT message_id FROM quota_weekly_lb WHERE id=1")
                ch = self.bot.get_channel(PUBLIC_QUOTA_CH_ID)
                if row and ch:
                    try:
                        m = await ch.fetch_message(row["message_id"])
                        await m.delete()
                    except (discord.NotFound, discord.HTTPException):
                        pass
                await conn.execute("DELETE FROM quota_weekly_lb WHERE id=1")
        await self.db.pool.execute(PURGE_OLD_SQL)

    async def cog_unload(self):
        self.lb_refresher.cancel()
        self.weekly_cleanup.cancel()

    # ---------------- SLASH COMMANDS ----------------
    quota = app_commands.Group(name="quota", description="Quota commands")

    # ------- submit -------
    @quota.command(name="submit", description="Submit up to 10 screenshots")
    @app_commands.choices(resource=[app_commands.Choice(name=r, value=r) for r in RESOURCES])
    @app_commands.describe(
        image1="Screenshot 1", image2="Screenshot 2", image3="Screenshot 3", image4="Screenshot 4",
        image5="Screenshot 5", image6="Screenshot 6", image7="Screenshot 7", image8="Screenshot 8",
        image9="Screenshot 9", image10="Screenshot 10"
    )
    async def submit(
        self, inter: discord.Interaction,
        resource: app_commands.Choice[str],
        amount: app_commands.Range[int, 1, 1_000_000],
        image1: Optional[discord.Attachment] = None, image2: Optional[discord.Attachment] = None,
        image3: Optional[discord.Attachment] = None, image4: Optional[discord.Attachment] = None,
        image5: Optional[discord.Attachment] = None, image6: Optional[discord.Attachment] = None,
        image7: Optional[discord.Attachment] = None, image8: Optional[discord.Attachment] = None,
        image9: Optional[discord.Attachment] = None, image10: Optional[discord.Attachment] = None
    ):
        await self._table_ready.wait()
        imgs = [i for i in (image1, image2, image3, image4, image5,
                            image6, image7, image8, image9, image10) if i][:10]
        if not imgs:
            return await inter.response.send_message("Attach at least one image.", ephemeral=True)
        await self._save_images(imgs, resource.value, inter.user.id)
        ids: List[int] = []
        async with self.db.pool.acquire() as conn:
            for img in imgs:
                rec_id = await conn.fetchval(
                    "INSERT INTO quota_submissions (user_id,resource,amount,image_url) "
                    "VALUES ($1,$2,$3,$4) RETURNING id",
                    inter.user.id, resource.value, amount, img.url)
                ids.append(rec_id)
        await inter.response.send_message("Submission received.", ephemeral=True)
        await self._notify_staff(inter.user, {resource.value: amount}, imgs, ids)

    # ------- leaderboard -------
    @quota.command(name="leaderboard", description="Per-resource weekly leaderboard")
    @app_commands.choices(resource=[app_commands.Choice(name=r, value=r) for r in RESOURCES])
    async def leaderboard(self, inter: discord.Interaction, resource: app_commands.Choice[str]):
        await self._table_ready.wait()
        rows = await self.db.pool.fetch(
            "SELECT user_id,SUM(amount) total FROM quota_submissions "
            "WHERE reviewed=TRUE AND resource=$1 AND week_ts>=CURRENT_DATE - INTERVAL '6 days' "
            "GROUP BY user_id ORDER BY total DESC LIMIT 15",
            resource.value)
        if not rows:
            return await inter.response.send_message("No data yet.", ephemeral=True)
        body = "\n".join(f"**{i+1}.** <@{r['user_id']}> `{r['total']:,}`" for i, r in enumerate(rows, 1))
        await inter.response.send_message(body, ephemeral=True)

    leader_perm = role_check(GROUP_LEADER_ROLE_ID, PLAYER_MGMT_ROLE_ID, ADMIN_ROLE_ID)
    admin_perm  = role_check(ADMIN_ROLE_ID)

    # ------- task -------
    @quota.command(name="task", description="Create a multi-resource task")
    @leader_perm
    @app_commands.describe(name="Task name", details="Pairs e.g. stone 20000 sulfur 5k")
    async def task_create(self, inter: discord.Interaction, name: str, details: str):
        await self._table_ready.wait()
        toks = re.sub(r"[,;:]", " ", details.lower()).split()
        pairs: Dict[str, int] = {}
        cur: Optional[str] = None
        for tok in toks:
            if tok in RESOURCES:
                cur = tok
            elif tok.replace(",", "").replace("k", "").isdigit() and cur:
                amt = int(float(tok.replace(",", "").replace("k", "")) *
                          (1000 if "k" in tok else 1))
                pairs[cur] = pairs.get(cur, 0) + amt
                cur = None
        if not pairs:
            return await inter.response.send_message("No valid pairs.", ephemeral=True)

        embed = discord.Embed(title=f"Task: {name}", colour=discord.Color.blue())
        for res, need in pairs.items():
            embed.add_field(
                name=res.title(),
                value=f"`0` / `{need:,}`\n{self._bar(0, need)}",
                inline=False)

        ch = self.bot.get_channel(PUBLIC_QUOTA_CH_ID)
        if not ch:
            return await inter.response.send_message(
                "Public channel missing.", ephemeral=True)
        msg = await ch.send(embed=embed)

        async with self.db.pool.acquire() as conn:
            start_id = await conn.fetchval("SELECT COALESCE(MAX(id),0) FROM quota_submissions")
            task_id = await conn.fetchval(
                "INSERT INTO quota_tasks (name,start_sub,message_id) "
                "VALUES ($1,$2,$3) RETURNING id",
                name, start_id, msg.id)
            for res, need in pairs.items():
                await conn.execute(
                    "INSERT INTO quota_task_needs (task_id,resource,required) "
                    "VALUES ($1,$2,$3)",
                    task_id, res, need)
        await inter.response.send_message("Task created.", ephemeral=True)
        await self.refresh_everything()

    # ------- review -------
    @quota.command(name="review", description="Review pending submissions")
    @leader_perm
    async def review(self, inter: discord.Interaction):
        await self._table_ready.wait()
        rows = await self.db.pool.fetch(PENDING_GROUP_SQL)
        if not rows:
            return await inter.response.send_message("Nothing pending.", ephemeral=True)
        embed = discord.Embed(title="Pending submissions", colour=discord.Color.orange())
        for r in rows:
            body = "\n".join(f"â€¢ **{k}** `{v}`" for k, v in r["res_totals"].items())
            embed.add_field(name=f"<@{r['user_id']}>", value=body, inline=False)
        await inter.response.send_message(
            embed=embed,
            view=QuotaCog.ReviewUsersView(rows, self),
            ephemeral=True)

    # ------- setdefault -------
    @quota.command(name="setdefault", description="Set global weekly quota")
    @leader_perm
    @app_commands.choices(
        resource=[app_commands.Choice(name=r, value=r) for r in RESOURCES])
    async def set_default(self, inter: discord.Interaction,
                          resource: app_commands.Choice[str],
                          amount: app_commands.Range[int, 1, 1_000_000]):
        await self._table_ready.wait()
        await self.db.pool.execute(
            SET_DEFAULT_SQL, resource.value, amount)
        await inter.response.send_message("Global quota set.", ephemeral=True)
        await self.refresh_weekly_leaderboard()

    # ------- set -------
    @quota.command(name="set", description="Set member weekly quota")
    @leader_perm
    @app_commands.choices(
        resource=[app_commands.Choice(name=r, value=r) for r in RESOURCES])
    async def set_user_quota(self, inter: discord.Interaction,
                             member: discord.Member,
                             resource: app_commands.Choice[str],
                             amount: app_commands.Range[int, 1, 1_000_000]):
        await self._table_ready.wait()
        await self.db.pool.execute(
            SET_USER_SQL, member.id, resource.value, amount)
        await inter.response.send_message("Member quota set.", ephemeral=True)

    # ------- reset -------
    @quota.command(name="reset", description="Wipe ALL quota data")
    @admin_perm
    async def reset(self, inter: discord.Interaction):
        embed = discord.Embed(
            title="âš ï¸ Wipe all quota data?",
            description="Deletes every submission, task and leaderboard message.",
            colour=discord.Color.red())
        await inter.response.send_message(
            embed=embed,
            view=QuotaCog.ResetConfirmView(self),
            ephemeral=True)

    async def _wipe_all_data(self):
        async with self.db.pool.acquire() as conn:
            ch = self.bot.get_channel(PUBLIC_QUOTA_CH_ID)
            for r in await conn.fetch("SELECT message_id FROM quota_tasks"):
                if ch:
                    try:
                        m = await ch.fetch_message(r["message_id"])
                        await m.delete()
                    except (discord.NotFound, discord.HTTPException):
                        pass
            lb_row = await conn.fetchrow(
                "SELECT message_id FROM quota_weekly_lb WHERE id=1")
            if lb_row and ch:
                try:
                    m = await ch.fetch_message(lb_row["message_id"])
                    await m.delete()
                except (discord.NotFound, discord.HTTPException):
                    pass
            await conn.execute(
                "TRUNCATE quota_submissions, quota_tasks, quota_task_needs "
                "RESTART IDENTITY")
            await conn.execute("DELETE FROM quota_weekly_lb WHERE id=1")
        await self.refresh_everything()

    # ---------------- DM Listener ----------------
    @commands.Cog.listener()
    async def on_message(self, msg: discord.Message):
        if msg.guild or msg.author.bot or not msg.attachments:
            return
        parts = re.sub(r"[,;:]", " ", msg.content.lower()).split()
        pairs: Dict[str, int] = defaultdict(int)
        cur: Optional[str] = None
        for tok in parts:
            if tok in RESOURCES:
                cur = tok
            elif tok.replace(",", "").isdigit() and cur:
                pairs[cur] += int(tok.replace(",", ""))
                cur = None
        if not pairs:
            return await msg.channel.send(
                "Provide resource amount pairs like `stone 6000`.")
        imgs = [
            a for a in msg.attachments
            if a.content_type and a.content_type.startswith("image/")
        ][:10]
        if not imgs:
            return await msg.channel.send("Attach images.")
        guild = next(
            (g for g in self.bot.guilds if g.get_member(msg.author.id)), None)
        if not guild:
            return
        member = guild.get_member(msg.author.id)
        await self._save_images(imgs, "multi", member.id)
        ids: List[int] = []
        await self._table_ready.wait()
        async with self.db.pool.acquire() as conn:
            for img in imgs:
                for res, amt in pairs.items():
                    rec_id = await conn.fetchval(
                        "INSERT INTO quota_submissions "
                        "(user_id,resource,amount,image_url) "
                        "VALUES ($1,$2,$3,$4) RETURNING id",
                        member.id, res, amt, img.url)
                    ids.append(rec_id)
        await msg.channel.send("Submission received â€“ thank you!")
        await self._notify_staff(member, pairs, imgs, ids)

# ---------------- SETUP ----------------
async def setup(bot, db):
    await bot.add_cog(QuotaCog(bot, db))


FILE: cogs\recruit_reminder.py
----------------------------------------
# cogs/recruit_reminder.py
# Production-ready â€¢ discord.py â‰¥ 2.3 â€¢ 2024-10-05
#
#  â€¢ A message in the #recruit channel lets recruitment staff press âœ… Accept
#    to "take the shift" and locks further posts for 6 h.
#  â€¢ The button is PERSISTENT â€“ survives bot restarts.
#  â€¢ Table `recruit_reminder` is created automatically.
#  â€¢ Fix: view is re-attached only after the DB table is ready, so the button
#    always works after a reboot.

from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timezone
from typing import Optional

import asyncpg
import discord
from discord import app_commands
from discord.ext import commands, tasks

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Server-specific constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RECRUIT_CHANNEL_ID  = 1421856820460388383          # channel where the reminder lives
RECRUITMENT_ROLE_ID = 1410659214959054988          # role allowed to accept

SHIFT_SECONDS   = 6 * 60 * 60                      # 6-hour cooldown
UPDATE_INTERVAL = 15                               # seconds between checks

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SQL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE_SQL = """
CREATE TABLE IF NOT EXISTS recruit_reminder (
    id         BOOLEAN PRIMARY KEY DEFAULT TRUE,
    message_id BIGINT,
    claimed_by BIGINT,
    end_ts     BIGINT
);
INSERT INTO recruit_reminder (id) VALUES (TRUE)
ON CONFLICT (id) DO NOTHING;
"""

GET_SQL = "SELECT message_id, claimed_by, end_ts FROM recruit_reminder LIMIT 1"

SET_SQL = """
UPDATE recruit_reminder
   SET message_id = $1, claimed_by = $2, end_ts = $3
 WHERE id = TRUE;
"""


class RecruitReminder(commands.Cog):
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INITIALISATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db

        # will be set after the table exists & pool ready
        self._table_ready = asyncio.Event()

        # Start the update task only after table is ready
        self.update_task: Optional[asyncio.Task] = None
        asyncio.create_task(self._prepare_and_start())

    async def _prepare_and_start(self):
        """Prepare table and start update task."""
        await self._prepare_table()
        self.update_message.start()
        self.update_task = self.update_message.get_task()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DB helpers â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _prepare_table(self):
        """Wait for `db.pool`, then create the table once."""
        while self.db.pool is None:
            await asyncio.sleep(1)

        async with self.db.pool.acquire() as conn:
            await conn.execute(CREATE_SQL)
        self._table_ready.set()
        log.debug("[recruit] table ready")

    async def _get_state(self) -> dict[str, Optional[int]]:
        """Return dict with keys: message_id, claimed_by, end_ts (can be None)."""
        if self.db.pool is None:
            return {"message_id": None, "claimed_by": None, "end_ts": None}

        await self._table_ready.wait()
        
        async with self.db.pool.acquire() as conn:
            try:
                row = await conn.fetchrow(GET_SQL)
            except asyncpg.UndefinedTableError:
                await conn.execute(CREATE_SQL)
                row = None
        return dict(row) if row else {"message_id": None, "claimed_by": None, "end_ts": None}

    async def _set_state(self, *, message_id, claimed_by, end_ts):
        if self.db.pool is None:
            return
        await self._table_ready.wait()
        
        async with self.db.pool.acquire() as conn:
            try:
                await conn.execute(SET_SQL, message_id, claimed_by, end_ts)
            except asyncpg.UndefinedTableError:
                await conn.execute(CREATE_SQL)
                await conn.execute(SET_SQL, message_id, claimed_by, end_ts)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Persistent VIEW â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class AcceptView(discord.ui.View):
        def __init__(self, outer: "RecruitReminder"):
            super().__init__(timeout=None)  # keep alive forever
            self.outer = outer

        @discord.ui.button(
            label="Accept",
            emoji="âœ…",
            style=discord.ButtonStyle.success,
            custom_id="recruit_accept"
        )
        async def accept(self, inter: discord.Interaction, _button: discord.ui.Button):
            guild = inter.guild
            role  = guild.get_role(RECRUITMENT_ROLE_ID) if guild else None
            if not (
                inter.user.guild_permissions.administrator
                or (role and role in inter.user.roles)
            ):
                return await inter.response.send_message(
                    "You're not recruitment staff.", ephemeral=True
                )

            await inter.response.defer(ephemeral=True)

            try:
                end_ts = int(datetime.now(timezone.utc).timestamp()) + SHIFT_SECONDS
                await self.outer._set_state(
                    message_id=inter.message.id,
                    claimed_by=inter.user.id,
                    end_ts=end_ts,
                )

                for child in self.children:
                    child.disabled = True

                await inter.message.edit(
                    content=(
                        f"âœ… {inter.user.mention} has sent out recruitment â€” "
                        f"next recruitment posts can be sent in **6 hours**."
                    ),
                    view=self,
                )
                await inter.followup.send("Shift accepted â€” thank you!", ephemeral=True)
            except Exception as exc:                         # noqa: BLE001
                log.exception("Recruit Accept callback failed: %s", exc)
                try:
                    await inter.followup.send(
                        "Something went wrong â€“ try again later.", ephemeral=True
                    )
                except (discord.HTTPException, discord.NotFound):
                    pass

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Periodic updater â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    @tasks.loop(seconds=UPDATE_INTERVAL)
    async def update_message(self):
        await self._table_ready.wait()

        state   = await self._get_state()
        channel = self.bot.get_channel(RECRUIT_CHANNEL_ID)
        if not isinstance(channel, discord.TextChannel):
            return

        now_ts = int(datetime.now(timezone.utc).timestamp())

        # ---------- no message stored â€“ create ----------
        if state["message_id"] is None:
            try:
                msg = await channel.send(
                    f"<@&{RECRUITMENT_ROLE_ID}> "
                    "Click **Accept** below if you're available to send out recruitment posts!",
                    view=self.AcceptView(self),
                )
                await self._set_state(message_id=msg.id, claimed_by=None, end_ts=None)
            except discord.Forbidden:
                log.error("Bot lacks permissions to send message in recruit channel")
            except discord.HTTPException as e:
                log.error("Failed to send recruit message: %s", e)
            return

        # ---------- fetch stored message ----------
        try:
            msg = await channel.fetch_message(state["message_id"])
        except discord.NotFound:                               # message deleted
            await self._set_state(message_id=None, claimed_by=None, end_ts=None)
            return
        except discord.Forbidden:
            log.error("Bot lacks permissions to fetch message in recruit channel")
            return
        except discord.HTTPException as e:
            log.error("Failed to fetch recruit message: %s", e)
            return

        # ---------- update content ----------
        if state["end_ts"]:                                    # shift active
            if now_ts >= state["end_ts"]:                      # shift expired
                try:
                    await msg.edit(
                        content=(
                            f"<@&{RECRUITMENT_ROLE_ID}> "
                            "Click **Accept** below if you're available to send out recruitment posts!"
                        ),
                        view=self.AcceptView(self),
                    )
                    await self._set_state(message_id=msg.id, claimed_by=None, end_ts=None)
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to update expired shift message: %s", e)
            else:                                              # still locked
                remaining = state["end_ts"] - now_ts
                hrs, rem  = divmod(remaining, 3600)
                mins      = rem // 60
                try:
                    await msg.edit(
                        content=(
                            f"âœ… <@{state['claimed_by']}> has sent out recruitment â€” "
                            f"next recruitment posts can be sent in **{hrs} h {mins:02} m**."
                        )
                    )
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to update locked shift message: %s", e)
        else:                                                  # idle
            if not msg.components:
                try:
                    await msg.edit(view=self.AcceptView(self))
                except (discord.Forbidden, discord.NotFound, discord.HTTPException) as e:
                    log.error("Failed to add view to idle message: %s", e)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Persist view on reboot â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    @commands.Cog.listener()
    async def on_ready(self):
        await self._table_ready.wait()
        state = await self._get_state()
        if state["message_id"]:
            try:
                # re-attach the persistent view so the button works
                self.bot.add_view(
                    self.AcceptView(self), message_id=state["message_id"]
                )
                log.info("[recruit] View reattached to message %s", state["message_id"])
            except Exception as e:                             # noqa: BLE001
                log.warning("Failed to add persistent view: %s", e)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Admin command â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    @app_commands.command(name="recruitreset",
                          description="Force-reset the recruitment reminder (admin only)")
    @app_commands.checks.has_permissions(administrator=True)
    async def recruit_reset(self, inter: discord.Interaction):
        await self._set_state(message_id=None, claimed_by=None, end_ts=None)
        await inter.response.send_message(
            "Recruitment reminder will refresh within 15 seconds.", ephemeral=True
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• teardown â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    def cog_unload(self):
        if self.update_message.is_running():
            self.update_message.cancel()
        log.info("RecruitReminder unloaded")


async def setup(bot, db):
    await bot.add_cog(RecruitReminder(bot, db))


FILE: cogs\staff_applications.py
----------------------------------------
# cogs/staff_applications.py
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   Staff application system (separate from member registration)
#   Drop-in for CTFO bot: /staffapply, review, and staff role granting.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Optional

import discord
from discord import app_commands
from discord.ext import commands

log = logging.getLogger("cog.staff_applications")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG (copy from your main) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GUILD_ID                = 1377035207777194005
STAFF_APPLICATION_CH_ID = 1410649548837093436
ADMIN_ROLE_ID           = 1377103244089622719

STAFF_ROLE_IDS: dict[str, int] = {
    "Group Leader":      1377077466513932338,
    "Player Management": 1377084533706588201,
    "Recruitment":       1410659214959054988,
}

# tuple = (label, style, required)   LABEL **â‰¤ 45 chars**
STAFF_QUESTION_SETS: dict[str, list[tuple[str, discord.TextStyle, bool]]] = {
    "Group Leader": [
        ("What group are you looking to lead?",          discord.TextStyle.short,     True),
        ("Why do you want to be a group leader?",        discord.TextStyle.paragraph, True),
        ("What makes you a good fit for this role?",     discord.TextStyle.paragraph, True),
        ("How many Rust hours do you have?",             discord.TextStyle.short,     True),
        ("How many hours a week are you available?",     discord.TextStyle.short,     True),
        ("When are you most active?",                    discord.TextStyle.short,     True),
        ("What time-zone are you in?",                   discord.TextStyle.short,     True),
        ("How would you rate your in-game skills?",      discord.TextStyle.short,     True),
        ("How old are you?",                             discord.TextStyle.short,     True),
    ],

    "Player Management": [
        ("Why do you want to join player management?",        discord.TextStyle.paragraph, True),
        ("What makes you good for this role?",                discord.TextStyle.paragraph, True),
        ("Describe your leadership skills.",                  discord.TextStyle.paragraph, True),
        ("How would you handle breaking of rules?",           discord.TextStyle.paragraph, True),
        ("How would you handle an unpopular decision?",       discord.TextStyle.paragraph, True),
        ("How would you handle an irritating player?",        discord.TextStyle.paragraph, True),
        ("What would you do if you felt annoyed?",            discord.TextStyle.paragraph, True),
        ("What time-zone are you in?",                        discord.TextStyle.short,     True),
        ("How many hours a week are you active?",             discord.TextStyle.short,     True),
        ("When are you most active?",                         discord.TextStyle.short,     True),
        ("How old are you?",                                  discord.TextStyle.short,     True),
    ],

    "Recruitment": [
        ("Why do you want this role?",                        discord.TextStyle.paragraph, True),
        ("What time-zone are you in?",                        discord.TextStyle.short,     True),
        ("When are you most active?",                         discord.TextStyle.short,     True),
        ("Are you banned from any Rust discords?",            discord.TextStyle.short,     True),
        ("How old are you?",                                  discord.TextStyle.short,     True),
        ("If a rejected user messages you, what do?",         discord.TextStyle.paragraph, True),   # 41 chars
    ],
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def safe_fetch(guild: discord.Guild, uid: int) -> Optional[discord.Member]:
    try:
        return await guild.fetch_member(uid)
    except (discord.NotFound, discord.HTTPException):
        return None
    except discord.Forbidden:
        log.debug("Could not fetch member %s â€“ forbidden", uid)
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class StaffApplicationsCog(commands.Cog):
    """Handles staff application workflow (/staffapply and review)."""

    _ready_once: bool

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._ready_once = False

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Bot ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_ready(self):
        if self._ready_once:
            return
        self._ready_once = True
        await self._restore_action_views()
        log.info("[staff_applications] persistent ActionViews re-attached")

    async def _restore_action_views(self):
        """Re-attach persistent ActionViews after a restart."""
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        rows = await self.db.get_pending_staff_apps()  # [{user_id, role, message_id}]
        for row in rows:
            # Avoid adding the same view twice if on_ready runs again
            if any(
                isinstance(v, StaffApplicationActionView)
                and getattr(v, "message_id", None) == row["message_id"]
                for v in self.bot.persistent_views
            ):
                continue

            self.bot.add_view(
                StaffApplicationActionView(guild, row["user_id"], row["role"], self.db),
                message_id=row["message_id"],
            )

    # â•â•â•â•â•â•â•â•â• main slash command â•â•â•â•â•â•â•â•â•â•â•â•
    @app_commands.command(name="staffapply", description="Apply for a staff position")
    async def staffapply(self, i: discord.Interaction):
        # Prevent duplicate open applications
        # FIXED: Get all pending apps and filter manually
        pending_apps = await self.db.get_pending_staff_apps()
        user_has_pending = any(app["user_id"] == i.user.id for app in pending_apps)
        
        if user_has_pending:
            return await i.response.send_message(
                "You already have a pending staff application.", ephemeral=True
            )

        await i.response.send_message(
            "Select the staff role you'd like to apply for:",
            view=StaffRoleSelectView(self.db),
            ephemeral=True,
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STAFF APPLICATION UI â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class StaffRoleSelectView(discord.ui.View):
    def __init__(self, db):
        super().__init__(timeout=300)
        self.db = db
        self.add_item(StaffRoleSelect(self.db))


class StaffRoleSelect(discord.ui.Select):
    def __init__(self, db):
        super().__init__(
            placeholder="Select the staff role you'd like to apply forâ€¦",
            options=[discord.SelectOption(label=r, value=r) for r in STAFF_QUESTION_SETS],
        )
        self.db = db

    async def callback(self, i: discord.Interaction):
        await i.response.send_modal(
            StaffApplicationModal(self.values[0], 0, [], self.db)
        )


class ContinueView(discord.ui.View):
    """Ephemeral view that shows a single **Continue** button."""

    def __init__(
        self,
        role: str,
        next_idx: int,
        collected: list[tuple[str, str]],
        db,
    ):
        super().__init__(timeout=300)
        self.role, self.next_idx, self.collected, self.db = role, next_idx, collected, db
        self.message: Optional[discord.Message] = None  # set after sending

    @discord.ui.button(label="Continue", style=discord.ButtonStyle.primary, emoji="â¡ï¸")
    async def continue_btn(self, i: discord.Interaction, _):
        await i.response.send_modal(
            StaffApplicationModal(
                self.role, self.next_idx, list(self.collected), self.db
            )
        )
        self.disable_all_items()
        await i.message.edit(view=self)
        self.stop()  # prevent double interaction

    async def on_timeout(self):
        if self.is_finished():
            return
        self.disable_all_items()
        try:
            if self.message:
                await self.message.edit(view=self)
        except Exception:
            pass
        self.stop()


class StaffApplicationModal(discord.ui.Modal):
    """One page (up to 5 questions) of the staff application."""

    def __init__(
        self, role: str, idx: int, collected: list[tuple[str, str]], db
    ):
        super().__init__(title=f"{role} Application")
        self.role, self.idx, self.collected, self.db = role, idx, collected, db

        qset = STAFF_QUESTION_SETS[role][idx : idx + 5]
        for q, style, req in qset:
            assert (
                len(q) <= 45
            ), f"Modal label >45 chars (Discord limit): {q!r}"
            self.add_item(
                discord.ui.TextInput(
                    label=q,
                    style=style,
                    required=req,
                    max_length=100 if style is discord.TextStyle.short else 1024,
                )
            )

    async def on_submit(self, i: discord.Interaction):
        # Cache answers from this page
        for comp in self.children:  # type: ignore
            label_txt = getattr(comp, "label", None) or comp._underlying.label
            self.collected.append((label_txt, comp.value))  # type: ignore

        next_idx = self.idx + 5
        if next_idx < len(STAFF_QUESTION_SETS[self.role]):
            view = ContinueView(self.role, next_idx, list(self.collected), self.db)
            await i.response.send_message(
                "Page saved â€” click **Continue** to answer the next set:",
                view=view,
                ephemeral=True,
            )
            # Store the message on the view for timeout edits
            view.message = await i.original_response()
            return

        # All questions answered: build embed & post to review channel
        review_ch = i.guild.get_channel(STAFF_APPLICATION_CH_ID)
        if not review_ch:
            return await i.response.send_message(
                "Review channel missing.", ephemeral=True
            )

        embed = (
            discord.Embed(
                title=f"{self.role} Application",
                colour=discord.Color.orange(),
                timestamp=datetime.now(timezone.utc),
            )
            .set_author(name=str(i.user), icon_url=i.user.display_avatar.url)
            .set_footer(text=f"User ID: {i.user.id}")
        )

        for idx, (q, a) in enumerate(self.collected, 1):
            # Truncate to embed field limit (1 024)
            val = a or "N/A"
            if len(val) > 1024:
                val = f"{val[:1021]}â€¦"
            embed.add_field(name=f"{idx}. {q}", value=val, inline=False)

        view = StaffApplicationActionView(i.guild, i.user.id, self.role, self.db)
        msg = await review_ch.send(f"<@&{ADMIN_ROLE_ID}>", embed=embed, view=view)

        await self.db.add_staff_app(i.user.id, self.role, msg.id)
        await i.response.send_message(
            "âœ… Your staff application was submitted.", ephemeral=True
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â• STAFF APPLICATION REVIEW (ActionView) â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class StaffApplicationActionView(discord.ui.View):
    """Persistent view with Accept / Deny buttons for admins."""

    def __init__(self, guild: discord.Guild, applicant_id: int, role: str, db):
        super().__init__(timeout=None)
        self.guild: discord.Guild = guild
        self.applicant_id: int = applicant_id
        self.role: str = role
        self.db = db
        # keep for duplicate-view guard
        self.message_id: Optional[int] = None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _authorised(self, member: discord.Member) -> bool:
        return member.guild_permissions.administrator or any(
            r.id in STAFF_ROLE_IDS.values() for r in member.roles
        )

    async def _notify(self, txt: str):
        user = await safe_fetch(self.guild, self.applicant_id)
        if user:
            try:
                await user.send(txt)
            except discord.Forbidden:
                log.debug("Could not DM applicant %s", self.applicant_id)

    async def _finish(self, i: discord.Interaction, colour: discord.Colour):
        emb = i.message.embeds[0]
        emb.colour = colour
        self.disable_all_items()
        await i.message.edit(embed=emb, view=self)
        self.stop()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @discord.ui.button(
        label="Accept",
        style=discord.ButtonStyle.success,
        emoji="âœ…",
        custom_id="staff_app_accept",
    )
    async def accept(self, i: discord.Interaction, _):
        # Acknowledge interaction immediately
        await i.response.defer(ephemeral=True)
        
        if not await self._authorised(i.user):
            return await i.followup.send("Not authorised.", ephemeral=True)

        applicant = await safe_fetch(self.guild, self.applicant_id)
        if not applicant:
            return await i.followup.send("Applicant left.", ephemeral=True)

        role_obj = self.guild.get_role(STAFF_ROLE_IDS[self.role])
        if not role_obj:
            return await i.followup.send("Role missing.", ephemeral=True)

        try:
            await applicant.add_roles(role_obj, reason="Staff application accepted")
        except discord.Forbidden:
            await self.db.update_staff_app_status(i.message.id, "error")
            return await i.followup.send(
                "Cannot add role â€“ my role is lower than the target role.",
                ephemeral=True,
            )

        await self.db.update_staff_app_status(i.message.id, "accepted")
        await i.followup.send(f"{applicant.mention} accepted âœ…", ephemeral=True)
        await self._finish(i, discord.Color.green())
        await self._notify(f"ğŸ‰ You have been **accepted** as **{self.role}**!")

    @discord.ui.button(
        label="Deny",
        style=discord.ButtonStyle.danger,
        emoji="â›”",
        custom_id="staff_app_deny",
    )
    async def deny(self, i: discord.Interaction, _):
        # Acknowledge interaction immediately
        await i.response.defer(ephemeral=True)
        
        if not await self._authorised(i.user):
            return await i.followup.send("Not authorised.", ephemeral=True)

        await self.db.update_staff_app_status(i.message.id, "denied")
        await i.followup.send("Application denied â›”", ephemeral=True)
        await self._finish(i, discord.Color.red())
        await self._notify(f"âŒ Your application for **{self.role}** was **denied**.")


# â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db):
    await bot.add_cog(StaffApplicationsCog(bot, db))


FILE: cogs\stats.py
----------------------------------------
# cogs/stats.py  â€“  FULL production version  (2024-09-23)
# This file contains every line required by the original cog
# plus the fixes discussed in the support thread.
from __future__ import annotations

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ stdlib & 3rd-party â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import os, re, json, statistics, datetime
import aiohttp
import cachetools
import discord
from discord import app_commands
from discord.ext import commands

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#               CONFIG
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STEAM_API_KEY = os.getenv("STEAM_API_KEY")            # â† MUST be set
BM_TOKEN      = os.getenv("BATTLEMETRICS_TOKEN", "")
BM_HEADERS    = {"Authorization": f"Bearer {BM_TOKEN}"} if BM_TOKEN else {}

APPID_RUST = 252490

PROFILE_RE   = re.compile(r"https?://steamcommunity\.com/(?:profiles|id)/([^/]+)")
PLAYER_CACHE = cachetools.TTLCache(maxsize=1_000, ttl=300)   # 5-minute cache

RISK_FLAG_EXPLANATIONS = {
    "ğŸ”’ Private profile":            "Profile not public",
    "ğŸ‘¤ Default avatar":             "Using default Steam avatar",
    "ğŸ†• New account":                "Account < 30 days old",
    "â¬‡ï¸ Low Steam level":            "Level < 10",
    "ğŸ® Few games":                  "Owns < 3 games",
    "ğŸ‘¥ Few friends":                "Has < 3 friends",
    "âš ï¸ Recent ban":                 "Ban in last 90 days",
    "âš ï¸ Very recent ban":            "Ban in last 14 days",
    "âš ï¸ Multiple bans":              "More than one VAC / game ban",
    "ğŸ”´ BattleMetrics ban":          "Banned on BattleMetrics",
    "ğŸ”´ EAC ban":                    "EAC ban recorded",
    "ğŸ”´ RustBans ban":               "Banned on RustBans",
    "âš ï¸ SteamRep flagged":           "Negative SteamRep",
    "âœï¸ Frequent name changes":      "â‰¥ 3 previous names",
    "ğŸ•µï¸â€â™‚ï¸ Suspicious name":          "Alt / smurf style name",
    "ğŸ•¹ï¸ Rust-only account":          "Only owns Rust (plus F2P)",
    "â³ High Rust hours (fast)":      "High hours but new account",
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
### BASELINE SECTION â€“ put this once near the top of your cog
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RAW_SAMPLES: list[dict] = [
    # 1
    {"kill_scientist":354,"kill_bear":55,"kill_wolf":39,"kill_boar":83,"kill_deer":12,"kill_horse":65,"death_suicide":682,"death_fall":24,"harvest_wood":2362390,"harvest_stones":1403171,"harvest_metal_ore":2964557,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":197998,"acq_scrap":282686,"acq_cloth":17461,"acq_leather":7734,"build_place":37247,"build_upgrade":10749,"barrels":26798,"bps":1070,"pipes":1980,"wires":762,"waves":213,"horse_miles":86,"horses_ridden":65,"calories":914399,"water":276831,"map_open":189793,"inv_open":443857,"items_crafted":22261,"shots_fired":609332,"shots_hit":253134,"arrow_fired":5637,"arrow_hit":2870,"headshot_hits":13704,"kill_player":3178,"death_player":3436,"_hours":3511},
    # 2
    {"kill_scientist":177,"kill_bear":26,"kill_wolf":17,"kill_boar":29,"kill_deer":5,"kill_horse":66,"death_suicide":186,"death_fall":10,"harvest_wood":609213,"harvest_stones":723570,"harvest_metal_ore":1054506,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":32355,"acq_scrap":59674,"acq_cloth":14140,"acq_leather":2432,"build_place":42145,"build_upgrade":17988,"barrels":14600,"bps":886,"pipes":322,"wires":826,"waves":34,"horse_miles":16,"horses_ridden":66,"calories":241643,"water":75164,"map_open":40893,"inv_open":139486,"items_crafted":6758,"shots_fired":7692,"shots_hit":4204,"arrow_fired":983,"arrow_hit":477,"headshot_hits":743,"kill_player":511,"death_player":1115,"_hours":1361},
    # 3
    {"kill_scientist":150,"kill_bear":4,"kill_wolf":11,"kill_boar":24,"kill_deer":7,"kill_horse":4,"death_suicide":112,"death_fall":1,"harvest_wood":89169,"harvest_stones":76421,"harvest_metal_ore":507135,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":10907,"acq_scrap":13242,"acq_cloth":2684,"acq_leather":1141,"build_place":3041,"build_upgrade":2730,"barrels":4066,"bps":267,"pipes":0,"wires":15,"waves":0,"horse_miles":3,"horses_ridden":4,"calories":138684,"water":40459,"map_open":8922,"inv_open":48483,"items_crafted":2389,"shots_fired":42379,"shots_hit":19476,"arrow_fired":988,"arrow_hit":533,"headshot_hits":2057,"kill_player":470,"death_player":443,"_hours":407},
    # 4
    {"kill_scientist":7274,"kill_bear":554,"kill_wolf":288,"kill_boar":1010,"kill_deer":63,"kill_horse":231,"death_suicide":2799,"death_fall":201,"harvest_wood":559046,"harvest_stones":560009,"harvest_metal_ore":6190220,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":189473,"acq_scrap":217267,"acq_cloth":22015,"acq_leather":4009,"build_place":213313,"build_upgrade":73828,"barrels":46328,"bps":3881,"pipes":656,"wires":1772,"waves":513,"horse_miles":1655,"horses_ridden":231,"calories":1322232,"water":384341,"map_open":78908,"inv_open":635818,"items_crafted":30236,"shots_fired":244968,"shots_hit":117231,"arrow_fired":9018,"arrow_hit":6484,"headshot_hits":19610,"kill_player":12363,"death_player":4277,"_hours":4505},
    # 5
    {"kill_scientist":77,"kill_bear":30,"kill_wolf":23,"kill_boar":60,"kill_deer":44,"kill_horse":118,"death_suicide":328,"death_fall":14,"harvest_wood":571628,"harvest_stones":248131,"harvest_metal_ore":659782,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":34781,"acq_scrap":62898,"acq_cloth":13846,"acq_leather":5828,"build_place":2979,"build_upgrade":2754,"barrels":6998,"bps":213,"pipes":0,"wires":39,"waves":5,"horse_miles":36,"horses_ridden":118,"calories":245011,"water":108200,"map_open":29552,"inv_open":107325,"items_crafted":1705,"shots_fired":21212,"shots_hit":12931,"arrow_fired":1830,"arrow_hit":903,"headshot_hits":719,"kill_player":406,"death_player":1357,"_hours":895},
    # 6
    {"kill_scientist":508,"kill_bear":70,"kill_wolf":32,"kill_boar":117,"kill_deer":27,"kill_horse":49,"death_suicide":135,"death_fall":8,"harvest_wood":122734,"harvest_stones":137361,"harvest_metal_ore":1842790,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":43915,"acq_scrap":36475,"acq_cloth":6891,"acq_leather":1203,"build_place":10966,"build_upgrade":9572,"barrels":11272,"bps":1139,"pipes":153,"wires":668,"waves":29,"horse_miles":83,"horses_ridden":49,"calories":191708,"water":52369,"map_open":15614,"inv_open":92130,"items_crafted":6765,"shots_fired":10528,"shots_hit":5882,"arrow_fired":824,"arrow_hit":559,"headshot_hits":1305,"kill_player":753,"death_player":522,"_hours":560},
    # 7
    {"kill_scientist":127,"kill_bear":25,"kill_wolf":32,"kill_boar":51,"kill_deer":2,"kill_horse":74,"death_suicide":267,"death_fall":11,"harvest_wood":392618,"harvest_stones":316605,"harvest_metal_ore":892631,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":28336,"acq_scrap":71849,"acq_cloth":6066,"acq_leather":1883,"build_place":8435,"build_upgrade":6904,"barrels":7956,"bps":771,"pipes":0,"wires":0,"waves":42,"horse_miles":34,"horses_ridden":74,"calories":336570,"water":134404,"map_open":32268,"inv_open":118623,"items_crafted":3116,"shots_fired":57902,"shots_hit":27645,"arrow_fired":2431,"arrow_hit":1341,"headshot_hits":1756,"kill_player":730,"death_player":1093,"_hours":1076},
    # 8
    {"kill_scientist":94,"kill_bear":36,"kill_wolf":23,"kill_boar":85,"kill_deer":31,"kill_horse":111,"death_suicide":239,"death_fall":21,"harvest_wood":299206,"harvest_stones":406888,"harvest_metal_ore":1013881,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":33126,"acq_scrap":39103,"acq_cloth":25362,"acq_leather":5173,"build_place":23754,"build_upgrade":13041,"barrels":7606,"bps":353,"pipes":328,"wires":1398,"waves":222,"horse_miles":22,"horses_ridden":111,"calories":316711,"water":85832,"map_open":28185,"inv_open":160681,"items_crafted":10638,"shots_fired":20496,"shots_hit":10767,"arrow_fired":1098,"arrow_hit":571,"headshot_hits":1421,"kill_player":638,"death_player":1102,"_hours":1005},
    # 9
    {"kill_scientist":1538,"kill_bear":74,"kill_wolf":85,"kill_boar":148,"kill_deer":14,"kill_horse":132,"death_suicide":236,"death_fall":5,"harvest_wood":61552,"harvest_stones":124968,"harvest_metal_ore":2466700,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":28056,"acq_scrap":25135,"acq_cloth":1982,"acq_leather":700,"build_place":18518,"build_upgrade":14925,"barrels":16192,"bps":1333,"pipes":221,"wires":477,"waves":66,"horse_miles":224,"horses_ridden":132,"calories":589583,"water":156402,"map_open":65653,"inv_open":261916,"items_crafted":7612,"shots_fired":39702,"shots_hit":22799,"arrow_fired":3299,"arrow_hit":1844,"headshot_hits":4655,"kill_player":2031,"death_player":1083,"_hours":1383},
    # 10
    {"kill_scientist":2942,"kill_bear":192,"kill_wolf":103,"kill_boar":286,"kill_deer":115,"kill_horse":84,"death_suicide":796,"death_fall":77,"harvest_wood":401773,"harvest_stones":405135,"harvest_metal_ore":5359024,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":328675,"acq_scrap":236977,"acq_cloth":11583,"acq_leather":2603,"build_place":106074,"build_upgrade":45983,"barrels":37434,"bps":4999,"pipes":206,"wires":244,"waves":671,"horse_miles":126,"horses_ridden":84,"calories":1429121,"water":473881,"map_open":155438,"inv_open":638920,"items_crafted":18922,"shots_fired":209520,"shots_hit":127249,"arrow_fired":7372,"arrow_hit":4373,"headshot_hits":12376,"kill_player":7000,"death_player":4515,"_hours":3254},
    # 11
    {"kill_scientist":212,"kill_bear":34,"kill_wolf":37,"kill_boar":92,"kill_deer":15,"kill_horse":33,"death_suicide":184,"death_fall":6,"harvest_wood":2064470,"harvest_stones":899024,"harvest_metal_ore":1011734,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":14565,"acq_scrap":10602,"acq_cloth":41203,"acq_leather":14470,"build_place":1372,"build_upgrade":1576,"barrels":10064,"bps":317,"pipes":0,"wires":14,"waves":10,"horse_miles":29,"horses_ridden":33,"calories":232643,"water":70585,"map_open":23424,"inv_open":113051,"items_crafted":2508,"shots_fired":10883,"shots_hit":5711,"arrow_fired":995,"arrow_hit":652,"headshot_hits":799,"kill_player":689,"death_player":616,"_hours":738},
    # 12
    {"kill_scientist":259,"kill_bear":54,"kill_wolf":61,"kill_boar":136,"kill_deer":74,"kill_horse":70,"death_suicide":320,"death_fall":2,"harvest_wood":195700,"harvest_stones":290142,"harvest_metal_ore":1091375,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":24847,"acq_scrap":21259,"acq_cloth":8975,"acq_leather":2347,"build_place":72973,"build_upgrade":17626,"barrels":10098,"bps":493,"pipes":34,"wires":292,"waves":4,"horse_miles":41,"horses_ridden":70,"calories":266304,"water":117404,"map_open":23023,"inv_open":99896,"items_crafted":6156,"shots_fired":60589,"shots_hit":35985,"arrow_fired":8192,"arrow_hit":3780,"headshot_hits":2227,"kill_player":1145,"death_player":1728,"_hours":980},
    # 13
    {"kill_scientist":80,"kill_bear":7,"kill_wolf":4,"kill_boar":26,"kill_deer":1,"kill_horse":275,"death_suicide":61,"death_fall":1,"harvest_wood":416652,"harvest_stones":356796,"harvest_metal_ore":241345,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":4340,"acq_scrap":3175,"acq_cloth":10406,"acq_leather":2997,"build_place":509,"build_upgrade":605,"barrels":2282,"bps":15,"pipes":0,"wires":0,"waves":3,"horse_miles":7,"horses_ridden":275,"calories":62326,"water":17612,"map_open":3040,"inv_open":26637,"items_crafted":540,"shots_fired":4990,"shots_hit":2850,"arrow_fired":233,"arrow_hit":96,"headshot_hits":272,"kill_player":207,"death_player":290,"_hours":165},
    # 14
    {"kill_scientist":18,"kill_bear":9,"kill_wolf":9,"kill_boar":11,"kill_deer":2,"kill_horse":5,"death_suicide":11,"death_fall":1,"harvest_wood":91199,"harvest_stones":131170,"harvest_metal_ore":204296,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":1979,"acq_scrap":2221,"acq_cloth":2986,"acq_leather":1037,"build_place":609,"build_upgrade":466,"barrels":1732,"bps":20,"pipes":0,"wires":0,"waves":1,"horse_miles":8,"horses_ridden":5,"calories":44906,"water":12002,"map_open":1605,"inv_open":11889,"items_crafted":359,"shots_fired":2129,"shots_hit":1222,"arrow_fired":227,"arrow_hit":102,"headshot_hits":163,"kill_player":80,"death_player":148,"_hours":91},
    # 15
    {"kill_scientist":20,"kill_bear":4,"kill_wolf":3,"kill_boar":18,"kill_deer":3,"kill_horse":182,"death_suicide":69,"death_fall":9,"harvest_wood":103288,"harvest_stones":40823,"harvest_metal_ore":350620,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":14851,"acq_scrap":28422,"acq_cloth":878,"acq_leather":1033,"build_place":2624,"build_upgrade":1683,"barrels":4932,"bps":232,"pipes":1669,"wires":3401,"waves":0,"horse_miles":14,"horses_ridden":182,"calories":83077,"water":24560,"map_open":6929,"inv_open":38328,"items_crafted":2931,"shots_fired":2822,"shots_hit":1919,"arrow_fired":167,"arrow_hit":82,"headshot_hits":72,"kill_player":67,"death_player":262,"_hours":596},
    # 16
    {"kill_scientist":5914,"kill_bear":73,"kill_wolf":56,"kill_boar":261,"kill_deer":29,"kill_horse":2115,"death_suicide":600,"death_fall":11,"harvest_wood":1774328,"harvest_stones":928261,"harvest_metal_ore":312497,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":18345,"acq_scrap":39335,"acq_cloth":58659,"acq_leather":16666,"build_place":40607,"build_upgrade":11907,"barrels":12252,"bps":804,"pipes":63,"wires":149,"waves":25,"horse_miles":280,"horses_ridden":2115,"calories":489067,"water":156255,"map_open":23920,"inv_open":118232,"items_crafted":5484,"shots_fired":122665,"shots_hit":58707,"arrow_fired":7151,"arrow_hit":3577,"headshot_hits":14446,"kill_player":6461,"death_player":1727,"_hours":761},
    # 17
    {"kill_scientist":373,"kill_bear":46,"kill_wolf":26,"kill_boar":59,"kill_deer":8,"kill_horse":266,"death_suicide":145,"death_fall":10,"harvest_wood":328148,"harvest_stones":456950,"harvest_metal_ore":1791943,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":33950,"acq_scrap":30473,"acq_cloth":9211,"acq_leather":4933,"build_place":50198,"build_upgrade":14947,"barrels":5776,"bps":830,"pipes":335,"wires":808,"waves":73,"horse_miles":32,"horses_ridden":266,"calories":264662,"water":90732,"map_open":38546,"inv_open":171193,"items_crafted":6471,"shots_fired":22908,"shots_hit":12084,"arrow_fired":2096,"arrow_hit":1056,"headshot_hits":1675,"kill_player":914,"death_player":1063,"_hours":711},
    # 18
    {"kill_scientist":1503,"kill_bear":164,"kill_wolf":167,"kill_boar":388,"kill_deer":95,"kill_horse":181,"death_suicide":679,"death_fall":22,"harvest_wood":2488693,"harvest_stones":1878775,"harvest_metal_ore":1121361,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":100601,"acq_scrap":71940,"acq_cloth":103517,"acq_leather":38881,"build_place":21072,"build_upgrade":14789,"barrels":31764,"bps":983,"pipes":0,"wires":75,"waves":8,"horse_miles":219,"horses_ridden":181,"calories":1154754,"water":895653,"map_open":85639,"inv_open":357509,"items_crafted":8262,"shots_fired":280702,"shots_hit":113993,"arrow_fired":19525,"arrow_hit":8795,"headshot_hits":13599,"kill_player":4174,"death_player":4826,"_hours":2258},
    # 19
    {"kill_scientist":754,"kill_bear":129,"kill_wolf":107,"kill_boar":215,"kill_deer":81,"kill_horse":105,"death_suicide":1874,"death_fall":32,"harvest_wood":726685,"harvest_stones":325399,"harvest_metal_ore":3182498,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":363139,"acq_scrap":234022,"acq_cloth":25275,"acq_leather":9316,"build_place":70992,"build_upgrade":46432,"barrels":19190,"bps":1692,"pipes":151,"wires":522,"waves":178,"horse_miles":143,"horses_ridden":105,"calories":1852308,"water":595864,"map_open":86312,"inv_open":853846,"items_crafted":30230,"shots_fired":755531,"shots_hit":277956,"arrow_fired":17509,"arrow_hit":8121,"headshot_hits":17674,"kill_player":9430,"death_player":9065,"_hours":4194},
    # 20
    {"kill_scientist":105,"kill_bear":10,"kill_wolf":12,"kill_boar":24,"kill_deer":2,"kill_horse":17,"death_suicide":64,"death_fall":1,"harvest_wood":21972,"harvest_stones":31930,"harvest_metal_ore":142886,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":4556,"acq_scrap":6244,"acq_cloth":1969,"acq_leather":582,"build_place":728,"build_upgrade":724,"barrels":2502,"bps":672,"pipes":0,"wires":12,"waves":0,"horse_miles":6,"horses_ridden":17,"calories":52617,"water":28933,"map_open":3566,"inv_open":19844,"items_crafted":1254,"shots_fired":42886,"shots_hit":16490,"arrow_fired":623,"arrow_hit":274,"headshot_hits":1363,"kill_player":277,"death_player":262,"_hours":252},
    # 21
    {"kill_scientist":2186,"kill_bear":140,"kill_wolf":117,"kill_boar":158,"kill_deer":16,"kill_horse":229,"death_suicide":518,"death_fall":39,"harvest_wood":358730,"harvest_stones":635622,"harvest_metal_ore":2111269,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":171723,"acq_scrap":256875,"acq_cloth":26341,"acq_leather":4391,"build_place":121514,"build_upgrade":63315,"barrels":24652,"bps":2982,"pipes":1,"wires":280,"waves":483,"horse_miles":310,"horses_ridden":229,"calories":1189694,"water":466139,"map_open":103053,"inv_open":504075,"items_crafted":29209,"shots_fired":663120,"shots_hit":259016,"arrow_fired":3547,"arrow_hit":1812,"headshot_hits":22469,"kill_player":7803,"death_player":3118,"_hours":2797},
    # 22
    {"kill_scientist":38,"kill_bear":3,"kill_wolf":12,"kill_boar":18,"kill_deer":0,"kill_horse":124,"death_suicide":76,"death_fall":4,"harvest_wood":669959,"harvest_stones":419266,"harvest_metal_ore":366584,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":6810,"acq_scrap":14132,"acq_cloth":14639,"acq_leather":4296,"build_place":1556,"build_upgrade":1634,"barrels":6310,"bps":168,"pipes":4,"wires":14,"waves":34,"horse_miles":3,"horses_ridden":124,"calories":135077,"water":146203,"map_open":22242,"inv_open":52607,"items_crafted":2925,"shots_fired":9061,"shots_hit":3226,"arrow_fired":352,"arrow_hit":158,"headshot_hits":533,"kill_player":185,"death_player":492,"_hours":328},
    # 23
    {"kill_scientist":90,"kill_bear":13,"kill_wolf":11,"kill_boar":18,"kill_deer":9,"kill_horse":7,"death_suicide":264,"death_fall":9,"harvest_wood":29331,"harvest_stones":109020,"harvest_metal_ore":852785,"harvest_hq_metal_ore":0,"harvest_sulfur_ore":0,"acq_lowgrade":23538,"acq_scrap":23944,"acq_cloth":3789,"acq_leather":254,"build_place":25772,"build_upgrade":8394,"barrels":3588,"bps":70,"pipes":0,"wires":121,"waves":40,"horse_miles":19,"horses_ridden":7,"calories":215783,"water":101466,"map_open":15590,"inv_open":100174,"items_crafted":3460,"shots_fired":57964,"shots_hit":30508,"arrow_fired":2660,"arrow_hit":1552,"headshot_hits":2014,"kill_player":1221,"death_player":1532,"_hours":842}
]

def _build_baseline(samples: list[dict]) -> dict[str, dict]:
    """
    Turn RAW_SAMPLES into {stat: {mean, sd}} (per-hour).
    Keep stats with â‰¥3 samples and players with â‰¥10 h.
    """
    per_key: dict[str, list[float]] = {}
    for s in samples:
        hrs = s.get("_hours", 0)
        if hrs < 10:
            continue
        for k, v in s.items():
            if k == "_hours": 
                continue
            per_key.setdefault(k, []).append(v / hrs)

    baseline: dict[str, dict] = {}
    for k, lst in per_key.items():
        if len(lst) < 3:             # need enough samples
            continue
        mu = statistics.mean(lst)
        sd = statistics.stdev(lst) if len(lst) > 1 else 0.001
        baseline[k] = {"mean": mu, "sd": sd}

    baseline["_meta"] = {
        "generated": datetime.datetime.utcnow().isoformat(timespec="seconds"),
        "source_samples": len(samples)
    }
    return baseline

BASELINE: dict = _build_baseline(RAW_SAMPLES)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#               COG
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class StatsCog(commands.Cog):
    """
    /check â€¦   â€“ risk / ban look-ups  
    /stats â€¦   â€“ Rust statistics
    """

    check = app_commands.Group(name="check",  description="Look-ups & checks")
    stats = app_commands.Group(name="stats",  description="Game statistics")

    def __init__(self, bot: commands.Bot):
        self.bot = bot                # no manual add_command â€“ discord.py does it

    async def _achievements(self, sid: str):
        """
        Return unlocked-count, total-count, percentage-string.
        """
        async with aiohttp.ClientSession() as ses:
            url = ("https://api.steampowered.com/ISteamUserStats/"
                   f"GetPlayerAchievements/v1/?key={STEAM_API_KEY}"
                   f"&steamid={sid}&appid={APPID_RUST}")
            async with ses.get(url) as r:
                data = await r.json()

        ps = data.get("playerstats", {})
        if not ps.get("success"):
            return 0, 0, "N/A"

        lst = ps.get("achievements", [])
        unlocked = sum(1 for a in lst if a["achieved"])
        total    = len(lst)
        pct      = f"{unlocked/total*100:.1f}%"
        return unlocked, total, pct

    async def _playtime_and_persona(self, sid: str):
        """Return total-hrs, 2-wk-hrs, last-played-date, player-summary-dict"""
        async with aiohttp.ClientSession() as ses:
            # total / 2-week hours
            url1 = ("https://api.steampowered.com/IPlayerService/"
                    f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
            async with ses.get(url1) as r:
                og = await r.json()
        g = next((x for x in og.get("response", {}).get("games", [])
                  if x["appid"] == APPID_RUST), None)
        total_h = g["playtime_forever"] // 60 if g else 0
        two_w_h = g.get("playtime_2weeks", 0) // 60 if g else 0

        # date last played
        async with aiohttp.ClientSession() as ses:
            url2 = ("https://api.steampowered.com/IPlayerService/"
                    f"GetRecentlyPlayedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
            async with ses.get(url2) as r:
                rp = await r.json()
        recent = next((x for x in rp.get("response", {}).get("games", [])
                       if x["appid"] == APPID_RUST), None)
        last_play = (datetime.datetime.utcfromtimestamp(recent["playtime_at"])
                     .strftime("%Y-%m-%d")
                     if recent and "playtime_at" in recent else "Unknown")

        # persona / avatar / profile-url
        async with aiohttp.ClientSession() as ses:
            url3 = ("https://api.steampowered.com/ISteamUser/"
                    f"GetPlayerSummaries/v2/?key={STEAM_API_KEY}&steamids={sid}")
            async with ses.get(url3) as r:
                prof = (await r.json())["response"]["players"][0]

        return total_h, two_w_h, last_play, prof

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #   /check help
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @check.command(name="help", description="Explain risk flags")
    async def check_help(self, inter: discord.Interaction):
        txt = "\n".join(f"{k} â€” {v}" for k, v in RISK_FLAG_EXPLANATIONS.items())
        await inter.response.send_message(txt, ephemeral=True)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #   /check player
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @check.command(name="player", description="Steam profile & ban check")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def check_player(self, inter: discord.Interaction, steamid: str):

        if not STEAM_API_KEY:
            return await inter.response.send_message(
                "Steam API key is not configured on this bot.", ephemeral=True
            )

        await inter.response.defer(ephemeral=True)

        # â”€â”€â”€â”€â”€ SteamID resolution â”€â”€â”€â”€â”€
        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send(
                "Unable to resolve SteamID.", ephemeral=True
            )

        # â”€â”€â”€â”€â”€ fetch (with 5-min cache) â”€â”€â”€â”€â”€
        if sid in PLAYER_CACHE:
            (bans, prof, lvl, game_cnt, friend_cnt, top_games,
             bm_prof, bm_bans, eac, names,
             rb_status, rb_reason, rb_date,
             sr_status, rust_h, two_w_h,
             comments, patterns) = PLAYER_CACHE[sid]
        else:
            bans, prof = await self._steam_bans_and_profile(sid)
            lvl, game_cnt, friend_cnt, top_games = \
                await self._level_games_friends(sid)
            bm_prof, bm_bans, eac, names = await self._bm_info(sid)
            rb_status, rb_reason, rb_date = await self._rustbans_info(sid)
            sr_status = await self._steamrep_info(sid)
            rust_h, two_w_h = await self._rust_hours(sid)
            comments = await self._profile_comments(sid)
            patterns = [n for n in names
                        if re.search(r"(alt|smurf|rust|\d{5,})", n, re.I)]
            PLAYER_CACHE[sid] = (bans, prof, lvl, game_cnt, friend_cnt,
                                 top_games, bm_prof, bm_bans, eac, names,
                                 rb_status, rb_reason, rb_date,
                                 sr_status, rust_h, two_w_h,
                                 comments, patterns)

        # â”€â”€â”€â”€â”€ risk / flag analysis â”€â”€â”€â”€â”€
        now = datetime.datetime.utcnow()
        created = (datetime.datetime.utcfromtimestamp(prof.get("timecreated", 0))
                   if prof.get("timecreated") else None)
        age = (now - created).days if created else None

        total_bans   = (bans.get("NumberOfVACBans", 0) or 0) + \
                       (bans.get("NumberOfGameBans", 0) or 0)
        has_any_ban  = bans.get("VACBanned") or total_bans

        recent_ban   = has_any_ban and bans.get("DaysSinceLastBan", 9999) <= 90
        very_recent  = has_any_ban and bans.get("DaysSinceLastBan", 9999) <= 14
        low_lvl      = lvl is not None and lvl < 6
        low_games    = game_cnt is not None and game_cnt < 3
        rust_only    = (game_cnt is not None and game_cnt <= 2
                        and top_games and top_games[0]["name"].lower() == "rust")
        low_friends  = friend_cnt is not None and friend_cnt < 3
        private      = prof.get("communityvisibilitystate", 3) != 3
        default_av   = prof.get("avatarfull", "").endswith("/avatar.jpg")
        many_names   = len(names) >= 3
        multi_bans   = total_bans > 1
        suspicious_name = bool(patterns)
        fast_rust    = (rust_h is not None and age is not None
                        and rust_h > 100 and age < 30)

        flags: list[str] = []
        if private:         flags.append("ğŸ”’ Private profile")
        if default_av:      flags.append("ğŸ‘¤ Default avatar")
        if age is not None and age < 30: flags.append("ğŸ†• New account")
        if low_lvl:         flags.append("â¬‡ï¸ Low Steam level")
        if low_games:       flags.append("ğŸ® Few games")
        if low_friends:     flags.append("ğŸ‘¥ Few friends")
        if very_recent:     flags.append("âš ï¸ Very recent ban")
        elif recent_ban:    flags.append("âš ï¸ Recent ban")
        if multi_bans:      flags.append("âš ï¸ Multiple bans")
        if bm_bans:         flags.append("ğŸ”´ BattleMetrics ban")
        if eac:             flags.append("ğŸ”´ EAC ban")
        if rb_status:       flags.append("ğŸ”´ RustBans ban")
        if sr_status:       flags.append("âš ï¸ SteamRep flagged")
        if many_names:      flags.append("âœï¸ Frequent name changes")
        if suspicious_name: flags.append("ğŸ•µï¸â€â™‚ï¸ Suspicious name")
        if rust_only:       flags.append("ğŸ•¹ï¸ Rust-only account")
        if fast_rust:       flags.append("â³ High Rust hrs (fast)")

        # â”€â”€â”€â”€â”€ numeric score â”€â”€â”€â”€â”€
        score = 0
        if private:                        score += 2
        if default_av:                     score += 1
        if age is not None:
            score += 5 if age < 7 else 3 if age < 30 else 0
        if low_lvl:                        score += 2
        if lvl and lvl > 50:               score -= 2
        if low_games:                      score += 3
        if game_cnt and game_cnt > 100:    score -= 2
        if low_friends:                    score += 2
        if friend_cnt and friend_cnt > 100:score -= 1
        if very_recent:                    score += 8
        elif recent_ban:                   score += 5
        if multi_bans:                     score += 3
        if bm_bans:                        score += 5
        if eac:                            score += 5
        if rb_status:                      score += 5
        if sr_status:                      score += 5
        if many_names:                     score += 1
        if suspicious_name:                score += 2
        if rust_only:                      score += 2
        if fast_rust:                      score += 2
        score = max(score, 0)

        risk, colour = (
            ("ğŸ”´  HIGH RISK",     discord.Color.red())     if score >= 12 else
            ("ğŸŸ   MODERATE RISK", discord.Color.orange())  if score >= 5  else
            ("ğŸŸ¢  LOW RISK",      discord.Color.green())
        )

        # â”€â”€â”€â”€â”€ embed skeleton â”€â”€â”€â”€â”€
        e = discord.Embed(
                title=prof.get("personaname", "Unknown"),
                url=prof.get("profileurl"),
                colour=colour,
                description=f"{risk}\n\n{' '.join(flags) or 'No immediate risk factors.'}"
            ).set_footer(text=f"SteamID64: {sid}  |  Score: {score}")
        if prof.get("avatarfull"):
            e.set_thumbnail(url=prof["avatarfull"])

        fmt = lambda n: f"{n:,}" if n is not None else "N/A"

        # â”€â”€â”€â”€â”€ neat blocks â”€â”€â”€â”€â”€
        # Account block
        account_block = "\n".join([
            f"Created : {created.strftime('%Y-%m-%d') if created else 'N/A'}",
            f"Age     : {age} d" if age is not None else "Age     : N/A",
            f"Level   : {fmt(lvl)}",
            f"Games   : {fmt(game_cnt)}",
            ("Friends : " +
             ("Private" if friend_cnt is None else fmt(friend_cnt))),
            f"Status  : {'Private' if private else 'Public'}",
        ])
        e.add_field(name="Account", value=f"```ini\n{account_block}\n```",
                    inline=False)

        # Activity block
        activity_block = "\n".join([
            f"Rust hours  : {fmt(rust_h)}",
            f"2-weeks hrs : {fmt(two_w_h)}",
        ])
        e.add_field(name="Activity", value=f"```ini\n{activity_block}\n```",
                    inline=False)

        # Top games (already hours)
        if top_games:
            tg_list = "\n".join(
                f"{g['name'][:25]:25}  {g['playtime']:>6,} h"
                for g in top_games[:5]
            )
            e.add_field(name="Top games (hours)",
                        value=f"```ini\n{tg_list}\n```",
                        inline=False)

        # Bans / reputation
        ban_lines = [
            f"VAC             : {'Yes' if bans['VACBanned'] else 'No'} "
            f"({bans['NumberOfVACBans']})",
            f"Game bans       : {bans['NumberOfGameBans']}",
            f"Comm ban        : {'Yes' if bans['CommunityBanned'] else 'No'}",
            f"Trade ban       : {bans['EconomyBan'].capitalize()}",
        ]
        if eac is not None:
            ban_lines.append(f"EAC ban         : {'Yes' if eac else 'No'}")
        ban_lines.append(
            f"BattleMetrics   : "
            f"{len(bm_bans)} ban(s)" if bm_bans else "BattleMetrics   : None")
        ban_lines.append(
            f"RustBans        : {rb_status or 'None'}")
        ban_lines.append(
            f"SteamRep        : {sr_status or 'Clean'}")
        e.add_field(name="Bans / reputation",
                    value=f"```ini\n" + "\n".join(ban_lines) + "\n```",
                    inline=False)

        # BattleMetrics details (if any bans) â€“ separate block to avoid clutter
        if bm_prof:
            bm_url = f"https://www.battlemetrics.com/rcon/players/{bm_prof['id']}"
            if bm_bans:
                bm_text = f"[Profile]({bm_url}) â€” **{len(bm_bans)} ban(s)**\n"
                for b in bm_bans[:3]:
                    org    = (b['attributes'].get('organization', {})
                              .get('name') or 'Org')
                    reason = b['attributes'].get('reason') or 'No reason'
                    date   = (b['attributes'].get('timestamp') or '')[:10]
                    bm_text += f"â€¢ {org}: {reason} ({date})\n"
                if len(bm_bans) > 3:
                    bm_text += f"â€¦and {len(bm_bans)-3} more"
            else:
                bm_text = f"[Profile]({bm_url}) â€” no bans"
            e.add_field(name="BattleMetrics details", value=bm_text, inline=False)

        # Previous names / comments
        if names:
            e.add_field(name="Previous names",
                        value="\n".join(names[:10]), inline=False)
        if comments:
            e.add_field(name="Profile comments",
                        value="\n".join(comments[:5]), inline=False)

        # Glossary (only for flags present)
        if flags:
            glossary = "\n".join(f"{f} â€” {RISK_FLAG_EXPLANATIONS[f]}"
                                 for f in flags)
            e.add_field(name="Flag glossary", value=glossary, inline=False)

        # Links
        links = [
            f"[Steam]({prof.get('profileurl')})",
            (f"[BattleMetrics](https://www.battlemetrics.com/rcon/players/"
             f"{bm_prof['id']})" if bm_prof else None),
            f"[RustBans](https://rustbans.com/lookup/{sid})",
            f"[SteamDB](https://steamdb.info/calculator/{sid}/)",
            f"[SteamRep](https://steamrep.com/profiles/{sid})",
        ]
        e.add_field(name="Links",
                    value=" | ".join(l for l in links if l),
                    inline=False)

        await inter.followup.send(embed=e, ephemeral=True)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #   /dump raw stats
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @app_commands.command(name="dump_rust_raw", description="DM-dump raw stats with hours")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def dump_rust_raw(self, inter: discord.Interaction, steamid: str):
        await inter.response.defer(ephemeral=True)
        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send("SteamID could not be resolved.", ephemeral=True)
        ok, raw = await self._rust_stats(sid)
        if not ok:
            return await inter.followup.send("Stats private / unavailable.", ephemeral=True)
        # Fetch total Rust hours (lifetime)
        tot_h, *_ = await self._rust_hours(sid)
        if tot_h is not None:
            raw["_hours"] = tot_h
        await inter.followup.send(
            "Copy & save this JSON for baseline analysis:\n"
            f"```json\n{json.dumps(raw, indent=2)}```",
            ephemeral=True
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ### /stats rust  â€“  baseline-aware version
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @stats.command(name="rust", description="Rust hours & detailed risk assessment")
    @app_commands.describe(steamid="SteamID64 or profile URL")
    async def rust_stats(self, inter: discord.Interaction, steamid: str):

        if not STEAM_API_KEY:
            return await inter.response.send_message(
                "Steam API key not configured on this bot.", ephemeral=True
            )
        await inter.response.defer(ephemeral=True)

        sid = await self._resolve(steamid)
        if not sid:
            return await inter.followup.send("Unable to resolve SteamID.",
                                            ephemeral=True)

        # â”€â”€â”€ top-level activity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        tot_h, twk_h, last_play, profile = await self._playtime_and_persona(sid)
        ach_unl, ach_tot, ach_pct = await self._achievements(sid)

        pres_steam = "Yes" if profile.get("gameid") == str(APPID_RUST) else "No"
        bm_prof, *_ = await self._bm_info(sid)
        bm_online = bm_sessions = "N/A"
        if bm_prof:
            _, online, _, sessions, _ = await self._bm_sessions(bm_prof["id"])
            bm_online   = "Yes" if online else "No"
            bm_sessions = sessions

        # â”€â”€â”€ detailed stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ok, st = await self._rust_stats(sid)
        if not ok:
            return await inter.followup.send(
                "Detailed stats are private / unavailable.", ephemeral=True
            )

        # helpers & derived PvP numbers
        fmt = lambda n: "N/A" if n in (None, 0, "N/A") else f"{n:,}"
        b_fired, b_hit = st["shots_fired"], st["shots_hit"]
        a_fired, a_hit = st["arrow_fired"], st["arrow_hit"]

        bullet_acc = b_hit / b_fired if b_fired else 0
        arrow_acc  = a_hit / a_fired if a_fired else 0
        head_acc   = st["headshot_hits"] / b_hit if b_hit else 0
        kills, deaths = st["kill_player"], st["death_player"]
        kd = kills / deaths if deaths else (999 if kills else 0)

        # â”€â”€â”€ risk assessment  (baseline z-scores + PvP caps) â”€â”€â”€â”€â”€â”€â”€
        BIG_Z, MID_Z, MIN_H = 3.5, 2.5, 10
        score, flags = 0, []

        if tot_h and tot_h >= MIN_H:
            for key, val in st.items():
                if key not in BASELINE: 
                    continue
                mu, sd = BASELINE[key]["mean"], BASELINE[key]["sd"]
                if sd < 1e-6: 
                    continue
                z = (val / tot_h - mu) / sd
                if z >= BIG_Z:
                    flags.append(f"ğŸ”´ {key} per-h very high (z={z:.1f})")
                    score += 2
                elif z <= -BIG_Z:
                    flags.append(f"ğŸ”´ {key} per-h very low (z={z:.1f})")
                    score += 2
                elif z >= MID_Z:
                    flags.append(f"âš ï¸ {key} per-h high (z={z:.1f})")
                    score += 1
                elif z <= -MID_Z:
                    flags.append(f"âš ï¸ {key} per-h low (z={z:.1f})")
                    score += 1

        def pvp_cap(name: str, val: float, thresh: float):
            nonlocal score
            if val >= thresh:
                flags.append(f"âš ï¸ {name} {val:.2f} â‰¥ {thresh}")
                score += 2
        pvp_cap("Bullet acc.", bullet_acc, 0.45)
        pvp_cap("Head-shot acc.", head_acc, 0.40)
        pvp_cap("Arrow acc.", arrow_acc, 0.60)
        pvp_cap("K/D", kd, 5.0)

        risk, colour = (
            ("ğŸ”´  HIGH RISK",     discord.Color.red())    if score >= 15 else
            ("ğŸŸ   MODERATE RISK", discord.Color.orange()) if score >= 7  else
            ("ğŸŸ¢  LOW RISK",      discord.Color.green())
        )

        # â”€â”€â”€ embed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        e = (
            discord.Embed(
                title=f"Rust stats â€“ [{profile.get('personaname')}]",
                url=profile.get("profileurl"),
                colour=colour,
                description=f"{risk}\n\n" +
                            (" ".join(flags) if flags else "No risk indicators triggered.")
            )
            .set_footer(text=f"SteamID64: {sid}  |  Score: {score}")
        )
        if profile.get("avatarfull"):
            e.set_thumbnail(url=profile["avatarfull"])

        # blocks (summary / PvP / PvE / resources / misc)
        summary = "\n".join([
            f"Total hrs  : {fmt(tot_h)}",
            f"2-wks hrs  : {fmt(twk_h)}",
            f"Last played: {last_play}",
            f"Achievement: {ach_unl}/{ach_tot} ({ach_pct})",
            f"Steam pres.: {pres_steam}",
            f"BM pres.   : {bm_online}",
            f"BM sessions: {fmt(bm_sessions)}",
        ])
        e.add_field(name="Summary", value=f"```ini\n{summary}\n```", inline=False)

        pvp_blk = "\n".join([
            f"Kills  : {fmt(kills)}",
            f"Deaths : {fmt(deaths)}   (K/D {kd:.2f})",
            f"Bullets: {fmt(b_hit)} / {fmt(b_fired)} ({bullet_acc*100:4.1f} %)",
            f"Head-shot acc.: {head_acc*100:4.1f} %",
            f"Arrows : {fmt(a_hit)} / {fmt(a_fired)} ({arrow_acc*100:4.1f} %)",
        ])
        e.add_field(name="PvP", value=f"```ini\n{pvp_blk}\n```", inline=False)

        pve = "\n".join([
            f"Scientists: {fmt(st['kill_scientist'])}",
            f"Bears     : {fmt(st['kill_bear'])}",
            f"Wolves    : {fmt(st['kill_wolf'])}",
            f"Boars     : {fmt(st['kill_boar'])}",
            f"Deer      : {fmt(st['kill_deer'])}",
            f"Horses    : {fmt(st['kill_horse'])}",
        ])
        other_deaths = "\n".join([
            f"Suicides: {fmt(st['death_suicide'])}",
            f"Falling : {fmt(st['death_fall'])}",
        ])
        e.add_field(name="PvE kills", value=f"```ini\n{pve}\n```", inline=True)
        e.add_field(name="Other deaths", value=f"```ini\n{other_deaths}\n```",
                    inline=True)
        e.add_field(name="\u200b", value="\u200b", inline=False)

        nodes = "\n".join([
            f"Wood      : {fmt(st['harvest_wood'])}",
            f"Stone     : {fmt(st['harvest_stones'])}",
            f"Metal ore : {fmt(st['harvest_metal_ore'])}",
            f"HQ ore    : {fmt(st['harvest_hq_metal_ore'])}",
            f"Sulfur ore: {fmt(st['harvest_sulfur_ore'])}",
        ])
        pickups = "\n".join([
            f"Low-grade : {fmt(st['acq_lowgrade'])}",
            f"Scrap     : {fmt(st['acq_scrap'])}",
            f"Cloth     : {fmt(st['acq_cloth'])}",
            f"Leather   : {fmt(st['acq_leather'])}",
        ])
        build = "\n".join([
            f"Blocks placed : {fmt(st['build_place'])}",
            f"Blocks upgrade: {fmt(st['build_upgrade'])}",
            f"Barrels broken: {fmt(st['barrels'])}",
            f"BPs learned   : {fmt(st['bps'])}",
        ])
        e.add_field(name="Resources (nodes)",
                    value=f"```ini\n{nodes}\n```", inline=True)
        e.add_field(name="Resources (pick-ups)",
                    value=f"```ini\n{pickups}\n```", inline=True)
        e.add_field(name="Building / Loot",
                    value=f"```ini\n{build}\n```", inline=True)
        e.add_field(name="\u200b", value="\u200b", inline=False)

        social = "\n".join([
            f"Wires conn.: {fmt(st['wires'])}",
            f"Pipes conn.: {fmt(st['pipes'])}",
            f"Friendly waves: {fmt(st['waves'])}",
        ])
        horses = "\n".join([
            f"Miles ridden : {fmt(st['horse_miles'])}",
            f"Horses ridden: {fmt(st['horses_ridden'])}",
        ])
        ui = "\n".join([
            f"Calories : {fmt(st['calories'])}",
            f"Water    : {fmt(st['water'])}",
            f"Map opens: {fmt(st['map_open'])}",
            f"Inv opens: {fmt(st['inv_open'])}",
            f"Crafted  : {fmt(st['items_crafted'])}",
        ])
        e.add_field(name="Electric / Social",
                    value=f"```ini\n{social}\n```", inline=True)
        e.add_field(name="Horses",
                    value=f"```ini\n{horses}\n```", inline=True)
        e.add_field(name="Consumption / UI",
                    value=f"```ini\n{ui}\n```", inline=True)

        await inter.followup.send(embed=e, ephemeral=True)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• helper methods â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _resolve(self, raw: str):
        if raw.isdigit() and len(raw) >= 16:
            return raw
        m = PROFILE_RE.search(raw)
        if not m:
            return None
        vanity = m.group(1)
        if vanity.isdigit():
            return vanity
        url = ("https://api.steampowered.com/ISteamUser/ResolveVanityURL/v1/"
               f"?key={STEAM_API_KEY}&vanityurl={vanity}")
        async with aiohttp.ClientSession() as s, s.get(url) as r:
            data = await r.json()
        return data["response"].get("steamid")

    async def _steam_bans_and_profile(self, sid: str):
        async with aiohttp.ClientSession() as ses:
            url_b = ("https://api.steampowered.com/ISteamUser/GetPlayerBans/v1/"
                     f"?key={STEAM_API_KEY}&steamids={sid}")
            url_p = ("https://api.steampowered.com/ISteamUser/"
                     f"GetPlayerSummaries/v2/?key={STEAM_API_KEY}&steamids={sid}")
            async with ses.get(url_b) as r1, ses.get(url_p) as r2:
                bans = (await r1.json())["players"][0]
                prof = (await r2.json())["response"]["players"][0]
        return bans, prof

    async def _bm_info(self, sid: str):
        if not sid.isdigit():
            return None, [], None, []
        async with aiohttp.ClientSession() as ses:
            url = f"https://api.battlemetrics.com/players?filter[search]={sid}"
            async with ses.get(url, headers=BM_HEADERS) as r:
                data = await r.json()
        if not data.get("data"):
            return None, [], None, []
        prof = data["data"][0]
        pid  = prof["id"]
        async with aiohttp.ClientSession() as ses:
            url = (f"https://api.battlemetrics.com/bans?"
                   f"filter[player]={pid}&sort=-timestamp")
            async with ses.get(url, headers=BM_HEADERS) as r:
                bans = (await r.json()).get("data", [])
        flags = prof["attributes"].get("flags", [])
        eac   = any("eac" in (f or "").lower() for f in flags)
        names = [n.get("name", "Unknown")
                 for n in prof["attributes"].get("names", [])[::-1]]
        return prof, bans, eac, names

    async def _bm_sessions(self, pid: str):
        url = ("https://api.battlemetrics.com/sessions?"
               f"filter[player]={pid}&page[size]=100&include=server&sort=-start")
        async with aiohttp.ClientSession() as ses, ses.get(url, headers=BM_HEADERS) as r:
            data = await r.json()
        sess = data.get("data", [])
        srv_name = {i["id"]: i["attributes"]["name"]
                    for i in data.get("included", [])
                    if i["type"] == "server"}
        online = False
        current = None
        if sess and sess[0]["attributes"]["end"] is None:
            online = True
            sid = sess[0]["relationships"]["server"]["data"]["id"]
            current = srv_name.get(sid, "Unknown")
        return sess, online, current, len(sess), []

    async def _level_games_friends(self, sid: str):
        lvl = games = friends = None
        g_list = []
        async with aiohttp.ClientSession() as ses:
            try:
                async with ses.get(
                    "https://api.steampowered.com/IPlayerService/"
                    f"GetSteamLevel/v1/?key={STEAM_API_KEY}&steamid={sid}"
                ) as r:
                    lvl = (await r.json())["response"].get("player_level")
            except: pass
            try:
                async with ses.get(
                    "https://api.steampowered.com/IPlayerService/"
                    f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}"
                    "&include_appinfo=1"
                ) as r:
                    data = await r.json()
                    games  = data["response"].get("game_count")
                    g_list = data["response"].get("games", [])
            except: pass
            try:
                async with ses.get(
                    "https://api.steampowered.com/ISteamUser/"
                    f"GetFriendList/v1/?key={STEAM_API_KEY}&steamid={sid}"
                ) as r:
                    friends = len((await r.json())
                                  .get("friendslist", {}).get("friends", []))
            except: pass
        g_list.sort(key=lambda x: x.get("playtime_forever", 0), reverse=True)
        top_games = [{"name": g["name"],
                      "playtime": g["playtime_forever"] // 60}
                     for g in g_list[:5]]
        return lvl, games, friends, top_games

    async def _rust_hours(self, sid: str):
        async with aiohttp.ClientSession() as ses:
            try:
                url = ("https://api.steampowered.com/IPlayerService/"
                       f"GetOwnedGames/v1/?key={STEAM_API_KEY}&steamid={sid}")
                async with ses.get(url) as r:
                    og = await r.json()
                for g in og["response"]["games"]:
                    if g["appid"] == APPID_RUST:
                        return (g["playtime_forever"] // 60,
                                g.get("playtime_2weeks", 0) // 60)
            except: pass
        return None, None

    async def _profile_comments(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                url = f"https://steamcommunity.com/profiles/{sid}/allcomments?xml=1"
                async with ses.get(url) as r:
                    text = await r.text()
            comments = re.findall(
                r"<comment thread='[^']+'>(.*?)</comment>",
                text, re.DOTALL)
            return [re.sub("<.*?>", "", c).strip()
                    for c in comments if c.strip()]
        except: return []

    async def _rustbans_info(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                async with ses.get(
                    f"https://rustbans.com/api/v2/ban/{sid}"
                ) as r:
                    if r.status == 200:
                        data = await r.json()
                        if data.get("banned"):
                            return ("Banned",
                                    data.get("reason"),
                                    data.get("timestamp", "")[:10])
        except: pass
        return None, None, None

    async def _steamrep_info(self, sid: str):
        try:
            async with aiohttp.ClientSession() as ses:
                async with ses.get(
                    f"https://steamrep.com/api/beta4/reputation/{sid}?json=1"
                ) as r:
                    if r.status == 200:
                        data = await r.json()
                        if data.get("reputation", {}).get("summary"):
                            return data["reputation"]["summary"]
        except: pass
        return None

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LONG _rust_stats helper (exactly as supplied) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def _rust_stats(self, sid: str):
        """
        Return (ok: bool, stats: dict[str,int])
        Implements every rule from the specification you supplied.
        """
        async with aiohttp.ClientSession() as ses:
            url = ("https://api.steampowered.com/ISteamUserStats/"
                   f"GetUserStatsForGame/v2/?key={STEAM_API_KEY}&steamid={sid}&appid={APPID_RUST}")
            async with ses.get(url) as r:
                data = await r.json()

        raw_list = data.get("playerstats", {}).get("stats")
        if not raw_list:
            return False, {}
        raw = {s["name"]: s["value"] for s in raw_list}

        # helpers
        def _sum_prefix(pre: str) -> int:
            return sum(v for k, v in raw.items() if k.startswith(pre))

        def get(*vars: str, _sum=False, _scale=1):
            if _sum:
                tot = 0
                for v in vars:
                    tot += _sum_prefix(v[:-1]) if v.endswith("*") else raw.get(v, 0)
                return int(tot / _scale)
            for v in vars:
                val = _sum_prefix(v[:-1]) if v.endswith("*") else raw.get(v, 0)
                if val:
                    return int(val / _scale)
            return 0

        # combat
        bullets_fired = get("bullet_fired") + get("shotgun_fired")
        bullets_hit   = get("bullet_hit_*", "shotgun_hit_*", _sum=True)
        arrows_fired  = get("arrow_fired", "arrows_shot")
        arrows_hit    = get("arrow_hit_*", _sum=True)
        headshots     = get("headshot", "headshots")
        kills_player  = get("kill_player")
        deaths_player = get("death_player", "deaths")

        stats = {
            "kill_scientist": get("kill_scientist"),
            "kill_bear":      get("kill_bear"),
            "kill_wolf":      get("kill_wolf"),
            "kill_boar":      get("kill_boar"),
            "kill_deer":      get("kill_stag"),
            "kill_horse":     get("horse_mounted_count"),
            "death_suicide":  get("death_suicide", "death_selfinflicted"),
            "death_fall":     get("death_fall"),
        }

        # resources â€“ nodes
        stats.update({
            "harvest_wood":   get("harvested_wood",  "harvest.wood"),
            "harvest_stones": get("harvested_stones","harvest.stones"),
            "harvest_metal_ore": get("acquired_metal.ore",
                                      "harvest.metal_ore", _sum=True),
            "harvest_hq_metal_ore": 0,
            "harvest_sulfur_ore":    0,
        })

        # resources â€“ pick-ups
        stats.update({
            "acq_lowgrade": get("acquired_lowgradefuel"),
            "acq_scrap":    get("acquired_scrap"),
            "acq_cloth":    get("harvested_cloth","acquired_cloth","acquired_cloth.item"),
            "acq_leather":  get("harvested_leather","acquired_leather","acquired_leather.item"),
        })

        # building / loot / social
        stats.update({
            "build_place":   get("placed_blocks","building_blocks_placed",
                                 "buildings_placed","structure_built"),
            "build_upgrade": get("upgraded_blocks","building_blocks_upgraded",
                                 "buildings_upgraded","structure_upgrade"),
            "barrels":       get("destroyed_barrels","destroyed_barrel*", _sum=True),
            "bps":           get("blueprint_studied"),
            "pipes":         get("pipes_connected"),
            "wires":         get("wires_connected","tincanalarms_wired"),
            "waves":         get("gesture_wave_count","waved_at_players","gesture_wave"),
        })

        metres = get("horse_distance_ridden", _sum=True)
        km     = get("horse_distance_ridden_km")
        miles  = (metres / 1609.344) if metres else (km * 0.621371)
        stats.update({
            "horse_miles":   int(miles),
            "horses_ridden": get("horse_mounted_count"),
            "calories":      get("calories_consumed"),
            "water":         get("water_consumed"),
            "map_open":      get("MAP_OPENED","map_opened","map_open"),
            "inv_open":      get("INVENTORY_OPENED","inventory_opened"),
            "items_crafted": get("CRAFTING_OPENED","items_crafted","crafted_items"),
        })

        # core combat numbers
        stats.update({
            "shots_fired":   bullets_fired,
            "shots_hit":     bullets_hit,
            "arrow_fired":   arrows_fired,
            "arrow_hit":     arrows_hit,
            "headshot_hits": headshots,
            "kill_player":   kills_player,
            "death_player":  deaths_player,
        })

        return True, stats

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#            public entry-point
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db=None):
    await bot.add_cog(StatsCog(bot))


FILE: cogs\stay_or_go.py
----------------------------------------
# cogs/stay_or_go.py

from __future__ import annotations

import discord
from discord.ext import commands

from db import Database

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Configurable â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
CHANNEL_ID = 1378080948259786782  # Set your desired channel ID here
ROLE_NAME = "Staying Role"
EMBED_TITLE = "âš ï¸ Do you wish to stick around after the cleanup? âš ï¸"
EMBED_DESCRIPTION = (
    "We're cleaning up inactive members soon.\n"
    "If you wish to remain active and not be kicked, please click the âœ… below.\n"
    "This will give you the **Staying Role** and protect your account!"
)
REACTION_EMOJI = "âœ…"
GUILD_ID = 1377035207777194005  # Your guild ID
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


class StayOrGo(commands.Cog):
    def __init__(self, bot: commands.Bot, db: Database):
        self.bot = bot
        self.db = db
        self.target_channel = None
        self.stay_role = None
        self.message = None
        self.active = False

    async def cog_load(self) -> None:
        # Don't do channel setup here, wait for on_ready
        pass

    @commands.Cog.listener()
    async def on_ready(self):
        """Setup channel and role when bot is fully ready"""
        if self.target_channel is not None:  # Already setup
            return
            
        print(f"[stay_or_go] Setting up... Guild ID: {GUILD_ID}, Channel ID: {CHANNEL_ID}")
        
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            print(f"[stay_or_go] Could not find guild {GUILD_ID}")
            return
            
        print(f"[stay_or_go] Found guild: {guild.name}")
        
        # List all channels for debugging
        print(f"[stay_or_go] Available channels in guild:")
        for channel in guild.channels:
            print(f"  - {channel.name} ({channel.id}) - Type: {type(channel)}")
            
        self.target_channel = guild.get_channel(CHANNEL_ID)
        if not self.target_channel:
            print(f"[stay_or_go] Could not find target channel {CHANNEL_ID} using get_channel")
            # Try fetching it
            try:
                self.target_channel = await guild.fetch_channel(CHANNEL_ID)
                print(f"[stay_or_go] Successfully fetched channel via fetch_channel")
            except Exception as e:
                print(f"[stay_or_go] Could not fetch channel {CHANNEL_ID}: {e}")
                return

        print(f"[stay_or_go] Found target channel: {self.target_channel.name}")

        self.stay_role = discord.utils.get(guild.roles, name=ROLE_NAME)
        if not self.stay_role:
            try:
                self.stay_role = await guild.create_role(
                    name=ROLE_NAME,
                    reason="Auto-created for stay-or-go system"
                )
                print(f"[stay_or_go] Created role: {ROLE_NAME}")
            except Exception as e:
                print(f"[stay_or_go] Failed to create role {ROLE_NAME}: {e}")
                return
        else:
            print(f"[stay_or_go] Found existing role: {ROLE_NAME}")

    @discord.app_commands.command(name="startstayorgo", description="Start the stay or go system")
    async def start_stay_or_go_command(self, interaction: discord.Interaction):
        # Check admin permissions
        if not (interaction.user.guild_permissions.administrator or 
                interaction.user.id == interaction.guild.owner_id):
            await interaction.response.send_message("You don't have permission to use this command!", ephemeral=True)
            return

        # Make sure setup is complete
        if not self.target_channel:
            await interaction.response.send_message("Bot not fully initialized yet. Please try again in a moment.", ephemeral=True)
            return

        if self.active:
            await interaction.response.send_message("Stay-or-go system is already active!", ephemeral=True)
            return

        # Try to find existing message or create new one
        await self.find_or_create_message()
        self.active = True
        await interaction.response.send_message("Stay-or-go system activated! Message is now live.", ephemeral=True)

    async def find_or_create_message(self):
        """Find existing message or create a new one"""
        if not self.target_channel:
            print("[stay_or_go] No target channel available in find_or_create_message")
            return
            
        # First, try to find existing message by looking through channel history
        try:
            print(f"[stay_or_go] Searching channel {self.target_channel.name} for existing message...")
            async for message in self.target_channel.history(limit=50):
                if (message.author == self.bot.user and 
                    message.embeds and 
                    message.embeds[0].title == EMBED_TITLE):
                    self.message = message
                    print("[stay_or_go] Found existing stay-or-go message")
                    return

            # If not found, create new message
            print("[stay_or_go] Creating new stay-or-go message...")
            embed = discord.Embed(
                title=EMBED_TITLE,
                description=EMBED_DESCRIPTION,
                color=discord.Color.red()
            )
            self.message = await self.target_channel.send(embed=embed)
            await self.message.add_reaction(REACTION_EMOJI)
            print("[stay_or_go] Created new stay-or-go message")
        except Exception as e:
            print(f"[stay_or_go] Error in find_or_create_message: {e}")

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        # Ignore if system not active
        if not self.active:
            return
            
        # Ignore bots
        if payload.member and payload.member.bot:
            return

        # Check if the reaction is on our message and emoji
        if str(payload.emoji) != REACTION_EMOJI:
            return

        # Check if it's the correct message
        if not self.message or payload.message_id != self.message.id:
            return

        guild = self.bot.get_guild(payload.guild_id)
        if not guild:
            return

        member = guild.get_member(payload.user_id)
        if not member:
            return

        # Give role
        if self.stay_role and self.stay_role not in member.roles:
            try:
                await member.add_roles(self.stay_role, reason="User confirmed staying")
                print(f"[stay_or_go] Added {ROLE_NAME} to {member.display_name}")
            except Exception as e:
                print(f"[stay_or_go] Failed to assign role: {e}")

async def setup(bot: commands.Bot, db: Database) -> None:
    cog = StayOrGo(bot, db)
    await bot.add_cog(cog)
    # Register the command with the bot's tree for the guild
    guild = bot.get_guild(GUILD_ID)
    if guild:
        bot.tree.add_command(cog.start_stay_or_go_command, guild=guild)
        print(f"[stay_or_go] Command registered for guild {guild.name}")
    else:
        print(f"[stay_or_go] Could not register command - guild not found")


FILE: cogs\steam_sync.py
----------------------------------------
# cogs/steam_sync.py
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   â€¢ Periodically sync Discord nicknames with Steam names
#   â€¢ /link steam <url>   â†’ users link / update their profile
#   â€¢ /steamsync now      â†’ mods trigger instant sync
#   â€¢ Missing links: silent DM reminder, max once / 24 h
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from __future__ import annotations

import logging
import os
import time
from typing import Optional

import discord
from discord import app_commands
from discord.ext import commands, tasks

# Re-use helpers from member_forms
from cogs.member_forms import (                         # type: ignore
    extract_steam_id,
    get_steam_username,
    is_steam_profile_valid,
    ROLE_PREFIXES,
)

log = logging.getLogger("cog.steam_sync")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GUILD_ID          = int(os.getenv("GUILD_ID", 0))
SYNC_INTERVAL_MIN = int(os.getenv("STEAM_SYNC_MINUTES", 60))          # periodic loop
PING_COOLDOWN_H   = int(os.getenv("STEAM_PING_COOLDOWN_H", 24))       # DM rate-limit

OWNER_ROLE_ID     = 1383201150140022784  # exempt from auto-nick

# staff role-id â†’ suffix
STAFF_SUFFIXES: dict[int, str] = {
    1377077466513932338: " | G L",
    1377084533706588201: " | P M",
    1377103244089622719: " | Admin",
    1410659214959054988: " | Rec",
}
STAR = "*"  # put in prefix to bump in voice

FOCUS_ROLE_IDS = {
    "Farming":      1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building":     1380233086544908428,
    "Electricity":  1380233234675400875,
    "PvP":          1408687710159245362,
}
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class SteamSyncCog(commands.Cog):
    """Automatically keeps nicknames in sync with Steam."""

    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._last_ping: dict[int, float] = {}  # discord_id â†’ last-DM ts
        self.sync_task.start()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /link steam â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    link_group = app_commands.Group(
        name="link", description="Link or update external accounts"
    )

    @link_group.command(name="steam")
    @app_commands.describe(url="Your steamcommunity.com profile URL")
    async def link_steam(self, i: discord.Interaction, url: str):
        """Store or update a member's Steam profile."""
        await i.response.defer(ephemeral=True)

        steam_id = await extract_steam_id(url)
        if not steam_id:
            return await i.followup.send(
                "âŒ I couldnâ€™t read that link. Use the full "
                "`steamcommunity.com/profiles/...` or `/id/...` URL.",
                ephemeral=True,
            )

        if not await is_steam_profile_valid(steam_id):
            return await i.followup.send(
                "âŒ That Steam profile is not public or doesnâ€™t meet the "
                "requirements (â‰¥ 1 game, â‰¥ 1 friend, â‰¥ 1 h play-time).",
                ephemeral=True,
            )

        await self.db.set_steam_id(i.user.id, steam_id)
        await i.followup.send("âœ… Steam account linked!", ephemeral=True)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /steamsync now â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    steamsync_group = app_commands.Group(
        name="steamsync", description="Manually control Steam nickname sync"
    )

    @steamsync_group.command(
        name="now", description="Run the Steam nickname sync immediately"
    )
    async def steamsync_now(self, i: discord.Interaction):
        if not i.user.guild_permissions.manage_guild:
            return await i.response.send_message("No permission.", ephemeral=True)

        await i.response.defer(thinking=True, ephemeral=True)
        await self._sync_once()
        await i.followup.send("âœ… Steam sync finished.", ephemeral=True)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ periodic task â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @tasks.loop(minutes=SYNC_INTERVAL_MIN)
    async def sync_task(self):
        await self._sync_once()

    @sync_task.before_loop
    async def _wait_for_ready(self):
        await self.bot.wait_until_ready()

    # ========== core sync logic (used by task & /now) ==========
    async def _sync_once(self):
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        for member in guild.members:
            if member.bot or member.get_role(OWNER_ROLE_ID):
                continue

            steam_id: Optional[str] = await self.db.get_steam_id(member.id)
            if not steam_id:
                await self._remind_link(member)
                continue

            steam_name = await get_steam_username(steam_id)
            if not steam_name:
                await self._remind_link(member)
                continue

            target_nick = self._build_nickname(member, steam_name)
            if member.nick != target_nick:
                try:
                    await member.edit(nick=target_nick, reason="SteamSync")
                except (discord.Forbidden, discord.HTTPException):
                    pass  # no perms or hierarchy issue

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helper: DM reminder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _remind_link(self, member: discord.Member):
        """DM the member at most once every PING_COOLDOWN_H hours (persistent)."""
        last_dt = await self.db.get_last_steam_ping(member.id)
        if last_dt:
            elapsed_h = (discord.utils.utcnow() - last_dt).total_seconds() / 3600
            if elapsed_h < PING_COOLDOWN_H:
                return  # still on cooldown

        try:
            await member.send(
                "Hi! I can't find a valid Steam profile linked to your account "
                "on the server. Please use the </link steam:â€¦> command there "
                "to add or update it. Thanks!"
            )
            await self.db.set_last_steam_ping(member.id)  # record successful DM
        except discord.Forbidden:
            # DMs disabled â†’ we still record the attempt so we don't spam publicly
            await self.db.set_last_steam_ping(member.id)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helper: nick builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _build_nickname(self, member: discord.Member, steam_name: str) -> str:
        # focus prefix
        prefix = ""
        for focus, role_id in FOCUS_ROLE_IDS.items():
            if member.get_role(role_id):
                prefix = ROLE_PREFIXES.get(focus, "")
                break

        # star for staff
        if any(member.get_role(rid) for rid in STAFF_SUFFIXES):
            if prefix.startswith("[") and not prefix.startswith("[*"):
                prefix = prefix.replace("[", "[*", 1)

        # staff suffix
        suffix = ""
        for rid, txt in STAFF_SUFFIXES.items():
            if member.get_role(rid):
                suffix = txt
                break

        nick = f"{prefix} {steam_name}{suffix}".strip()
        return nick[:32]  # Discord limit

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db):
    await bot.add_cog(SteamSyncCog(bot, db))


FILE: cogs\todo.py
----------------------------------------
# cogs/todo.py â€“ Server-wide To-Do list
# Works with discord.py â‰¥ 2.3  (persistent buttons)
# -----------------------------------------------------------------------

from __future__ import annotations

import asyncio
import contextlib
import logging
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

import discord
from discord import app_commands
from discord.ext import commands

log = logging.getLogger("cog.todo")
log.setLevel(logging.INFO)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GUILD_ID        = 1377035207777194005
TODO_CH_ID      = 1422698527342989322
MAX_CLAIMS_CAP  = 3         # slots per task
DAILY_USER_CAP  = 3         # max open claims / user
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TodoCog(commands.Cog):
    """/todo commands, task embeds & claim / complete buttons."""

    todo_group = app_commands.Group(name="todo", description="Server To-Do list")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self._started = False          # ensure on_ready runs once

    @commands.Cog.listener()
    async def on_ready(self):
        if self._started:
            return
        self._started = True

        # wait for DB pool created by the core bot
        while self.db.pool is None:
            await asyncio.sleep(0.5)

        # add the `title` column once (ignored if exists)
        await self.db.pool.execute(
            "ALTER TABLE todo_tasks ADD COLUMN IF NOT EXISTS title TEXT"
        )

        await self._initial_sync()
        log.info("TodoCog initialised")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _embed(self, row: Dict[str, Any]) -> discord.Embed:
        title = row.get("title") or f"ğŸ“ Task #{row['id']}"
        e = discord.Embed(
            title=title,
            description=row["description"],
            colour=discord.Color.orange(),
            timestamp=row.get("created_at", datetime.now(timezone.utc)),
        )
        if row["max_claims"]:
            claimers = ", ".join(f"<@{u}>" for u in row["claimed"]) or "*None*"
            e.add_field(
                name=f"Claims ({len(row['claimed'])}/{row['max_claims']})",
                value=claimers,
                inline=False,
            )
            e.set_footer(text="Claimable task")
        else:
            e.set_footer(text="Global task â€“ everyone can help")
        return e

    async def _refresh_msg(self, guild: discord.Guild, task_id: int):
        """
        Create / update / delete the message for one task and attach a
        persistent TaskView.
        """
        row = await self.db.pool.fetchrow(
            "SELECT * FROM todo_tasks WHERE id=$1", task_id
        )
        if not row:
            return
        row = dict(row)

        ch = guild.get_channel(TODO_CH_ID)
        if not isinstance(ch, discord.TextChannel):
            return

        try:
            msg = await ch.fetch_message(row["message_id"])
        except (discord.NotFound, discord.HTTPException):
            msg = None

        if row["completed"]:
            if msg:
                with contextlib.suppress(discord.Forbidden):
                    await msg.delete()
            return

        view = TaskView(self, task_id, row["max_claims"] > 0)

        if msg is None:
            msg = await ch.send(embed=await self._embed(row), view=view)
            await self.db.pool.execute(
                "UPDATE todo_tasks SET message_id=$1 WHERE id=$2",
                msg.id, task_id
            )
        else:
            await msg.edit(embed=await self._embed(row), view=view)

        # Register the view as persistent so it works after restarts
        self.bot.add_view(view, message_id=msg.id)

    async def _initial_sync(self):
        """Refresh every still-open task when the bot starts."""
        guild = self.bot.get_guild(GUILD_ID)
        if not guild:
            return

        rows: List[Dict[str, Any]] = await self.db.list_open_todos(guild.id)
        for r in rows:
            await self._refresh_msg(guild, r["id"])

        log.info("[todo] initial sync finished â€“ %s open tasks", len(rows))

    # â•â•â•â•â•â•â•â•â•â•â• SLASH COMMANDS â•â•â•â•â•â•â•â•â•â•â•â•
    # /todo add ------------------------------------------------------
    @todo_group.command(name="add", description="Create a new task (staff only)")
    @app_commands.describe(
        title="Short title",
        description="Task details / instructions",
        claimable_slots=f"0 = global â€¢ 1-{MAX_CLAIMS_CAP} = claimable slots",
    )
    async def todo_add(
        self,
        inter: discord.Interaction,
        title: str,
        description: str,
        claimable_slots: app_commands.Range[int, 0, MAX_CLAIMS_CAP] = 0,
    ):
        if not inter.user.guild_permissions.manage_guild:
            return await inter.response.send_message("Staff only.", ephemeral=True)

        ch = inter.guild.get_channel(TODO_CH_ID)
        if not isinstance(ch, discord.TextChannel):
            return await inter.response.send_message("Todo channel missing.", ephemeral=True)

        await inter.response.defer(ephemeral=True)

        placeholder = await ch.send(embed=discord.Embed(
            title="Creating task â€¦", description=description, colour=discord.Color.orange()
        ))

        await self.db.pool.execute(
            """
            INSERT INTO todo_tasks
                  (guild_id, creator_id, title, description,
                   max_claims, message_id)
            VALUES ($1,$2,$3,$4,$5,$6)
            """,
            inter.guild.id, inter.user.id, title, description,
            claimable_slots, placeholder.id,
        )
        task_id = await self.db.pool.fetchval(
            "SELECT id FROM todo_tasks WHERE message_id=$1", placeholder.id
        )

        await self._refresh_msg(inter.guild, task_id)
        await inter.followup.send(f"Task **#{task_id}** added.", ephemeral=True)

    # /todo list -----------------------------------------------------
    @todo_group.command(name="list", description="Show all open tasks")
    async def todo_list(self, inter: discord.Interaction):
        rows = await self.db.list_open_todos(inter.guild.id)
        if not rows:
            return await inter.response.send_message("No open tasks â€“ ğŸ‰", ephemeral=True)

        txt = "\n".join(
            f"â€¢ **#{r['id']}** â€“ {r.get('title') or r['description']}"
            for r in rows
        )
        await inter.response.send_message(txt[:1990], ephemeral=True)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VIEW (persistent buttons) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TaskView(discord.ui.View):
    def __init__(self, cog: TodoCog, task_id: int, claimable: bool):
        super().__init__(timeout=None)
        self.cog, self.task_id, self.claimable = cog, task_id, claimable

        if not claimable:
            for child in self.children:
                if child.custom_id in {"todo_claim", "todo_unclaim"}:
                    child.disabled = True

    # helper
    async def _ack(self, inter: discord.Interaction, msg: str):
        await self.cog._refresh_msg(inter.guild, self.task_id)
        await inter.followup.send(msg, ephemeral=True)

    # ---- Claim -----------------------------------------------------
    @discord.ui.button(
        label="Claim", style=discord.ButtonStyle.primary,
        emoji="ğŸ™‹", custom_id="todo_claim"
    )
    async def claim(self, inter: discord.Interaction, _):
        await inter.response.defer(ephemeral=True)
        if not self.claimable:
            return await self._ack(inter, "Global task â€“ can't claim.")

        ok = await self.cog.db.pool.fetchval(
            """
            UPDATE todo_tasks
               SET claimed = array_append(claimed, $2::bigint)
             WHERE id=$1
               AND NOT claimed @> ARRAY[$2::bigint]
               AND coalesce(array_length(claimed,1),0) < max_claims
             RETURNING TRUE
            """,
            self.task_id, inter.user.id,
        )
        if not ok:
            return await self._ack(inter, "Already claimed or slots full.")

        # user cap check
        if await self.cog.db.count_open_claims(inter.guild.id, inter.user.id) > DAILY_USER_CAP:
            await self.cog.db.pool.execute(
                "UPDATE todo_tasks "
                "SET claimed = array_remove(claimed,$2::bigint) "
                "WHERE id=$1",
                self.task_id, inter.user.id,
            )
            return await self._ack(inter, f"Claim limit ({DAILY_USER_CAP}) reached â€“ reverted.")

        await self._ack(inter, "Claimed!")

    # ---- Unclaim ---------------------------------------------------
    @discord.ui.button(
        label="Unclaim", style=discord.ButtonStyle.secondary,
        emoji="â†©ï¸", custom_id="todo_unclaim"
    )
    async def unclaim(self, inter: discord.Interaction, _):
        await inter.response.defer(ephemeral=True)
        if not self.claimable:
            return await self._ack(inter, "Global task â€“ can't claim.")

        await self.cog.db.pool.execute(
            "UPDATE todo_tasks "
            "SET claimed = array_remove(claimed,$2::bigint) "
            "WHERE id=$1",
            self.task_id, inter.user.id,
        )
        await self._ack(inter, "Unclaimed.")

    # ---- Complete --------------------------------------------------
    @discord.ui.button(
        label="Complete", style=discord.ButtonStyle.success,
        emoji="âœ…", custom_id="todo_complete"
    )
    async def complete(self, inter: discord.Interaction, _):
        await inter.response.defer(ephemeral=True)
        if not inter.user.guild_permissions.manage_guild:
            return await self._ack(inter, "Staff only.")

        await self.cog.db.complete_todo(self.task_id)
        await self._ack(inter, "Task completed!")


# â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry-point â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot, db):
    await bot.add_cog(TodoCog(bot, db))


FILE: cogs\warnings.py
----------------------------------------
# cogs/warnings.py
import discord
from discord.ext import commands, tasks
from typing import Optional
import logging
from datetime import datetime, timedelta
import json
import os
import io
import csv

# Create data directory if it doesn't exist
DATA_DIR = "data"
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)

WARNINGS_FILE = os.path.join(DATA_DIR, "warnings.json")
CONFIG_FILE = os.path.join(DATA_DIR, "warning_config.json")

class WarningSystem(commands.Cog):
    def __init__(self, bot, db=None):
        self.bot = bot
        self.warnings = self._load_warnings()
        self.config = self._load_config()
        
    def _load_warnings(self):
        """Load warnings from JSON file"""
        try:
            if os.path.exists(WARNINGS_FILE):
                with open(WARNINGS_FILE, 'r') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            logging.error(f"Error loading warnings: {e}")
            return {}
    
    def _save_warnings(self):
        """Save warnings to JSON file"""
        try:
            with open(WARNINGS_FILE, 'w') as f:
                json.dump(self.warnings, f, indent=2, default=str)
        except Exception as e:
            logging.error(f"Error saving warnings: {e}")
    
    def _load_config(self):
        """Load config from JSON file"""
        try:
            if os.path.exists(CONFIG_FILE):
                with open(CONFIG_FILE, 'r') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            logging.error(f"Error loading config: {e}")
            return {}
    
    def _save_config(self):
        """Save config to JSON file"""
        try:
            with open(CONFIG_FILE, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            logging.error(f"Error saving config: {e}")
    
    async def cog_load(self):
        """Initialize the cog"""
        # Start expiration checker
        self.check_expired_warnings.start()
    
    async def cog_unload(self):
        """Clean up when cog is unloaded"""
        if hasattr(self, 'check_expired_warnings') and self.check_expired_warnings.is_running():
            self.check_expired_warnings.cancel()
        self._save_warnings()
        self._save_config()
    
    @tasks.loop(hours=1)
    async def check_expired_warnings(self):
        """Check for expired warnings and mark them as expired"""
        try:
            now = datetime.utcnow()
            changed = False
            
            for guild_id, guild_warnings in self.warnings.items():
                for warning in guild_warnings:
                    if warning.get('expiry_date'):
                        try:
                            expiry = datetime.fromisoformat(warning['expiry_date'])
                            if expiry <= now and not warning.get('expired', False):
                                warning['expired'] = True
                                changed = True
                                
                                # Log expiration if log channel exists
                                guild = self.bot.get_guild(int(guild_id))
                                if guild:
                                    config = self.config.get(guild_id, {})
                                    if config.get('log_channel_id'):
                                        channel = guild.get_channel(config['log_channel_id'])
                                        if channel:
                                            user = guild.get_member(warning['user_id'])
                                            if user:
                                                try:
                                                    await channel.send(
                                                        f"Warning #{warning['case_id']} for {user.mention} "
                                                        f"has expired automatically."
                                                    )
                                                except Exception:
                                                    pass  # Ignore channel send errors
                        except ValueError:
                            # Handle invalid date format
                            pass
            
            if changed:
                self._save_warnings()
                
        except Exception as e:
            logging.error(f"Error checking expired warnings: {e}")
    
    def _get_next_case_id(self, guild_id: str):
        """Get next case ID for a guild"""
        try:
            guild_warnings = self.warnings.get(guild_id, [])
            if not guild_warnings:
                return 1
            return max(w['case_id'] for w in guild_warnings) + 1
        except Exception as e:
            logging.error(f"Failed to get next case ID: {e}")
            return 1
    
    def _get_guild_config(self, guild_id: str):
        """Get guild configuration"""
        return self.config.get(guild_id, {})
    
    def _log_warning(self, user_id: int, moderator_id: int, guild_id: int, 
                    reason: str, case_id: int, timestamp: datetime, warning_type: str = "general"):
        """Log warning to storage"""
        try:
            guild_id_str = str(guild_id)
            if guild_id_str not in self.warnings:
                self.warnings[guild_id_str] = []
            
            warning = {
                'id': len(self.warnings[guild_id_str]) + 1,
                'user_id': user_id,
                'moderator_id': moderator_id,
                'guild_id': guild_id,
                'reason': reason,
                'case_id': case_id,
                'timestamp': timestamp.isoformat(),
                'warning_type': warning_type,
                'appeal_text': None,
                'appeal_status': 'none',
                'expiry_date': None,
                'expired': False
            }
            
            self.warnings[guild_id_str].append(warning)
            self._save_warnings()
            return True
        except Exception as e:
            logging.error(f"Failed to log warning: {e}")
            return False
    
    def _get_warnings(self, user_id: int, guild_id: int, active_only: bool = True):
        """Get warnings for a user"""
        try:
            guild_id_str = str(guild_id)
            if guild_id_str not in self.warnings:
                return []
            
            user_warnings = [w for w in self.warnings[guild_id_str] if w['user_id'] == user_id]
            
            if active_only:
                user_warnings = [w for w in user_warnings if not w.get('expired', False)]
            
            # Sort by timestamp descending
            user_warnings.sort(key=lambda x: x['timestamp'], reverse=True)
            return user_warnings
        except Exception as e:
            logging.error(f"Failed to fetch warnings: {e}")
            return []
    
    def _get_warning_by_case(self, case_id: int, guild_id: int):
        """Get a specific warning by case ID"""
        try:
            guild_id_str = str(guild_id)
            if guild_id_str not in self.warnings:
                return None
            
            for warning in self.warnings[guild_id_str]:
                if warning['case_id'] == case_id:
                    return warning
            return None
        except Exception as e:
            logging.error(f"Failed to fetch warning by case ID: {e}")
            return None
    
    async def _log_mod_action(self, guild_id: int, action: str, moderator_id: int, 
                             target_id: int, reason: str, case_id: Optional[int] = None):
        """Log moderation action to channel"""
        config = self._get_guild_config(str(guild_id))
        if not config.get('log_channel_id'):
            return
            
        guild = self.bot.get_guild(guild_id)
        if not guild:
            return
            
        channel = guild.get_channel(config['log_channel_id'])
        if not channel:
            return
            
        moderator = guild.get_member(moderator_id)
        target = guild.get_member(target_id)
        
        if not moderator or not target:
            return
            
        embed = discord.Embed(
            title=f"Moderation Action: {action}",
            color=discord.Color.orange(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Moderator", value=f"{moderator} ({moderator_id})", inline=False)
        embed.add_field(name="User", value=f"{target} ({target_id})", inline=False)
        embed.add_field(name="Reason", value=reason, inline=False)
        if case_id:
            embed.add_field(name="Case ID", value=f"#{case_id}", inline=False)
            
        try:
            await channel.send(embed=embed)
        except Exception as e:
            logging.error(f"Failed to log mod action: {e}")
    
    @commands.hybrid_command(name="warn")
    @commands.has_permissions(manage_messages=True)
    @commands.bot_has_permissions(manage_roles=True)
    async def warn_user(self, ctx, member: discord.Member, 
                       warning_type: str = "general", *, reason: str = "No reason provided"):
        """Warn a user with a reason"""
        if member == ctx.author:
            await ctx.send("You cannot warn yourself!", ephemeral=True)
            return
    
        if member.bot:
            await ctx.send("You cannot warn a bot!", ephemeral=True)
            return
    
        # Create case ID
        guild_id_str = str(ctx.guild.id)
        case_id = self._get_next_case_id(guild_id_str)
        
        # Log warning
        success = self._log_warning(
            user_id=member.id,
            moderator_id=ctx.author.id,
            guild_id=ctx.guild.id,
            reason=reason,
            case_id=case_id,
            timestamp=ctx.message.created_at,
            warning_type=warning_type
        )
    
        if not success:
            await ctx.send("Failed to log warning. Please try again.", ephemeral=True)
            return
    
        # Send DM to warned user
        dm_success = True
        config = self._get_guild_config(guild_id_str)
        if config.get('dm_users', True):
            try:
                embed = discord.Embed(
                    title="âš ï¸ You have been warned",
                    description=f"You received a warning in **{ctx.guild.name}**",
                    color=discord.Color.red(),
                    timestamp=ctx.message.created_at
                )
                embed.add_field(name="Type", value=warning_type.title(), inline=False)
                embed.add_field(name="Reason", value=reason, inline=False)
                embed.add_field(name="Case ID", value=f"`#{case_id}`", inline=False)
                embed.set_footer(text="Please follow server rules to avoid further action")
                
                await member.send(embed=embed)
            except discord.Forbidden:
                dm_success = False
    
        # Confirmation message
        embed = discord.Embed(
            title="User Warned",
            description=f"{member.mention} has been warned",
            color=discord.Color.orange(),
            timestamp=ctx.message.created_at
        )
        embed.add_field(name="Type", value=warning_type.title(), inline=False)
        embed.add_field(name="Reason", value=reason, inline=False)
        embed.add_field(name="Case ID", value=f"`#{case_id}`", inline=False)
        embed.add_field(name="User", value=f"{member} ({member.id})", inline=False)
        embed.add_field(name="Moderator", value=f"{ctx.author} ({ctx.author.id})", inline=False)
        if not dm_success:
            embed.set_footer(text="âš ï¸ Could not DM user")
        
        await ctx.send(embed=embed)
        
        # Log action
        await self._log_mod_action(
            ctx.guild.id, "Warning", ctx.author.id, member.id, 
            f"{warning_type}: {reason}", case_id
        )
    
    @commands.hybrid_command(name="warnings")
    @commands.has_permissions(manage_messages=True)
    async def list_warnings(self, ctx, member: Optional[discord.Member] = None, 
                           include_expired: bool = False):
        """List warnings for a user"""
        target = member or ctx.author
        warnings = self._get_warnings(target.id, ctx.guild.id, active_only=not include_expired)
        
        if not warnings:
            status = " (including expired)" if include_expired else ""
            await ctx.send(f"{target.mention} has no warnings{status}.")
            return
    
        embed = discord.Embed(
            title=f"Warnings for {target}",
            color=discord.Color.orange()
        )
        
        warning_count = len(warnings)
        for i, warning in enumerate(warnings[:10]):  # Show only last 10 warnings
            moderator = ctx.guild.get_member(warning['moderator_id']) or "Unknown"
            expired_text = " (Expired)" if warning.get('expired') else ""
            appeal_status = f" ({warning['appeal_status'].title()})" if warning['appeal_status'] != 'none' else ""
            
            try:
                timestamp = datetime.fromisoformat(warning['timestamp'])
                timestamp_str = timestamp.strftime('%Y-%m-%d %H:%M:%S')
            except ValueError:
                timestamp_str = warning['timestamp']
            
            embed.add_field(
                name=f"Case #{warning['case_id']}{expired_text}{appeal_status}",
                value=f"**Type:** {warning['warning_type'].title()}\n"
                      f"**Reason:** {warning['reason']}\n"
                      f"**Moderator:** {moderator}\n"
                      f"**Date:** {timestamp_str}",
                inline=False
            )
        
        if warning_count > 10:
            embed.set_footer(text=f"Showing 10 of {warning_count} warnings")
        else:
            embed.set_footer(text=f"Total: {warning_count} warning(s)")
            
        await ctx.send(embed=embed)
    
    @commands.hybrid_command(name="delwarn")
    @commands.has_permissions(administrator=True)
    async def delete_warning(self, ctx, case_id: int):
        """Permanently delete a specific warning by case ID"""
        guild_id_str = str(ctx.guild.id)
        warning = self._get_warning_by_case(case_id, ctx.guild.id)
        if not warning:
            await ctx.send("No warning found with that case ID.", ephemeral=True)
            return
    
        try:
            # Remove warning from list
            if guild_id_str in self.warnings:
                self.warnings[guild_id_str] = [
                    w for w in self.warnings[guild_id_str] 
                    if w['case_id'] != case_id
                ]
                self._save_warnings()
                
            await ctx.send(f"Warning case #{case_id} has been permanently deleted.")
            
            # Log action
            await self._log_mod_action(
                ctx.guild.id, "Warning Deletion", ctx.author.id, 
                warning['user_id'], f"Deleted case #{case_id}", case_id
            )
        except Exception as e:
            logging.error(f"Failed to delete warning: {e}")
            await ctx.send("An error occurred while deleting the warning.", ephemeral=True)
    
    @commands.hybrid_command(name="clearwarns")
    @commands.has_permissions(administrator=True)
    async def clear_warnings(self, ctx, member: discord.Member):
        """Clear all warnings for a user"""
        try:
            guild_id_str = str(ctx.guild.id)
            if guild_id_str in self.warnings:
                initial_count = len(self.warnings[guild_id_str])
                self.warnings[guild_id_str] = [
                    w for w in self.warnings[guild_id_str] 
                    if w['user_id'] != member.id
                ]
                self._save_warnings()
                
                deleted_count = initial_count - len(self.warnings[guild_id_str])
            else:
                deleted_count = 0
                
            await ctx.send(f"Cleared {deleted_count} warning(s) for {member.mention}.")
            
            # Log action
            await self._log_mod_action(
                ctx.guild.id, "Warnings Cleared", ctx.author.id, 
                member.id, f"Cleared {deleted_count} warnings"
            )
        except Exception as e:
            logging.error(f"Failed to clear warnings: {e}")
            await ctx.send("An error occurred while clearing warnings.", ephemeral=True)
    
    @commands.hybrid_command(name="warncount")
    @commands.has_permissions(manage_messages=True)
    async def warn_count(self, ctx, member: Optional[discord.Member] = None):
        """Show warning count for a user"""
        target = member or ctx.author
        warnings = self._get_warnings(target.id, ctx.guild.id)
        
        embed = discord.Embed(
            title=f"Warning Summary for {target}",
            color=discord.Color.orange()
        )
        embed.add_field(name="Active Warnings", value=str(len(warnings)), inline=True)
        embed.add_field(name="User ID", value=str(target.id), inline=True)
        embed.set_thumbnail(url=target.display_avatar.url)
        
        await ctx.send(embed=embed)
    
    @commands.hybrid_command(name="editwarn")
    @commands.has_permissions(manage_messages=True)
    async def edit_warning(self, ctx, case_id: int, *, new_reason: str):
        """Edit the reason for a warning"""
        guild_id_str = str(ctx.guild.id)
        warning = self._get_warning_by_case(case_id, ctx.guild.id)
        if not warning:
            await ctx.send("No warning found with that case ID.", ephemeral=True)
            return
    
        try:
            # Update warning reason
            if guild_id_str in self.warnings:
                for w in self.warnings[guild_id_str]:
                    if w['case_id'] == case_id:
                        w['reason'] = new_reason
                        break
                self._save_warnings()
            
            await ctx.send(f"Warning case #{case_id} reason updated.")
            
            # Log action
            await self._log_mod_action(
                ctx.guild.id, "Warning Edit", ctx.author.id, 
                warning['user_id'], f"Changed reason to: {new_reason}", case_id
            )
        except Exception as e:
            logging.error(f"Failed to edit warning: {e}")
            await ctx.send("An error occurred while editing the warning.", ephemeral=True)
    
    @commands.hybrid_command(name="expirewarn")
    @commands.has_permissions(manage_messages=True)
    async def expire_warning(self, ctx, case_id: int, days: int = 30):
        """Set a warning to expire after specified days"""
        guild_id_str = str(ctx.guild.id)
        warning = self._get_warning_by_case(case_id, ctx.guild.id)
        if not warning:
            await ctx.send("No warning found with that case ID.", ephemeral=True)
            return
            
        expiry_date = datetime.utcnow() + timedelta(days=days)
        
        try:
            # Update warning expiry date
            if guild_id_str in self.warnings:
                for w in self.warnings[guild_id_str]:
                    if w['case_id'] == case_id:
                        w['expiry_date'] = expiry_date.isoformat()
                        break
                self._save_warnings()
            
            await ctx.send(f"Warning #{case_id} will expire in {days} days.")
            
            # Log action
            await self._log_mod_action(
                ctx.guild.id, "Warning Expiry Set", ctx.author.id, 
                warning['user_id'], f"Set to expire in {days} days", case_id
            )
        except Exception as e:
            logging.error(f"Failed to set expiry: {e}")
            await ctx.send("Failed to set expiry date.", ephemeral=True)
    
    @commands.hybrid_command(name="appeal")
    async def appeal_warning(self, ctx, case_id: int, *, appeal_text: str):
        """Appeal a warning"""
        guild_id_str = str(ctx.guild.id)
        warning = self._get_warning_by_case(case_id, ctx.guild.id)
        if not warning:
            await ctx.send("No warning found with that case ID.", ephemeral=True)
            return
            
        if warning['user_id'] != ctx.author.id:
            await ctx.send("You can only appeal your own warnings.", ephemeral=True)
            return
            
        if warning['appeal_status'] != 'none':
            await ctx.send("This warning already has an appeal status.", ephemeral=True)
            return
            
        try:
            # Update warning appeal status
            if guild_id_str in self.warnings:
                for w in self.warnings[guild_id_str]:
                    if w['case_id'] == case_id:
                        w['appeal_text'] = appeal_text
                        w['appeal_status'] = 'pending'
                        break
                self._save_warnings()
            
            await ctx.send("Your appeal has been submitted.")
            
            # Log action
            await self._log_mod_action(
                ctx.guild.id, "Warning Appeal", ctx.author.id, 
                ctx.author.id, f"Appealed case #{case_id}", case_id
            )
        except Exception as e:
            logging.error(f"Failed to submit appeal: {e}")
            await ctx.send("Failed to submit appeal.", ephemeral=True)
    
    @commands.hybrid_command(name="resolveappeal")
    @commands.has_permissions(manage_messages=True)
    async def resolve_appeal(self, ctx, case_id: int, decision: str, *, reason: str = "No reason provided"):
        """Resolve a warning appeal (approve/deny)"""
        if decision not in ['approve', 'deny']:
            await ctx.send("Decision must be 'approve' or 'deny'.", ephemeral=True)
            return
            
        guild_id_str = str(ctx.guild.id)
        warning = self._get_warning_by_case(case_id, ctx.guild.id)
        if not warning:
            await ctx.send("No warning found with that case ID.", ephemeral=True)
            return
            
        if warning['appeal_status'] != 'pending':
            await ctx.send("This warning does not have a pending appeal.", ephemeral=True)
            return
            
        try:
            # Update warning appeal status
            if guild_id_str in self.warnings:
                for w in self.warnings[guild_id_str]:
                    if w['case_id'] == case_id:
                        w['appeal_status'] = decision
                        break
                self._save_warnings()
            
            status_text = "approved" if decision == "approve" else "denied"
            await ctx.send(f"Appeal for warning #{case_id} has been {status_text}.")
            
            # Notify user
            user = ctx.guild.get_member(warning['user_id'])
            if user:
                try:
                    await user.send(
                        f"Your appeal for warning #{case_id} has been {status_text}.\n"
                        f"Reason: {reason}"
                    )
                except discord.Forbidden:
                    pass  # Can't DM user
                    
            # Log action
            await self._log_mod_action(
                ctx.guild.id, f"Appeal {status_text.title()}", ctx.author.id, 
                warning['user_id'], reason, case_id
            )
        except Exception as e:
            logging.error(f"Failed to resolve appeal: {e}")
            await ctx.send("Failed to resolve appeal.", ephemeral=True)
    
    @commands.hybrid_command(name="exportwarns")
    @commands.has_permissions(administrator=True)
    async def export_warnings(self, ctx, member: Optional[discord.Member] = None):
        """Export warnings to CSV"""
        target = member or ctx.author
        warnings = self._get_warnings(target.id, ctx.guild.id, active_only=False)
        
        if not warnings:
            await ctx.send(f"{target.mention} has no warnings to export.")
            return
            
        # Create CSV
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['Case ID', 'User ID', 'Moderator ID', 'Reason', 'Type', 
                        'Timestamp', 'Appeal Status', 'Expiry Date', 'Expired'])
        
        for warning in warnings:
            writer.writerow([
                warning['case_id'],
                target.id,
                warning['moderator_id'],
                warning['reason'],
                warning['warning_type'],
                warning['timestamp'],
                warning['appeal_status'],
                warning['expiry_date'] or '',
                warning['expired']
            ])
            
        output.seek(0)
        buffer = io.BytesIO(output.getvalue().encode())
        buffer.name = f"warnings_{target.id}.csv"
        
        await ctx.send(
            f"Exported {len(warnings)} warnings for {target}",
            file=discord.File(buffer, filename=buffer.name)
        )
    
    @commands.hybrid_command(name="warnconfig")
    @commands.has_permissions(administrator=True)
    async def config_warnings(self, ctx, setting: str, value: str):
        """Configure warning system settings"""
        valid_settings = ['dm_users', 'auto_moderation', 'log_channel_id', 'escalate_3_warns', 'escalate_5_warns']
        if setting not in valid_settings:
            await ctx.send(f"Valid settings: {', '.join(valid_settings)}", ephemeral=True)
            return
            
        try:
            guild_id_str = str(ctx.guild.id)
            if guild_id_str not in self.config:
                self.config[guild_id_str] = {}
            
            # Update setting
            if setting == 'log_channel_id':
                try:
                    channel_id = int(value)
                    channel = ctx.guild.get_channel(channel_id)
                    if not channel:
                        await ctx.send("Invalid channel ID.", ephemeral=True)
                        return
                except ValueError:
                    await ctx.send("Channel ID must be a number.", ephemeral=True)
                    return
                    
                self.config[guild_id_str]['log_channel_id'] = channel_id
            elif setting in ['dm_users', 'auto_moderation', 'escalate_3_warns', 'escalate_5_warns']:
                bool_value = value.lower() in ['true', '1', 'yes', 'on']
                self.config[guild_id_str][setting] = bool_value
                
            self._save_config()
            await ctx.send(f"Setting `{setting}` updated to `{value}`.")
        except Exception as e:
            logging.error(f"Failed to update config: {e}")
            await ctx.send("Failed to update configuration.", ephemeral=True)
    
    @commands.hybrid_command(name="warnstats")
    @commands.has_permissions(manage_messages=True)
    async def warning_stats(self, ctx):
        """Show server warning statistics"""
        try:
            guild_id_str = str(ctx.guild.id)
            guild_warnings = self.warnings.get(guild_id_str, [])
            
            # Total warnings
            total = len(guild_warnings)
            
            # Active warnings
            active = len([w for w in guild_warnings if not w.get('expired', False)])
            
            # Top moderators
            mod_counts = {}
            for warning in guild_warnings:
                mod_id = warning['moderator_id']
                mod_counts[mod_id] = mod_counts.get(mod_id, 0) + 1
            
            top_mods = sorted(mod_counts.items(), key=lambda x: x[1], reverse=True)[:5]
            
            # Warning types
            type_counts = {}
            for warning in guild_warnings:
                w_type = warning['warning_type']
                type_counts[w_type] = type_counts.get(w_type, 0) + 1
            
            top_types = sorted(type_counts.items(), key=lambda x: x[1], reverse=True)[:5]
            
            embed = discord.Embed(
                title="Warning Statistics",
                color=discord.Color.blue()
            )
            embed.add_field(name="Total Warnings", value=str(total), inline=True)
            embed.add_field(name="Active Warnings", value=str(active), inline=True)
            embed.add_field(name="Expired Warnings", value=str(max(0, total-active)), inline=True)
            
            if top_mods:
                mod_list = []
                for mod_id, count in top_mods:
                    moderator = ctx.guild.get_member(mod_id)
                    mod_list.append(f"{moderator or 'Unknown'}: {count}")
                embed.add_field(name="Top Moderators", value="\n".join(mod_list[:5]), inline=False)
                
            if top_types:
                type_list = [f"{w_type.title()}: {count}" for w_type, count in top_types[:5]]
                embed.add_field(name="Warning Types", value="\n".join(type_list), inline=False)
                
            await ctx.send(embed=embed)
        except Exception as e:
            logging.error(f"Failed to get warning stats: {e}")
            await ctx.send("Failed to retrieve statistics.", ephemeral=True)

# Make sure the setup function accepts both parameters
async def setup(bot, db=None):
    await bot.add_cog(WarningSystem(bot, db))


FILE: cogs\welcome_general.py
----------------------------------------
# cogs/welcome_general.py
#
# Handles:
#   â€¢ on_member_join   â€“ add â€œUncompleted applicationâ€ role + public welcome
#   â€¢ on_member_remove â€“ announce leave / kick
#   â€¢ on_member_ban    â€“ announce ban
#
# NOTE: The existing cog `cogs/welcome_member.py` (accepted-member welcome)
#       stays unchanged â€“ its listeners will run in parallel.

from __future__ import annotations

import contextlib
import logging
from typing import Optional

import discord
from discord.ext import commands

log = logging.getLogger("cog.welcome_general")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ constants (copy from main) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GUILD_ID                = 1377035207777194005
WELCOME_CHANNEL_ID      = 1398659438960971876
APPLICATION_CH_ID       = 1378081331686412468
UNCOMPLETED_APP_ROLE_ID = 1390143545066917931
LEAVE_BAN_CH_ID         = 1404955868054814761
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


class WelcomeGeneralCog(commands.Cog):
    """Public join / leave / ban announcements (not accepted-member welcome)."""

    def __init__(self, bot: commands.Bot):
        self.bot = bot

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helper: deduplicate welcomes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    async def _clean_old_welcomes(
        channel: discord.TextChannel,
        member: discord.Member,
        marker: str = "ğŸ‘‹ **Welcome",
    ):
        seen: list[discord.Message] = []
        async for msg in channel.history(limit=20):
            if (
                msg.author == channel.guild.me
                and marker in msg.content
                and member.mention in msg.content
            ):
                seen.append(msg)

        if len(seen) > 1:
            seen.sort(key=lambda m: m.created_at, reverse=True)
            for old in seen[1:]:
                with contextlib.suppress(Exception):
                    await old.delete()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ on_member_join â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        # ignore other guilds & bots
        if member.bot or member.guild.id != GUILD_ID:
            return

        guild = member.guild
        welcome_ch: Optional[discord.TextChannel] = guild.get_channel(WELCOME_CHANNEL_ID)  # type: ignore
        apply_ch  : Optional[discord.TextChannel] = guild.get_channel(APPLICATION_CH_ID)   # type: ignore

        # 1) add â€œUncompleted applicationâ€ role
        role = guild.get_role(UNCOMPLETED_APP_ROLE_ID)
        if role and role not in member.roles:
            try:
                await member.add_roles(role, reason="Joined â€“ application not started")
            except discord.Forbidden:
                log.warning("[welcome] Can't add role to %s", member)
            except Exception as exc:
                log.exception("[welcome] Error adding role: %s", exc)

        # 2) send public welcome
        if welcome_ch and apply_ch:
            txt = (
                f"ğŸ‘‹ **Welcome {member.mention}!**\n"
                f"To join CTFO, please run **`/memberform`** "
                f"in {apply_ch.mention} and fill out the quick application.\n"
                "If you have any questions, just ask a mod.  Enjoy your stay!"
            )
            try:
                await welcome_ch.send(txt)
            except Exception as exc:
                log.warning("[welcome] Failed to send message: %s", exc)

            # 3) delete duplicate welcomes
            try:
                await self._clean_old_welcomes(welcome_ch, member)
            except Exception as exc:
                log.debug("[welcome] Dedup error: %s", exc)
        else:
            log.info("[welcome] Welcome or application channel missing.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ on_member_remove â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_member_remove(self, member: discord.Member):
        if member.guild.id != GUILD_ID:
            return
        ch: Optional[discord.TextChannel] = member.guild.get_channel(LEAVE_BAN_CH_ID)  # type: ignore
        if ch:
            await ch.send(f"ğŸ‘‹ **{member}** has left the server.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ on_member_ban â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener()
    async def on_member_ban(self, guild: discord.Guild, user: discord.User):
        if guild.id != GUILD_ID:
            return
        ch: Optional[discord.TextChannel] = guild.get_channel(LEAVE_BAN_CH_ID)  # type: ignore
        if ch:
            await ch.send(f"â›” **{user}** has been banned from the server.")


# â•â•â•â•â•â•â•â•â•â•â•â•â• setup entry point â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, _db=None):
    await bot.add_cog(WelcomeGeneralCog(bot))


FILE: cogs\welcome_member.py
----------------------------------------
# cogs/welcome_member.py
from __future__ import annotations
import asyncio

import discord
from discord.ext import commands

WELCOME_CHANNEL_ID = 1421881846240645302   # ğŸ‘ˆ change if needed
WELCOME_MARKER     = "**Welcome to CTFO!**"      # used for deduplication

class WelcomeMember(commands.Cog):
    """Send the big welcome message when a member form is accepted."""

    def __init__(self, bot: commands.Bot):
        self.bot = bot

    # ---------------------------------------------------------
    # helper: delete older duplicates so only one welcome stays
    # ---------------------------------------------------------
    async def _dedupe(self, channel: discord.TextChannel, member: discord.Member):
        dupes = []
        async for msg in channel.history(limit=25):
            if (
                msg.author == channel.guild.me
                and WELCOME_MARKER in msg.content
                and member.mention in msg.content
            ):
                dupes.append(msg)

        if len(dupes) > 1:
            dupes.sort(key=lambda m: m.created_at, reverse=True)
            for m in dupes[1:]:
                try:
                    await m.delete()
                except Exception:
                    pass

    # ---------------------------------------------------------
    # core: send the message
    # ---------------------------------------------------------
    async def _send_welcome(self, member: discord.Member):
        channel: discord.TextChannel | None = member.guild.get_channel(WELCOME_CHANNEL_ID)
        if channel is None:
            return

        msg = (
            f"{member.mention}\n\n"
            "**Welcome to CTFO!**\n\n"
            "We're glad to have you here. Please take a moment to review the important "
            "information below to help you get started:\n\n"
            "**Basic Information:**\n"
            "- **Codes:** Codes may be shared in VC, but please avoid posting them in text channels.\n"
            "- **Base & Bag:** Join a VC to receive base location and a bag.\n"
            "- **Getting Started:** Once accepted, feel free to hop on at any time!\n"
            "- **Questions or Help:** If you have any questions or get stuck, please "
            "reach out to a staff member.\n"
            "- **Security Reminder:** For safety, do not discuss server details or "
            "clan matters in public channels.\n\n"
            "**Important Channels:**\n"
            "- <#1401604218711838893> **Current Server Information**\n"
            "- <#1403891526844551228> **Loot Thread - for any loot obtained you wish to share**\n"
            "- <#1414663176666222673> **In-Game Names - Make sure to post yours to avoid any confusion**\n"
            "- <#1413929735658016899> **Giveaways - Automatic entry for active members**\n"
            "- <#1416559771103924415> **Clan Guidelines & Support**\n"
            "- <#1421945592522739824> **Quotas - To improve clan progress and help with motivation**\n"
            "- <#1422698527342989322> **To-Do Lists - To help keep members busy and more informed**"

        )

        await channel.send(
            msg,
            allowed_mentions=discord.AllowedMentions(users=True, roles=False)
        )
        await self._dedupe(channel, member)

    # ---------------------------------------------------------
    # listener for the custom event weâ€™ll dispatch in ActionView
    # ---------------------------------------------------------
    @commands.Cog.listener()
    async def on_member_form_accepted(self, member: discord.Member):
        await self._send_welcome(member)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ setup() hook â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def setup(bot, db):              # db arg kept for symmetry, not used
    await bot.add_cog(WelcomeMember(bot))


FILE: cogs\xp.py
----------------------------------------
"""
cogs.xp â€“ v2.2
==============

Full XP / levelling system for *discord.py*.

Changes in v2.2
---------------
â€¢ New level-up embed: nicer layout, gradient colour, percentage sits
  directly next to the progress bar.
"""

from __future__ import annotations

import contextlib
import math
import random
import textwrap
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Tuple

import colorsys
import discord
from discord import app_commands
from discord.ext import commands, tasks

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MSG_COOLDOWN_S = 45
MIN_CHARS = 5
MSG_XP_RANGE = (15, 25)

VOICE_XP_PER_MIN = 5
VOICE_TICK_SECONDS = 60

STREAK_BASE = 10
STREAK_PER_DAY = 5

LEADERBOARD_SIZE = 10
DECAY_AFTER_DAYS = 7
DECAY_FACTOR = 0.99
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EMBED HELPERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def _hsv_gradient(level: int) -> discord.Colour:
    """Return a pleasant hue that drifts as the level increases."""
    hue_deg = (level * 3) % 360  # 3Â° hue shift per level
    r, g, b = colorsys.hsv_to_rgb(hue_deg / 360, 0.65, 0.90)
    return discord.Colour.from_rgb(int(r * 255), int(g * 255), int(b * 255))


def build_levelup_embed(
    member: discord.Member, *, level: int, current_xp: int, next_level_xp: int
) -> discord.Embed:
    pct = current_xp / next_level_xp
    bar_len = 10
    bar = "â–°" * int(pct * bar_len) + "â–±" * (bar_len - int(pct * bar_len))
    percent_txt = f"{pct*100:4.1f}%"

    embed = discord.Embed(
        title=f"ğŸ‰  Level {level} unlocked!",
        description=f"{member.mention} reached a new level!",
        colour=_hsv_gradient(level),
        timestamp=datetime.now(timezone.utc),
    )
    embed.set_author(name=member.display_name, icon_url=member.display_avatar.url)
    embed.add_field(name="Current XP", value=f"{current_xp:,}", inline=True)
    embed.add_field(name="Next level XP", value=f"{next_level_xp:,}", inline=True)
    embed.add_field(
        name="Progress", value=f"{bar} **`{percent_txt}`**", inline=False
    )
    embed.set_footer(
        text="Keep chatting and hanging out in voice to earn more XP!"
    )
    return embed


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class XPCog(commands.Cog):
    def __init__(self, bot: commands.Bot, db):
        self.bot, self.db = bot, db
        self.voice_sessions: Dict[Tuple[int, int], datetime] = {}

        self._voice_tick.start()
        self._decay_loop.start()
        self._boost_watch.start()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ maths & db helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @staticmethod
    def level_from_xp(xp: int) -> int:
        return int(0.1 * math.sqrt(xp))

    @staticmethod
    def xp_for_next(level: int) -> int:
        return int(((level + 1) / 0.1) ** 2)

    async def _chan_mult(self, gid: int, cid: int) -> float:
        row = await self.db.fetch_one(
            "SELECT mult FROM xp_channel_mult WHERE guild_id=$1 AND channel_id=$2",
            gid,
            cid,
        )
        return float(row["mult"]) if row else 1.0

    async def _guild_boost(self, gid: int) -> float:
        row = await self.db.fetch_one(
            "SELECT multiplier, ends_at FROM xp_boosts WHERE guild_id=$1", gid
        )
        if not row or row["ends_at"] < datetime.now(timezone.utc):
            return 1.0
        return float(row["multiplier"])

    async def _lvl_channel_id(self, gid: int) -> Optional[int]:
        row = await self.db.fetch_one(
            "SELECT channel_id FROM xp_levelup_channel WHERE guild_id=$1", gid
        )
        return row["channel_id"] if row else None

    async def _voice_excluded(self, gid: int, cid: int) -> bool:
        return (
            await self.db.fetch_one(
                "SELECT 1 FROM xp_voice_excluded WHERE guild_id=$1 AND channel_id=$2",
                gid,
                cid,
            )
            is not None
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TEXT XP LISTENER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener("on_message")
    async def _text_xp(self, m: discord.Message):
        if m.author.bot or m.guild is None or len(m.content) < MIN_CHARS:
            return

        gid, uid, now = m.guild.id, m.author.id, datetime.now(timezone.utc)
        rec = await self.db.fetch_one(
            "SELECT xp, level, last_msg, streak FROM xp_members "
            "WHERE guild_id=$1 AND user_id=$2",
            gid,
            uid,
        )

        if rec and rec["last_msg"]:
            if (now - rec["last_msg"]).total_seconds() < MSG_COOLDOWN_S:
                return

        base = random.randint(*MSG_XP_RANGE)
        base = int(
            base
            * await self._chan_mult(gid, m.channel.id)
            * await self._guild_boost(gid)
        )

        streak, bonus = (rec["streak"] if rec else 0), 0
        if rec and rec["last_msg"]:
            gap = (now.date() - rec["last_msg"].date()).days
            if gap == 1:
                streak += 1
                bonus = STREAK_BASE + streak * STREAK_PER_DAY
            elif gap > 1:
                streak = 1
        else:
            streak = 1

        delta = base + bonus
        new_xp = delta + (rec["xp"] if rec else 0)
        new_lvl = self.level_from_xp(new_xp)
        old_lvl = rec["level"] if rec else 0

        await self.db.execute(
            """
            INSERT INTO xp_members (guild_id,user_id,xp,level,last_msg,streak)
            VALUES ($1,$2,$3,$4,$5,$6)
            ON CONFLICT (guild_id,user_id)
            DO UPDATE SET xp=$3, level=$4, last_msg=$5, streak=$6
            """,
            gid,
            uid,
            new_xp,
            new_lvl,
            now,
            streak,
        )
        await self.db.execute(
            "INSERT INTO xp_log (guild_id,user_id,delta,reason) "
            "VALUES ($1,$2,$3,'message')",
            gid,
            uid,
            delta,
        )

        if new_lvl > old_lvl:
            await self._announce_level_up(m.author, new_lvl, m.channel)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ VOICE XP TRACKING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @commands.Cog.listener("on_voice_state_update")
    async def _voice_state(self, m: discord.Member, before, after):
        key = (m.guild.id, m.id)

        # leaving / switching out of an included room
        if before.channel and key in self.voice_sessions:
            mins = int(
                (
                    datetime.now(timezone.utc) - self.voice_sessions.pop(key)
                ).total_seconds()
                / 60
            )
            if mins:
                await self._grant_voice_xp(m, mins)

        # joined / switched into an included room
        if after.channel and not await self._voice_excluded(
            m.guild.id, after.channel.id
        ):
            self.voice_sessions[key] = datetime.now(timezone.utc)

    async def _grant_voice_xp(self, m: discord.Member, mins: int):
        if mins <= 0:
            return

        delta = int(
            mins * VOICE_XP_PER_MIN * await self._guild_boost(m.guild.id)
        )
        rec = await self.db.fetch_one(
            "SELECT xp, level FROM xp_members WHERE guild_id=$1 AND user_id=$2",
            m.guild.id,
            m.id,
        )
        new_xp = delta + (rec["xp"] if rec else 0)
        new_lvl = self.level_from_xp(new_xp)
        old_lvl = rec["level"] if rec else 0

        await self.db.execute(
            """
            INSERT INTO xp_members (guild_id,user_id,xp,level,last_msg)
            VALUES ($1,$2,$3,$4,$5)
            ON CONFLICT (guild_id,user_id) DO UPDATE SET xp=$3, level=$4
            """,
            m.guild.id,
            m.id,
            new_xp,
            new_lvl,
            datetime.now(timezone.utc),
        )
        await self.db.execute(
            "INSERT INTO xp_log (guild_id,user_id,delta,reason) "
            "VALUES ($1,$2,$3,'voice')",
            m.guild.id,
            m.id,
            delta,
        )

        if new_lvl > old_lvl:
            chan = next(
                (
                    c
                    for c in m.guild.text_channels
                    if c.permissions_for(m.guild.me).send_messages
                ),
                None,
            )
            if chan:
                await self._announce_level_up(m, new_lvl, chan)

    @tasks.loop(seconds=VOICE_TICK_SECONDS)
    async def _voice_tick(self):
        now = datetime.now(timezone.utc)
        for (gid, uid), last in list(self.voice_sessions.items()):
            mins = int((now - last).total_seconds() / 60)
            if mins <= 0:
                continue

            guild = self.bot.get_guild(gid)
            member = guild and guild.get_member(uid)
            if not member or not member.voice:
                self.voice_sessions.pop((gid, uid), None)
                continue

            if await self._voice_excluded(gid, member.voice.channel.id):
                self.voice_sessions.pop((gid, uid), None)
                continue

            await self._grant_voice_xp(member, mins)
            self.voice_sessions[(gid, uid)] = now

    @_voice_tick.before_loop
    async def _voice_ready(self):
        await self.bot.wait_until_ready()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LEVEL UP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _announce_level_up(
        self,
        member: discord.Member,
        level: int,
        origin_channel: discord.TextChannel,
    ):
        # get current XP for the embed
        rec = await self.db.fetch_one(
            "SELECT xp FROM xp_members WHERE guild_id=$1 AND user_id=$2",
            member.guild.id,
            member.id,
        )
        current_xp = rec["xp"] if rec else 0
        next_xp = self.xp_for_next(level)

        embed = build_levelup_embed(
            member,
            level=level,
            current_xp=current_xp,
            next_level_xp=next_xp,
        )

        # role rewards
        rows = await self.db.fetch_all(
            "SELECT role_id FROM xp_roles WHERE guild_id=$1 AND min_level <= $2",
            member.guild.id,
            level,
        )
        for r in rows:
            role = member.guild.get_role(r["role_id"])
            if role and role not in member.roles:
                with contextlib.suppress(discord.Forbidden):
                    await member.add_roles(role, reason="XP reward")

        pub_id = await self._lvl_channel_id(member.guild.id)
        if pub_id:
            pub = member.guild.get_channel(pub_id)
            if isinstance(pub, discord.TextChannel):
                with contextlib.suppress(discord.Forbidden):
                    await pub.send(embed=embed)

        try:
            await member.send(embed=embed)
        except discord.Forbidden:
            with contextlib.suppress(discord.Forbidden):
                await origin_channel.send(member.mention, embed=embed)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ USER COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @app_commands.command(name="rank", description="Show your level / XP")
    async def rank(
        self, inter: discord.Interaction, member: Optional[discord.Member] = None
    ):
        member = member or inter.user
        rec = await self.db.fetch_one(
            "SELECT xp, level, streak FROM xp_members "
            "WHERE guild_id=$1 AND user_id=$2",
            inter.guild.id,
            member.id,
        )
        if not rec:
            return await inter.response.send_message(
                f"{member.mention} has no XP yet.", ephemeral=True
            )

        next_xp = self.xp_for_next(rec["level"])
        pct = rec["xp"] / next_xp
        bar = "â–°" * int(pct * 10) + "â–±" * (10 - int(pct * 10))

        embed = discord.Embed(
            title=f"Rank for {member.display_name}",
            colour=discord.Colour.dark_embed(),
            description=textwrap.dedent(
                f"""
                Level **{rec['level']}**
                XP **{rec['xp']} / {next_xp}**
                {bar} **`{pct*100:4.1f}%`**
                Daily streak **{rec['streak']}**
                """
            ),
        ).set_thumbnail(url=member.display_avatar.url)
        await inter.response.send_message(embed=embed)

    @app_commands.command(name="leaderboard", description="Top XP users")
    async def leaderboard(
        self,
        inter: discord.Interaction,
        length: app_commands.Range[int, 1, 25] = LEADERBOARD_SIZE,
    ):
        rows = await self.db.fetch_all(
            "SELECT user_id, xp, level FROM xp_members "
            "WHERE guild_id=$1 ORDER BY xp DESC LIMIT $2",
            inter.guild.id,
            length,
        )
        if not rows:
            return await inter.response.send_message(
                "Nobody has XP yet.", ephemeral=True
            )

        lines = []
        for rank, r in enumerate(rows, 1):
            user = inter.guild.get_member(r["user_id"]) or f"<@{r['user_id']}>"
            lines.append(
                f"`#{rank:02}` **{user}** â€” L{r['level']} ({r['xp']} XP)"
            )

        embed = discord.Embed(
            title=f"Top {len(rows)} â€” {inter.guild.name}",
            description="\n".join(lines),
            colour=discord.Colour.blurple(),
            timestamp=datetime.now(timezone.utc),
        )
        await inter.response.send_message(embed=embed)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ADMIN SUB-GROUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    xp_admin = app_commands.Group(
        name="xpadmin", description="XP admin tools", guild_only=True
    )

    # multiplier
    @xp_admin.command(
        name="multiplier", description="Set per-channel XP multiplier (0-5)"
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    async def adm_multiplier(
        self,
        inter: discord.Interaction,
        channel: discord.TextChannel,
        value: app_commands.Range[float, 0, 5],
    ):
        await self.db.execute(
            """
            INSERT INTO xp_channel_mult (guild_id,channel_id,mult)
            VALUES ($1,$2,$3)
            ON CONFLICT (guild_id,channel_id) DO UPDATE SET mult=$3
            """,
            inter.guild.id,
            channel.id,
            value,
        )
        await inter.response.send_message(
            f"Multiplier for {channel.mention} set to Ã—{value}."
        )

    # grantrole
    @xp_admin.command(
        name="grantrole",
        description="Auto-grant a role once a member reaches a level",
    )
    @app_commands.checks.has_permissions(manage_roles=True)
    async def adm_grantrole(
        self,
        inter: discord.Interaction,
        role: discord.Role,
        min_level: app_commands.Range[int, 1, 200],
    ):
        await self.db.execute(
            """
            INSERT INTO xp_roles (guild_id,role_id,min_level)
            VALUES ($1,$2,$3)
            ON CONFLICT (guild_id,role_id) DO UPDATE SET min_level=$3
            """,
            inter.guild.id,
            role.id,
            min_level,
        )
        await inter.response.send_message(
            f"{role.mention} will now be granted at level {min_level}."
        )

    # level-up channel
    @xp_admin.command(
        name="setlevelupchannel",
        description="Set the channel where level-up cards are posted",
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    async def adm_set_lvl_channel(
        self, inter: discord.Interaction, channel: discord.TextChannel
    ):
        await self.db.execute(
            """
            INSERT INTO xp_levelup_channel (guild_id,channel_id)
            VALUES ($1,$2)
            ON CONFLICT (guild_id) DO UPDATE SET channel_id=$2
            """,
            inter.guild.id,
            channel.id,
        )
        await inter.response.send_message(
            f"Level-up cards will be posted in {channel.mention}."
        )

    # boost
    @xp_admin.command(
        name="boost", description="Activate a temporary global XP boost"
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    @app_commands.describe(
        multiplier="Boost factor (1-10)",
        minutes="Duration (1-1440)",
        announce_channel="Where to announce (defaults to current)",
        message="Optional extra text",
    )
    async def adm_boost(
        self,
        inter: discord.Interaction,
        multiplier: app_commands.Range[float, 1.0, 10.0],
        minutes: app_commands.Range[int, 1, 1440],
        announce_channel: Optional[discord.TextChannel] = None,
        message: Optional[str] = None,
    ):
        ends = datetime.now(timezone.utc) + timedelta(minutes=minutes)

        await self.db.execute(
            """
            INSERT INTO xp_boosts (guild_id,multiplier,ends_at,message,
                                   announce_channel_id,announce_msg_id)
            VALUES ($1,$2,$3,$4,NULL,NULL)
            ON CONFLICT (guild_id) DO UPDATE
            SET multiplier=$2, ends_at=$3, message=$4,
                announce_channel_id=NULL, announce_msg_id=NULL
            """,
            inter.guild.id,
            multiplier,
            ends,
            message,
        )

        ch = announce_channel or inter.channel
        emb = discord.Embed(
            title="ğŸš€ XP BOOST ACTIVE",
            description=f"All XP gains are multiplied by **Ã—{multiplier}** "
            f"for the next **{minutes} minutes**!",
            colour=discord.Colour.gold(),
            timestamp=datetime.now(timezone.utc),
        )
        if message:
            emb.add_field(name="Info", value=message, inline=False)

        msg = await ch.send(embed=emb)

        await self.db.execute(
            """
            UPDATE xp_boosts
            SET announce_channel_id=$1, announce_msg_id=$2
            WHERE guild_id=$3
            """,
            ch.id,
            msg.id,
            inter.guild.id,
        )
        await inter.response.send_message("Boost activated!", ephemeral=True)

    # exclude
    @xp_admin.command(
        name="exclude",
        description="Enable / disable XP in a text or voice channel",
    )
    @app_commands.checks.has_permissions(manage_guild=True)
    @app_commands.describe(
        channel="Channel to toggle",
        enabled="True = enable XP, False = disable (default)",
    )
    async def adm_exclude(
        self,
        inter: discord.Interaction,
        channel: discord.abc.GuildChannel,
        enabled: bool = False,
    ):
        if isinstance(channel, discord.TextChannel):
            if enabled:
                await self.db.execute(
                    "DELETE FROM xp_channel_mult WHERE guild_id=$1 AND channel_id=$2",
                    inter.guild.id,
                    channel.id,
                )
            else:
                await self.db.execute(
                    """
                    INSERT INTO xp_channel_mult (guild_id,channel_id,mult)
                    VALUES ($1,$2,0.0)
                    ON CONFLICT (guild_id,channel_id) DO UPDATE SET mult=0.0
                    """,
                    inter.guild.id,
                    channel.id,
                )
        elif isinstance(channel, discord.VoiceChannel):
            if enabled:
                await self.db.execute(
                    "DELETE FROM xp_voice_excluded WHERE guild_id=$1 AND channel_id=$2",
                    inter.guild.id,
                    channel.id,
                )
            else:
                await self.db.execute(
                    """
                    INSERT INTO xp_voice_excluded (guild_id,channel_id)
                    VALUES ($1,$2)
                    ON CONFLICT DO NOTHING
                    """,
                    inter.guild.id,
                    channel.id,
                )
        else:
            return await inter.response.send_message(
                "Unsupported channel type.", ephemeral=True
            )

        state = "enabled" if enabled else "disabled"
        await inter.response.send_message(f"XP {state} in {channel.mention}.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BACKGROUND MAINTENANCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    @tasks.loop(hours=24)
    async def _decay_loop(self):
        cutoff = datetime.now(timezone.utc) - timedelta(days=DECAY_AFTER_DAYS)
        await self.db.execute(
            "UPDATE xp_members SET xp=floor(xp*$1) WHERE last_msg<$2",
            DECAY_FACTOR,
            cutoff,
        )

    @_decay_loop.before_loop
    async def _decay_ready(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=1)
    async def _boost_watch(self):
        rows = await self.db.fetch_all(
            "SELECT guild_id,announce_channel_id,announce_msg_id "
            "FROM xp_boosts WHERE ends_at < $1",
            datetime.now(timezone.utc),
        )
        for r in rows:
            g = self.bot.get_guild(r["guild_id"])
            ch = g and g.get_channel(r["announce_channel_id"])
            if isinstance(ch, discord.TextChannel) and r["announce_msg_id"]:
                with contextlib.suppress(Exception):
                    msg = await ch.fetch_message(r["announce_msg_id"])
                    await msg.edit(content="ğŸŸ¢ Boost ended.", embed=None)
        if rows:
            await self.db.execute(
                "DELETE FROM xp_boosts WHERE ends_at < $1",
                datetime.now(timezone.utc),
            )

    @_boost_watch.before_loop
    async def _boost_ready(self):
        await self.bot.wait_until_ready()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ graceful unload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def cog_unload(self):
        self._voice_tick.cancel()
        self._decay_loop.cancel()
        self._boost_watch.cancel()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXTENSION ENTRY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def setup(bot: commands.Bot, db):
    cog = XPCog(bot, db)
    await bot.add_cog(cog)
    if bot.tree.get_command("xpadmin") is None:
        bot.tree.add_command(cog.xp_admin)


FILE: ctfobot2_0.py
----------------------------------------
# ctfobot2_0.py â€“ CTFO Discord bot (core launcher)
# =================================================
from __future__ import annotations

import asyncio
import logging
import os
import sys
from importlib import import_module
from types import ModuleType
from typing import Sequence

import discord
from discord.ext import commands
from dotenv import load_dotenv

from db import Database

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ log / env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-8s | %(name)s | %(message)s",
    stream=sys.stdout,
    force=True,
)

BOT_TOKEN: str | None = os.getenv("BOT_TOKEN")
DATABASE_URL: str | None = os.getenv("DATABASE_URL")
if not BOT_TOKEN or not DATABASE_URL:
    raise RuntimeError("Set BOT_TOKEN and DATABASE_URL in .env!")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ database â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db = Database(DATABASE_URL)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ shared constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GUILD_ID = int(os.getenv("GUILD_ID", "1377035207777194005"))

WELCOME_CHANNEL_ID      = 1398659438960971876
APPLICATION_CH_ID       = 1378081331686412468
UNCOMPLETED_APP_ROLE_ID = 1390143545066917931
COMPLETED_APP_ROLE_ID   = 1398708167525011568
ACCEPT_ROLE_ID          = 1377075930144571452

REGION_ROLE_IDS = {
    "North America": 1411364406096433212,
    "Europe":        1411364744484491287,
    "Asia":          1411364982117105684,
    "Other":         1411365034440921260,
}
FOCUS_ROLE_IDS = {
    "Farming":      1379918816871448686,
    "Base Sorting": 1400849292524130405,
    "Building":     1380233086544908428,
    "Electricity":  1380233234675400875,
    "PvP":          1408687710159245362,
}

TEMP_BAN_SECONDS  = 7 * 24 * 60 * 60
GIVEAWAY_ROLE_ID  = 1403337937722019931
GIVEAWAY_CH_ID    = 1413929735658016899
EMBED_TITLE       = "ğŸ‰ GIVEAWAY ğŸ‰"

ADMIN_ID        = 1377103244089622719
ELECTRICIAN_ID  = 1380233234675400875
GROUP_LEADER_ID = 1377077466513932338
PLAYER_MGMT_ID  = 1377084533706588201
TRUSTED_ID      = 1400584430900219935

CODE_NAMES = ["Master", "Guest", "Electrician", "Other"]

STAFF_BONUS_ROLE_IDS = {
    ADMIN_ID,
    GROUP_LEADER_ID,
    PLAYER_MGMT_ID,
    1410659214959054988,  # recruitment
}

BOOST_BONUS_PER_WEEK = 3
STAFF_BONUS_PER_WEEK = 3
STREAK_BONUS_PER_SET = 3

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ bot instance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
intents = discord.Intents.default()
intents.members = True
intents.messages = True
intents.message_content = True  # needed for XP + moderation

bot = commands.Bot(command_prefix="!", intents=intents)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ slash-cmd error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.tree.error
async def app_command_error(inter: discord.Interaction, err: Exception):
    logging.error("Slash-cmd error: %s â€“ %s", type(err).__name__, err)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ on_ready (sync) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.event
async def on_ready() -> None:
    logging.info("Logged in as %s (%s)", bot.user, bot.user.id)

    guild = discord.Object(id=GUILD_ID)
    bot.tree.copy_global_to(guild=guild)
    await bot.tree.sync(guild=guild)
    logging.info("Slash-commands synced for guild %s", GUILD_ID)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helper: cog loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def load_cogs(bot_: commands.Bot, db_: Database, paths: Sequence[str]) -> None:
    for dotted in paths:
        try:
            module: ModuleType = import_module(dotted)
            if not hasattr(module, "setup"):
                logging.warning("Module %s has no setup() â€“ skipped", dotted)
                continue
            await module.setup(bot_, db_)
            logging.info("Loaded cog %s", dotted)
        except Exception:
            logging.exception("Failed to load cog %s", dotted)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ main runner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def _run_bot() -> None:
    await db.connect()                      # 1) DB
    await load_cogs(                        # 2) Cogs
        bot,
        db,
        (
            "cogs.giveaways",
            "cogs.stay_or_go",
            "cogs.member_forms",
            "cogs.staff_applications",
            "cogs.stats",
            "cogs.recruit_reminder",
            "cogs.welcome_general",
            "cogs.welcome_member",
            "cogs.quota",
            "cogs.todo",
            "cogs.feedback",
            "cogs.codes",
            "cogs.warnings",
            "cogs.xp",                      # XP system
            "cogs.steam_sync",
        ),
    )
    await bot.start(BOT_TOKEN)              # 3) live

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ entry-point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main() -> None:
    try:
        asyncio.run(_run_bot())
    except KeyboardInterrupt:
        logging.info("Bot stopped by user")
    finally:
        # Close the DB pool cleanly
        try:
            asyncio.run(db.close())  # type: ignore[arg-type]
        except RuntimeError:
            # event-loop already closed (windows quirk)
            pass


if __name__ == "__main__":
    main()


FILE: db.py
----------------------------------------
# db.py â€“ central async-pg helper for CTFO bot
# ===============================================================
# Last update: 2024-10-08
#
# â€¢ generic helpers  fetch_one / fetch_all / execute / close
# â€¢ full XP-system schema (xp_members, xp_boosts, â€¦)
# â€¢ keeps **all** previously-public methods unchanged
#
# Tips:
#   await db.connect()   â†’ open pool + run migrations
#   await db.close()     â†’ graceful shutdown
# ===============================================================
from __future__ import annotations

import json
from typing import Any, Dict, List, Sequence, Set, Optional

import asyncpg


class Database:
    """Thin wrapper around an async-pg pool + convenience helpers."""

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # INIT / POOL
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def __init__(self, dsn: str) -> None:
        self.dsn = dsn
        self.pool: asyncpg.Pool | None = None

    async def connect(self) -> None:
        """Open pool and run idempotent migrations."""
        self.pool = await asyncpg.create_pool(self.dsn, min_size=1, max_size=5)
        await self._init_tables()

    async def close(self) -> None:
        """Gracefully close the connection-pool (call on shutdown)."""
        if self.pool and not self.pool.closed:
            await self.pool.close()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # GENERIC SMALL HELPERS  (used by newer cogs)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def fetch_one(self, sql: str, *args) -> Dict[str, Any] | None:
        """Return first row as dict or None."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            row = await conn.fetchrow(sql, *args)
            return dict(row) if row else None

    async def fetch_all(self, sql: str, *args) -> List[Dict[str, Any]]:
        """Return all rows as list[dict]."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            rows: Sequence[asyncpg.Record] = await conn.fetch(sql, *args)
            return [dict(r) for r in rows]

    async def execute(self, sql: str, *args) -> None:
        """Run statement that does not return rows."""
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            await conn.execute(sql, *args)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # MIGRATIONS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _init_tables(self) -> None:
        async with self.pool.acquire() as conn:       # type: ignore[arg-type]
            await conn.execute(
                """
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Core / legacy tables â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE TABLE IF NOT EXISTS codes (
    name   TEXT PRIMARY KEY,
    pin    VARCHAR(4) NOT NULL,
    public BOOLEAN     NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS reviewers ( user_id BIGINT PRIMARY KEY );

CREATE TABLE IF NOT EXISTS activity (
    user_id BIGINT PRIMARY KEY,
    streak  INTEGER,
    date    DATE,
    warned  BOOLEAN,
    last    TIMESTAMP
);

CREATE TABLE IF NOT EXISTS giveaways (
    id         SERIAL PRIMARY KEY,
    channel_id BIGINT,
    message_id BIGINT,
    prize      TEXT,
    start_ts   BIGINT,
    end_ts     BIGINT,
    active     BOOLEAN,
    note       TEXT
);
ALTER TABLE giveaways ADD COLUMN IF NOT EXISTS start_ts BIGINT;
ALTER TABLE giveaways ADD COLUMN IF NOT EXISTS note TEXT;

CREATE TABLE IF NOT EXISTS member_forms (
    id         SERIAL PRIMARY KEY,
    user_id    BIGINT,
    created_at TIMESTAMP DEFAULT now(),
    data       JSONB,
    status     TEXT NOT NULL DEFAULT 'pending',
    message_id BIGINT,
    region     TEXT,
    focus      TEXT
);

CREATE TABLE IF NOT EXISTS staff_applications (
    id         SERIAL PRIMARY KEY,
    user_id    BIGINT,
    role       TEXT,
    message_id BIGINT,
    status     TEXT NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS inactive_members (
    user_id  BIGINT PRIMARY KEY,
    until_ts BIGINT
);

CREATE TABLE IF NOT EXISTS exempt_users ( user_id BIGINT PRIMARY KEY );

CREATE TABLE IF NOT EXISTS activity_audit (
    id SERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    event_type VARCHAR(32) NOT NULL,
    timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
    details TEXT
);

CREATE TABLE IF NOT EXISTS todo_tasks (
    id          SERIAL PRIMARY KEY,
    guild_id    BIGINT,
    creator_id  BIGINT,
    description TEXT      NOT NULL,
    max_claims  INTEGER   NOT NULL DEFAULT 0,
    claimed     BIGINT[]  NOT NULL DEFAULT '{}',
    message_id  BIGINT,
    completed   BOOLEAN   NOT NULL DEFAULT FALSE,
    created_at  TIMESTAMP NOT NULL DEFAULT NOW()
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Feedback tables â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE TABLE IF NOT EXISTS anon_feedback_cooldown (
    user_id BIGINT PRIMARY KEY,
    last_ts TIMESTAMPTZ NOT NULL
);

CREATE TABLE IF NOT EXISTS feedback (
    id              SERIAL PRIMARY KEY,
    msg_id          BIGINT      NOT NULL,
    author_id       BIGINT      NOT NULL,   -- 0 == anonymous
    category        TEXT,
    target_id       BIGINT,
    text            TEXT,
    rating          INT,
    attachment_urls TEXT[],
    status          TEXT        NOT NULL DEFAULT 'Open',
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• XP system (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE TABLE IF NOT EXISTS xp_members (
    guild_id BIGINT NOT NULL,
    user_id  BIGINT NOT NULL,
    xp       BIGINT  NOT NULL DEFAULT 0,
    level    INTEGER NOT NULL DEFAULT 0,
    last_msg TIMESTAMPTZ,
    streak   INTEGER NOT NULL DEFAULT 0,
    voice_secs BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, user_id)
);

CREATE INDEX IF NOT EXISTS xp_members_xp_idx
          ON xp_members (guild_id, xp DESC);

CREATE TABLE IF NOT EXISTS xp_log (
    id       BIGSERIAL PRIMARY KEY,
    guild_id BIGINT NOT NULL,
    user_id  BIGINT NOT NULL,
    delta    INTEGER NOT NULL,
    reason   TEXT,
    ts       TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS xp_channel_mult (
    guild_id  BIGINT NOT NULL,
    channel_id BIGINT NOT NULL,
    mult      NUMERIC(4,2) NOT NULL DEFAULT 1.0,
    PRIMARY KEY (guild_id, channel_id)
);

CREATE TABLE IF NOT EXISTS xp_roles (
    guild_id BIGINT NOT NULL,
    role_id  BIGINT NOT NULL,
    min_level INTEGER NOT NULL,
    PRIMARY KEY (guild_id, role_id)
);

CREATE TABLE IF NOT EXISTS xp_levelup_channel (
    guild_id   BIGINT PRIMARY KEY,
    channel_id BIGINT NOT NULL
);

CREATE TABLE IF NOT EXISTS xp_boosts (
    guild_id            BIGINT PRIMARY KEY,
    multiplier          NUMERIC(4,2) NOT NULL,
    ends_at             TIMESTAMPTZ  NOT NULL,
    message             TEXT,
    announce_channel_id BIGINT,
    announce_msg_id     BIGINT
);

CREATE TABLE IF NOT EXISTS xp_voice_excluded (
    guild_id   BIGINT NOT NULL,
    channel_id BIGINT NOT NULL,
    PRIMARY KEY (guild_id, channel_id)
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Steam links (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE TABLE IF NOT EXISTS steam_links (
    discord_id BIGINT PRIMARY KEY,
    steam_id64 VARCHAR(17) NOT NULL
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Steam-Sync cooldown (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE TABLE IF NOT EXISTS steam_ping_cooldown (
    discord_id BIGINT PRIMARY KEY,
    last_ts    TIMESTAMPTZ NOT NULL
);

"""
            )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CODES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def get_codes(self, *, only_public: bool = False) -> Dict[str, tuple[str, bool]]:
        q = "SELECT name, pin, public FROM codes"
        if only_public:
            q += " WHERE public=TRUE"
        q += " ORDER BY name"
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(q)
            return {r["name"]: (r["pin"], r["public"]) for r in rows}

    async def add_code(self, name: str, pin: str, public: bool):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO codes (name, pin, public)
                VALUES ($1,$2,$3)
                ON CONFLICT(name) DO UPDATE SET pin=$2, public=$3
                """,
                name,
                pin,
                public,
            )

    async def edit_code(self, name: str, pin: str, public: bool | None = None):
        async with self.pool.acquire() as conn:
            if public is None:
                await conn.execute("UPDATE codes SET pin=$2 WHERE name=$1", name, pin)
            else:
                await conn.execute(
                    "UPDATE codes SET pin=$2, public=$3 WHERE name=$1",
                    name,
                    pin,
                    public,
                )

    async def remove_code(self, name: str):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM codes WHERE name=$1", name)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REVIEWERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def get_reviewers(self) -> Set[int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT user_id FROM reviewers")
            return {r["user_id"] for r in rows}

    async def add_reviewer(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO reviewers (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
                uid,
            )

    async def remove_reviewer(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM reviewers WHERE user_id=$1", uid)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTIVITY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def get_activity(self, uid: int) -> Dict[str, Any] | None:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM activity WHERE user_id=$1", uid)
            return dict(row) if row else None

    async def set_activity(self, uid, streak, date_, warned, last):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO activity (user_id, streak, date, warned, last)
                VALUES ($1,$2,$3,$4,$5)
                ON CONFLICT(user_id) DO UPDATE
                  SET streak=$2, date=$3, warned=$4, last=$5
                """,
                uid,
                streak,
                date_,
                warned,
                last,
            )

    async def get_all_activity(self) -> Dict[int, Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT * FROM activity")
            return {r["user_id"]: dict(r) for r in rows}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INACTIVE MEMBERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def add_inactive(self, uid: int, until_ts: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO inactive_members (user_id, until_ts)
                VALUES ($1,$2)
                ON CONFLICT(user_id) DO UPDATE SET until_ts=$2
                """,
                uid,
                until_ts,
            )

    async def remove_inactive(self, uid: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM inactive_members WHERE user_id=$1", uid)

    async def get_expired_inactive(self, now_ts: int) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT * FROM inactive_members WHERE until_ts <= $1", now_ts
            )
            return [dict(r) for r in rows]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MEMBER FORMS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def add_member_form(self, uid, data: dict, message_id: int | None = None):
        async with self.pool.acquire() as conn:
            d = json.loads(json.dumps(data))  # ensure JSON-serialisable
            await conn.execute(
                """
                INSERT INTO member_forms (user_id, data, region, focus, message_id, status)
                VALUES ($1,$2,$3,$4,$5,'pending')
                """,
                uid,
                json.dumps(d),
                d.get("region"),
                d.get("focus"),
                message_id,
            )

    async def update_member_form_status(self, message_id: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE member_forms SET status=$1 WHERE message_id=$2",
                status,
                message_id,
            )

    async def get_pending_member_forms(self) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM member_forms
                WHERE status='pending' AND message_id IS NOT NULL
                """
            )
            return [dict(r) for r in rows]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STAFF APPLICATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def add_staff_app(self, uid: int, role: str, msg_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO staff_applications (user_id, role, message_id)
                VALUES ($1,$2,$3)
                """,
                uid,
                role,
                msg_id,
            )

    async def update_staff_app_status(self, msg_id: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE staff_applications SET status=$1 WHERE message_id=$2",
                status,
                msg_id,
            )

    async def get_pending_staff_apps(self) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT * FROM staff_applications WHERE status='pending'"
            )
            return [dict(r) for r in rows]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTIVITY EXEMPT / AUDIT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def add_exempt_user(self, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO exempt_users (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
                user_id,
            )

    async def remove_exempt_user(self, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM exempt_users WHERE user_id=$1", user_id)

    async def get_exempt_users(self) -> Set[int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("SELECT user_id FROM exempt_users")
            return {r["user_id"] for r in rows}

    async def log_activity_event(self, user_id: int, event_type: str, details: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO activity_audit (user_id, event_type, details)
                VALUES ($1,$2,$3)
                """,
                user_id,
                event_type,
                details,
            )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TO-DO LIST â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def add_todo(
        self,
        guild_id: int,
        creator_id: int,
        description: str,
        max_claims: int,
        message_id: int,
    ):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO todo_tasks
                  (guild_id, creator_id, description,
                   max_claims, message_id)
                VALUES ($1,$2,$3,$4,$5)
                """,
                guild_id,
                creator_id,
                description,
                max_claims,
                message_id,
            )

    async def list_open_todos(self, guild_id: int) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT * FROM todo_tasks
                 WHERE guild_id=$1 AND completed=FALSE
                 ORDER BY id
                """,
                guild_id,
            )
            return [dict(r) for r in rows]

    async def claim_todo(self, task_id: int, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE todo_tasks
                   SET claimed = array_append(claimed, $2)
                 WHERE id=$1
                   AND completed=FALSE
                   AND NOT (claimed @> ARRAY[$2])
                   AND (max_claims=0 OR array_length(claimed,1) < max_claims)
                """,
                task_id,
                user_id,
            )

    async def unclaim_todo(self, task_id: int, user_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE todo_tasks
                   SET claimed = array_remove(claimed, $2)
                 WHERE id=$1 AND completed=FALSE
                """,
                task_id,
                user_id,
            )

    async def complete_todo(self, task_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE todo_tasks SET completed=TRUE WHERE id=$1", task_id
            )

    async def remove_todo(self, task_id: int):
        async with self.pool.acquire() as conn:
            await conn.execute("DELETE FROM todo_tasks WHERE id=$1", task_id)

    async def count_open_claims(self, guild_id: int, user_id: int) -> int:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT COUNT(*) AS n
                  FROM todo_tasks
                 WHERE guild_id=$1
                   AND completed=FALSE
                   AND $2 = ANY(claimed)
                """,
                guild_id,
                user_id,
            )
        return row["n"] if row else 0

    async def todo_bonus_map(self, guild_id: int) -> Dict[int, int]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT claimed FROM todo_tasks
                 WHERE guild_id=$1
                   AND completed=FALSE
                   AND max_claims>0
                """,
                guild_id,
            )
        bonus: Dict[int, int] = {}
        for r in rows:
            for uid in r["claimed"]:
                bonus[uid] = min(3, bonus.get(uid, 0) + 1)
        return bonus

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FEEDBACK (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # -- anon cooldown --
    async def get_last_anon_ts(self, user_id: int):
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT last_ts FROM anon_feedback_cooldown WHERE user_id=$1",
                user_id,
            )
            return row["last_ts"] if row else None

    async def set_last_anon_ts(self, user_id: int, ts):
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO anon_feedback_cooldown (user_id, last_ts)
                VALUES ($1,$2)
                ON CONFLICT (user_id) DO UPDATE SET last_ts=$2
                """,
                user_id,
                ts,
            )

    # -- record feedback --
    async def record_feedback(
        self,
        *,
        msg_id: int,
        author_id: int,
        category: str,
        target_id: int | None,
        text: str,
        rating: int | None,
        attachment_urls: list[str] | None,
    ) -> int:
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO feedback
                  (msg_id, author_id, category, target_id,
                   text, rating, attachment_urls)
                VALUES ($1,$2,$3,$4,$5,$6,$7)
                RETURNING id
                """,
                msg_id,
                author_id,
                category,
                target_id,
                text,
                rating,
                attachment_urls,
            )
        return row["id"]

    async def update_feedback_status(self, fid: int, status: str):
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE feedback SET status=$2 WHERE id=$1",
                fid,
                status,
            )

    async def list_feedback_by_author(
        self, author_id: int, limit: int = 25
    ) -> List[Dict[str, Any]]:
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT id, created_at, category, status
                  FROM feedback
                 WHERE author_id=$1
                 ORDER BY id DESC
                 LIMIT $2
                """,
                author_id,
                limit,
            )
            return [dict(r) for r in rows]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEAM LINKS (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def get_steam_id(self, discord_id: int) -> Optional[str]:
        """Return the linked 64-bit Steam-ID or None if none stored."""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT steam_id64 FROM steam_links WHERE discord_id = $1",
                discord_id,
            )
            return row["steam_id64"] if row else None

    async def set_steam_id(self, discord_id: int, steam_id: str) -> None:
        """Store / overwrite the Steam-ID for a Discord user."""
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO steam_links (discord_id, steam_id64)
                VALUES ($1, $2)
                ON CONFLICT (discord_id) DO UPDATE
                  SET steam_id64 = EXCLUDED.steam_id64
                """,
                discord_id,
                steam_id,
            )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEAM SYNC (NEW) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async def get_last_steam_ping(self, discord_id: int):
        """Return datetime of the last DM reminder or None."""
        row = await self.fetch_one(
            "SELECT last_ts FROM steam_ping_cooldown WHERE discord_id=$1",
            discord_id,
        )
        return row["last_ts"] if row else None

    async def set_last_steam_ping(self, discord_id: int):
        """Upsert NOW() as the last DM timestamp."""
        await self.execute(
            """
            INSERT INTO steam_ping_cooldown (discord_id, last_ts)
            VALUES ($1, NOW())
            ON CONFLICT (discord_id) DO UPDATE SET last_ts = NOW()
            """,
            discord_id,
        )


FILE: nixpacks.toml
----------------------------------------
# Forces Python 3.11 (default may eventually change)
[build]
pythonVersion = "3.11"



FILE: railway.json
----------------------------------------
{
  "build": {
    "builder": "NIXPACKS"
  },

  "volumes": [
    {
      "name": "data",
      "mountPath": "/data",
      "sizeGb": 1
    }
  ]
}



FILE: requirements.txt
----------------------------------------
discord.py[voice]>=2.3.2,<3.0
python-dotenv>=1.0
asyncpg
fastapi
uvicorn
jinja2
python-multipart
itsdangerous>=2.1
httpx
passlib[bcrypt]>=1.7.4
bcrypt<4.0
cachetools==5.3.2
requests


FILE: static\css\style.css
----------------------------------------
/* CTFO Dark theme & Neon accents */
:root {
  --bg:   #121212;        /* dark grey */
  --card: #1e1e1e;        /* card surface */

  /* new accent colours */
  --neon:      #ff2e2e;   /* vibrant red */
  --neon-glow: #ff8c0045; /* translucent orange glow */

  --ctfo-bg:        #0e0e0f;
  --ctfo-panel:     #1a1a1c;
  --ctfo-border:    #262629;
  --ctfo-red:       #ff3030;
  --ctfo-green:     #2ecc71;
  --ctfo-amber:     #f1c40f;
  --ctfo-yellow:    #f1c40f;
  --ctfo-blue:      #2980b9;

  --bs-body-bg:     var(--ctfo-bg);      /* override bootstrap var */
  --bs-body-color:  #ddd;
}

html,body {
  height: 100%;
  background: var(--bg);
  color: #fff;
  font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
}
body { background: var(--ctfo-bg); color: var(--bs-body-color); }

/* Navbar --------------------------------------------------- */
.navbar-brand,
.nav-link,
.navbar-text { color: #eee !important; }

.navbar-brand {
  font-weight: 700;
  letter-spacing: 1px;
  color: var(--neon) !important;
  text-shadow: 0 0 6px var(--neon), 0 0 12px var(--neon-glow);
}

/* Neon Button ---------------------------------------------- */
.neon-btn {
  background: var(--neon);
  border: none;
  color: #fff;
  font-weight: 600;
  box-shadow: 0 0 10px var(--neon), 0 0 4px var(--neon-glow);
  transition: transform .15s;
}
.neon-btn:hover {
  transform: translateY(-2px);
  background: var(--neon);
  box-shadow: 0 0 15px var(--neon), 0 0 6px var(--neon-glow);
}
.neon-btn:active { transform: translateY(0); }

/* Cards / lists -------------------------------------------- */
.card {
  background: var(--card);
  border: none;
  box-shadow: 0 0 12px #000 inset, 0 0 6px var(--neon-glow);
  border-radius: 14px;
}
.list-group-item {
  background: #272727;
  border: none;
  color: #eee;
}
.badge-priv {
  background: #f0ad4e;
}

/* Utilities ------------------------------------------------- */
.center-vh {
  min-height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Accordion / Panel (member forms) -------------------------- */
.accordion-item {
    background: var(--ctfo-panel);
    border: 1px solid var(--ctfo-border);
    border-radius: .35rem;
}
.accordion-button {
    background: var(--ctfo-panel);
    color: #ddd;
    padding: .6rem 1rem;
}
.accordion-button:not(.collapsed) {
    background: var(--ctfo-panel);
    box-shadow: inset 0 -1px 0 rgba(255,255,255,.05);
}
.accordion-button::after { filter: invert(90%); }  /* arrow icon */

.badge-status {
    width: 22px; height: 22px; display: inline-flex;
    align-items: center; justify-content: center;
    font-size: .85rem; border-radius: 50%;
}
.badge-pending  { background: var(--ctfo-amber); }
.badge-accepted { background: var(--ctfo-green); }
.badge-denied   { background: var(--ctfo-red);   }

textarea.form-control {
    background: #111215;
    color: #eee;
    border: 1px solid var(--ctfo-border);
}

.btn-primary  { background: var(--ctfo-blue);   border: none; }
.btn-success  { background: var(--ctfo-green);  border: none; }
.btn-warning  { background: var(--ctfo-amber);  border: none; color:#000; }
.btn-danger   { background: var(--ctfo-red);    border: none; }

.btn-primary:disabled,
.btn-warning:disabled {
    opacity: .4;
}

/* make bottom padding so last item doesn't hug footer */
#formAcc { padding-bottom: 1rem; }

/* DataTables/Member Forms custom styles --------------------- */
.table thead{background:#121216;}
table.dataTable tbody td,
table.dataTable thead th{color:#fff !important;}

td.details-control{cursor:pointer;text-align:center;width:28px;}
td.details-control i{color:var(--ctfo-red);filter:drop-shadow(0 0 3px var(--ctfo-red));
                     transition:transform .25s;}
tr.shown td.details-control i{transform:rotate(90deg);}

/* status badge (DataTable size) */
.badge-status{width:26px;height:26px;display:flex;align-items:center;justify-content:center;
              border-radius:50%;font-size:.8rem;}
.badge-pending {background:var(--ctfo-yellow);}
.badge-accepted{background:var(--ctfo-green);}
.badge-denied  {background:var(--ctfo-red);box-shadow:0 0 6px var(--ctfo-red);}

/* buttons for DataTable actions */
.btn-success{background:var(--ctfo-green);border:0;}        /* green accept */
.btn-warning{background:var(--ctfo-yellow);border:0;color:#000;}
.btn-danger {background:var(--ctfo-red);border:0;box-shadow:0 0 6px rgba(255,48,48,.5);}
.btn:disabled{opacity:.35!important;}

/* DataTables search / length controls */
.dataTables_wrapper .form-select,
.dataTables_wrapper .dataTables_filter input{background:#1c1c1f;border:1px solid #444;color:#fff;}

/* child row -----------------------------------------------------*/
tr.child td{background:transparent;border:0;padding:0 !important;}

.child-panel{
  width:100%;box-sizing:border-box;
  background:var(--ctfo-panel);
  border-left:4px solid var(--ctfo-red);
  box-shadow:0 0 8px rgba(255,48,48,.6);

  margin-top:10px;                       /* gap reduced to 10 px */
  padding:1.2rem 1.4rem 1.2rem 70px;     /* indent clears caret+badge */
}
.field-card .label{
  font-size:.72rem;text-transform:uppercase;color:#ccc;letter-spacing:.4px;
}
.field-card .label i{color:#ccc;}
.field-card .value{
  font-weight:600;color:var(--ctfo-red);text-shadow:0 0 5px var(--ctfo-red);
  word-break:break-word;
}

/* Responsive tweaks ------------------------------------------ */
@media (max-width: 991px){
  .child-panel .col-lg-3 { flex: 0 0 50%; max-width: 50%; }
}
@media (max-width: 575px){
  .child-panel .col-6, .child-panel .col-lg-3 { flex: 0 0 100%; max-width: 100%; }
}


FILE: templates\admin.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Admin Panel | CTFO{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.8/css/dataTables.bootstrap5.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
{% endblock %}

{% block content %}
<section class="container py-5">

  <!-- Tabs -->
  <ul class="nav nav-tabs mb-4">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#codes">Codes</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#forms">Member&nbsp;Forms</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#giveaways">Giveaways</button></li>
  </ul>

  <div class="tab-content">

    <!-- CODES -->
    <div class="tab-pane fade show active" id="codes">
      {% include "partials/admin_codes.html" %}
    </div>

    <!-- MEMBER FORMS: DataTable -->
    <div class="tab-pane fade" id="forms">
      <table id="formsTable" class="table table-striped align-middle w-100">
        <thead>
          <tr>
            <th></th>
            <th>Status</th>
            <th>ID</th>
            <th>User&nbsp;ID</th>
            <th>Created</th>
            <th style="width:110px;">Actions</th>
          </tr>
        </thead>
        <tbody>
          {% if forms %}
            {% for f in forms %}
              {% set badge =
                'badge-pending'  if f.status=='pending' else
                'badge-accepted' if f.status=='accepted' else
                'badge-denied'   %}
              <tr data-form='{{ f.data|tojson | safe }}'>
                <td class="details-control"><i class="fa-solid fa-caret-right fa-lg"></i></td>
                <td>
                  <span class="badge-status {{badge}}">
                    {% if f.status=='pending' %}<i class="fa fa-hourglass-half"></i>
                    {% elif f.status=='accepted' %}<i class="fa fa-check"></i>
                    {% else %}<i class="fa fa-ban"></i>{% endif %}
                  </span>
                </td>
                <td>{{f.id}}</td>
                <td>{{f.user_id}}</td>
                <td>
                  {% if f.created_at %}
                    {{ f.created_at.strftime('%Y-%m-%d %H:%M') }}
                  {% else %}
                    N/A
                  {% endif %}
                </td>
                <td class="d-flex gap-1">
                  <button class="btn btn-sm btn-success action-btn" data-id="{{f.id}}" data-action="accept"
                    {% if f.status!='pending' %}disabled{% endif %}>
                    <i class="fa fa-check"></i>
                  </button>
                  <button class="btn btn-sm btn-warning action-btn" data-id="{{f.id}}" data-action="deny"
                    {% if f.status!='pending' %}disabled{% endif %}>
                    <i class="fa fa-ban"></i>
                  </button>
                  <button class="btn btn-sm btn-danger action-btn" data-id="{{f.id}}" data-action="delete">
                    <i class="fa fa-trash"></i>
                  </button>
                </td>
              </tr>
            {% endfor %}
          {% else %}
            <tr>
              <td colspan="6" class="text-center text-muted">No member forms stored.</td>
            </tr>
          {% endif %}
        </tbody>
      </table>
    </div>

    <!-- GIVEAWAYS -->
    <div class="tab-pane fade" id="giveaways">
      {% if gws %}
        <div class="table-responsive">
          <table class="table table-dark table-striped align-middle">
            <thead>
              <tr><th>ID</th><th>Prize</th><th>Ends&nbsp;(unix)</th><th>Active?</th><th>Note</th><th>Actions</th></tr>
            </thead>
            <tbody>
              {% for g in gws %}
                <tr>
                  <form method="post" action="/giveaways/update">
                    <td><code>{{ g.id }}</code></td>
                    <td><input name="prize" class="form-control form-control-sm" value="{{ g.prize }}"></td>
                    <td><input name="end_ts" class="form-control form-control-sm" type="number" value="{{ g.end_ts }}"></td>
                    <td>{{ 'âœ…' if g.active else 'â›”' }}</td>
                    <td><input name="note" class="form-control form-control-sm" value="{{ g.note or '' }}"></td>
                    <td class="d-flex gap-2">
                      <input type="hidden" name="id" value="{{ g.id }}">
                      <button class="btn btn-sm btn-success">Save</button>
                  </form>
                  <form method="post" action="/giveaways/end">
                      <input type="hidden" name="id" value="{{ g.id }}">
                      <button class="btn btn-sm btn-warning" {% if not g.active %}disabled{% endif %}>End</button>
                  </form>
                    </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      {% else %}
        <div class="alert alert-info">No giveaways yet.</div>
      {% endif %}
    </div>
  </div>

  <footer class="text-muted text-center mt-5">&copy; {{ year }} CTFO Gaming</footer>
</section>
{% endblock %}

{% block extra_js %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/dataTables.bootstrap5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js"></script>
<script>
const ICON = {
  age      :['fa-calendar',    'Age'],
  region   :['fa-globe',       'Region'],
  bans     :['fa-ban',         'Bans'],
  ban_explanation:['fa-note-sticky','Ban explanation'],
  focus    :['fa-bullseye',    'Focus'],
  skill    :['fa-star',        'Skill'],
  steam    :['fa-link',        'Steam'],
  hours    :['fa-clock',       'Hours'],
  heard    :['fa-bullhorn',    'Heard'],
  referral :['fa-handshake',   'Referral'],
  gender   :['fa-person',      'Gender']
};
const ORDER = [
  "steam", "age", "region", "bans", "ban_explanation", "focus",
  "skill", "hours", "heard", "referral", "gender"
];

function card(k, v) {
  const [ico, label] = ICON[k] ?? ['fa-circle-question', k];
  return `<div class="col-6 col-lg-3 field-card mb-3">
    <div class="label"><i class="fa ${ico} me-1"></i>${label}</div>
    <div class="value">${v ?? 'N/A'}</div>
  </div>`;
}
function makeChild(form_data) {
  let html = '<div class="child-panel row g-4">';
  for (const k of ORDER) if (k in form_data) html += card(k, form_data[k]);
  for (const k of Object.keys(form_data)) if (!ORDER.includes(k)) html += card(k, form_data[k]);
  return html + '</div>';
}

$(function() {
  const table = $('#formsTable').DataTable({
    order: [[2, 'desc']], pageLength: 25,
    columnDefs: [{targets:[0,1,5], orderable:false}]
  });

  $('#formsTable tbody').on('click','td.details-control',function(){
     const tr = $(this).closest('tr');
     const row = table.row(tr);
     const formData = JSON.parse(tr.attr('data-form') || '{}');
     row.child.isShown()
       ? (row.child.hide(), tr.removeClass('shown'))
       : (row.child(makeChild(formData)).show(), tr.addClass('shown'));
  });

  // AJAX actions for Accept/Deny/Delete
  $('#formsTable').on('click', '.action-btn', function() {
    const id = $(this).data('id');
    const action = $(this).data('action');
    if(!id || !action) return;
    let url = `/forms/${action}`;
    let btn = $(this);
    btn.prop('disabled', true);

    $.post(url, {id: id})
      .done(function(resp) {
        const row = btn.closest('tr');
        if(action === 'delete') {
          table.row(row).remove().draw();
        } else if(resp && resp.status) {
          // Update badge
          let badgeCell = row.find('td').eq(1).find('.badge-status');
          if(action === 'accept') {
            badgeCell.removeClass().addClass('badge-status badge-accepted').html('<i class="fa fa-check"></i>');
          } else if(action === 'deny') {
            badgeCell.removeClass().addClass('badge-status badge-denied').html('<i class="fa fa-ban"></i>');
          }
          // Disable all except delete button
          row.find('.action-btn').not('[data-action="delete"]').prop('disabled', true);
        } else if(resp && resp.error) {
          alert(resp.error);
          btn.prop('disabled', false);
        }
      })
      .fail(function(xhr) {
        let msg = "Error processing action.";
        if(xhr.responseJSON && xhr.responseJSON.error) msg = xhr.responseJSON.error;
        alert(msg);
        btn.prop('disabled', false);
      });
  });
});
</script>
{% endblock %}


FILE: templates\base.html
----------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{% block title %}CTFO{% endblock %}</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
        rel="stylesheet">
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/static/css/style.css">

  {% block extra_head %}{% endblock %}
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-black px-4">
    <a class="navbar-brand" href="/">CTFO</a>
    <button class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#nav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div id="nav" class="collapse navbar-collapse">
      <ul class="navbar-nav me-auto">
        <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
        {% if user %}
          <li class="nav-item"><a class="nav-link" href="/admin">Admin</a></li>
        {% endif %}
      </ul>
      <span class="navbar-text">
        {% if user %}
          Logged in as <strong>{{ user }}</strong> |
          <a href="/logout" class="nav-link d-inline p-0">Logout</a>
        {% else %}
          <a class="nav-link d-inline p-0" href="/login">Login</a>
        {% endif %}
      </span>
    </div>
  </nav>

  {% block content %}{% endblock %}

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  {% block extra_js %}{% endblock %}
</body>
</html>


FILE: templates\login.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Login | CTFO{% endblock %}

{% block content %}
<div class="center-vh">
  <div class="card p-4" style="width:360px">
    <h3 class="text-center mb-3" style="color:var(--neon)">Admin Login</h3>
    {% if pending %}
      <div class="alert alert-info">Account created! Waiting for owner approval.</div>
    {% endif %}
    <form method="post">
      <div class="mb-3">
        <input class="form-control" placeholder="Username" name="username" required>
      </div>
      <div class="mb-3">
        <input class="form-control" type="password" placeholder="Password" name="password" required>
      </div>
      <button class="neon-btn w-100 btn">Login</button>
    </form>
    <div class="mt-3 text-center">
      <a href="/signup">Need an account? Sign up</a>
    </div>
  </div>
</div>
{% endblock %}


FILE: templates\partials\admin_codes.html
----------------------------------------
<h2 class="mb-4" style="color:var(--neon)">Codes</h2>
<div class="card p-4 mx-auto" style="max-width:560px">
  {% if codes %}
    <ul class="list-group mb-4">
      {% for c in codes %}
        <li class="list-group-item d-flex justify-content-between align-items-center">
          <span>
            <strong>{{ c['name'] }}</strong> : <code>{{ c['pin'] }}</code>
            {% if not c['public'] %}
              <span class="badge badge-priv">priv</span>
            {% endif %}
          </span>
          <form method="post" action="/codes/remove" class="m-0">
            <input type="hidden" name="name" value="{{ c['name'] }}">
            <button class="btn btn-sm btn-outline-danger">Delete</button>
          </form>
        </li>
      {% endfor %}
    </ul>
  {% else %}
    <div class="alert alert-warning text-center">No codes yet.</div>
  {% endif %}

  <form class="row g-2 align-items-center" method="post" action="/codes/add">
    <div class="col-4"><input name="name" class="form-control" placeholder="Name" required></div>
    <div class="col-3"><input name="pin" class="form-control" placeholder="1234" pattern="\d{4}" required></div>
    <div class="col-3 form-check">
      <input class="form-check-input" type="checkbox" id="pub" name="public">
      <label class="form-check-label" for="pub">Public</label>
    </div>
    <div class="col-2 d-grid"><button class="neon-btn btn">Save</button></div>
  </form>
</div>


FILE: templates\signup.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Sign Up | CTFO Admin{% endblock %}

{% block content %}
<div class="center-vh">
  <div class="card p-4" style="width:360px">
    <h3 class="text-center mb-3" style="color:var(--neon)">Admin Sign-up</h3>
    <form method="post">
      <div class="mb-3">
        <input class="form-control" placeholder="Username" name="username" required>
      </div>
      <div class="mb-3">
        <input class="form-control" type="password" placeholder="Password" name="password" required>
      </div>
      <button class="neon-btn w-100 btn">Create Account</button>
    </form>
    <div class="mt-3 text-center">
      <a href="/login">Already have one? Login</a>
    </div>
  </div>
</div>
{% endblock %}


FILE: templates\welcome.html
----------------------------------------
{% extends "base.html" %}
{% block title %}Welcome | CTFO{% endblock %}

{% block content %}
<section class="container text-center py-5">
  <h1 class="display-4 mb-3"
      style="color:var(--neon);text-shadow:0 0 9px var(--neon);">
    Welcome to CTFO Gaming
  </h1>
  <p class="lead mb-4">Rust community focused on mega builds, PvP and good vibes.</p>

  <a href="https://discord.gg/YOUR_INVITE" class="btn neon-btn btn-lg mb-5">
    Join our Discord
  </a>

  <div class="row justify-content-center">
    <div class="col-md-6">
      <div class="card p-4">
        <h4 class="mb-2" style="color:var(--neon)">About Us</h4>
        <p>We are a tight-knit group of Rust players specialising in base
           design, electricity, farming and raids.  Apply today and find your new team.</p>
        <hr>
        <h5>Current Member Count</h5>
        <p class="display-6">{{ members }}</p>
      </div>
    </div>
  </div>

  <footer class="text-muted mt-5">&copy; {{ year }} CTFO Gaming</footer>
</section>
{% endblock %}


FILE: web.py
----------------------------------------
"""
FastAPI control-panel for CTFO bot
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Runs next to the Discord bot but as a separate Railway service.
â€¢ Importing ctfobot2_0 is safe because the bot starts only when
  botmod.main() is invoked (never at mere import).
"""

from __future__ import annotations

import os, json, datetime, asyncio, inspect, httpx, asyncpg
from pathlib import Path
from typing import Callable, Awaitable, Any

from itsdangerous import URLSafeSerializer, BadSignature
from passlib.context import CryptContext
from asyncpg import UniqueViolationError

from fastapi import (
    FastAPI,
    Request,
    Form,
    Response,
    HTTPException,
)
from fastapi.responses import RedirectResponse, HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

import discord

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  BOT  (import-safe thanks to guard in ctfobot2_0.py)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import ctfobot2_0 as botmod

BOT_TOKEN = botmod.BOT_TOKEN
GUILD_ID  = botmod.GUILD_ID

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  CONFIG
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is required for the web service")

WEB_SECRET  = os.getenv("WEB_SECRET", "CHANGE_ME")
OWNER_KEY   = os.getenv("OWNER_KEY",  "OWNER_ONLY")
COOKIE_NAME = "ctfo_admin"

pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")
signer  = URLSafeSerializer(WEB_SECRET)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  FASTAPI
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app       = FastAPI(debug=False)
templates = Jinja2Templates(directory="templates")

static_path = Path("static")
if static_path.is_dir():
    app.mount("/static", StaticFiles(directory=static_path), name="static")

db: asyncpg.Pool | None = None        # initialised on startup

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  HELPERS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def current_user(request: Request) -> str | None:
    """
    Return username stored in signed cookie **if** that user exists in DB
    and is approved; otherwise None.
    """
    if db is None:
        return None

    token = request.cookies.get(COOKIE_NAME)
    if not token:
        return None
    try:
        username = signer.loads(token)
    except BadSignature:
        return None

    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT username, approved FROM admins WHERE username=$1",
            username
        )
    return row["username"] if row and row["approved"] else None


def login_required(fn: Callable[..., Awaitable[Any]]):
    """
    Decorator that
      â€¢ verifies cookie,
      â€¢ redirects unauthenticated users to /login,
      â€¢ injects a `user` argument (str) into the endpoint.
    """
    sig      = inspect.signature(fn)
    params   = list(sig.parameters.values())

    async def wrapper(request: Request, *args, **kwargs):   # type: ignore
        user = await current_user(request)
        if not user:
            return RedirectResponse("/login", status_code=303)
        return await fn(request, user, *args, **kwargs)

    wrapper.__name__      = fn.__name__
    wrapper.__doc__       = fn.__doc__
    wrapper.__signature__ = inspect.Signature(
        parameters=[p for p in params if p.name != "user"]
    )
    return wrapper


def _build_role_list(guild: discord.Guild, data: dict[str, str]):
    roles: list[discord.Role] = []
    if (r := guild.get_role(botmod.ACCEPT_ROLE_ID)):                               roles.append(r)
    if (r := guild.get_role(botmod.REGION_ROLE_IDS.get(data.get("region"), 0))):   roles.append(r)
    if (r := guild.get_role(botmod.FOCUS_ROLE_IDS.get(data.get("focus"), 0))):     roles.append(r)
    return roles

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  START-UP  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.on_event("startup")
async def init_database():
    global db
    db = await asyncpg.create_pool(DATABASE_URL)
    async with db.acquire() as conn:
        await conn.execute("""
        CREATE TABLE IF NOT EXISTS admins (
            username TEXT PRIMARY KEY,
            pwd_hash TEXT NOT NULL,
            approved BOOLEAN NOT NULL DEFAULT FALSE
        );""")
        await conn.execute("""
        CREATE TABLE IF NOT EXISTS codes (
            name TEXT PRIMARY KEY,
            pin  TEXT NOT NULL,
            public BOOLEAN NOT NULL DEFAULT FALSE
        );""")
    print("[web] DB pool ready")


@app.on_event("startup")
async def launch_discord_bot():
    """
    Start the Discord bot in *this* process **only if** BOT_TOKEN is set.
    botmod.main() is synchronous; it schedules the async start coroutine
    on the already-running FastAPI loop.
    """
    if BOT_TOKEN:
        botmod.main()                        # no create_task needed
        print("[web] Discord bot task scheduled")


@app.on_event("shutdown")
async def stop_discord_bot():
    if not botmod.bot.is_closed():
        await botmod.bot.close()
        print("[web] Discord bot stopped")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  DATA QUERIES  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def all_admin_data():
    """Fetch codes, member_forms, giveaways for the admin dashboard."""
    async with db.acquire() as conn:
        codes = await conn.fetch("SELECT * FROM codes ORDER BY name")
        forms = await conn.fetch(
            "SELECT * FROM member_forms ORDER BY created_at DESC"
        )
        gws   = await conn.fetch(
            "SELECT * FROM giveaways ORDER BY end_ts DESC"
        )

    forms_parsed = []
    for rec in forms:
        d = dict(rec)
        if isinstance(d["data"], str):
            try:
                d["data"] = json.loads(d["data"])
            except json.JSONDecodeError:
                d["data"] = {}
        forms_parsed.append(d)
    return codes, forms_parsed, gws

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  PUBLIC PAGE  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.get("/", response_class=HTMLResponse)
async def welcome(request: Request):
    """Landing page that shows live guild member count via widget."""
    member_count = "?"
    try:
        async with httpx.AsyncClient() as cli:
            r = await cli.get(
                f"https://discord.com/api/guilds/{GUILD_ID}/widget.json",
                timeout=5
            )
            if r.status_code == 200:
                member_count = len(r.json()["members"])
    except Exception:
        pass

    return templates.TemplateResponse(
        "welcome.html",
        {
            "request": request,
            "year": datetime.datetime.now().year,
            "members": member_count,
        },
    )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  ADMIN PANEL  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.get("/admin", response_class=HTMLResponse)
@login_required
async def admin_panel(request: Request, user: str):
    codes, forms, gws = await all_admin_data()
    return templates.TemplateResponse(
        "admin.html",
        {
            "request": request,
            "codes": codes,
            "forms": forms,
            "gws":   gws,
            "user":  user,
            "year":  datetime.datetime.now().year,
        },
    )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  SIGN-UP / LOGIN  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async def _get_admin_row(username: str):
    async with db.acquire() as conn:
        return await conn.fetchrow(
            "SELECT * FROM admins WHERE username=$1", username
        )

@app.get("/signup", response_class=HTMLResponse)
async def signup_get(request: Request):
    return templates.TemplateResponse("signup.html", {"request": request})


@app.post("/signup")
async def signup_post(username: str = Form(...), password: str = Form(...)):
    hash_ = pwd_ctx.hash(password)
    async with db.acquire() as conn:
        try:
            await conn.execute(
                "INSERT INTO admins (username, pwd_hash) VALUES ($1,$2)",
                username, hash_
            )
        except UniqueViolationError:
            raise HTTPException(400, "Username already exists.")
    return RedirectResponse("/login?pending=1", status_code=303)


@app.get("/login", response_class=HTMLResponse)
async def login_get(request: Request, pending: int | None = None):
    return templates.TemplateResponse(
        "login.html", {"request": request, "pending": pending}
    )

@app.post("/login")
async def login_post(
    response: Response,
    username: str = Form(...),
    password: str = Form(...)
):
    row = await _get_admin_row(username)
    if (not row
            or not row["approved"]
            or not pwd_ctx.verify(password, row["pwd_hash"])):
        raise HTTPException(403, "Invalid credentials or not yet approved.")

    resp = RedirectResponse("/admin", status_code=303)
    resp.set_cookie(
        COOKIE_NAME, signer.dumps(username),
        httponly=True, max_age=7 * 86400
    )
    return resp

@app.get("/logout")
async def logout():
    resp = RedirectResponse("/", status_code=303)
    resp.delete_cookie(COOKIE_NAME)
    return resp

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  OWNER-ONLY ENDPOINT  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.post("/approve")
async def approve_user(request: Request, username: str = Form(...)):
    if request.headers.get("X-OWNER-KEY") != OWNER_KEY:
        raise HTTPException(403, "Bad owner key.")
    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE admins SET approved=TRUE WHERE username=$1", username
        )
    return "approved"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  CODE MANAGEMENT  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.post("/codes/add")
@login_required
async def add_code(
    request: Request,
    user: str,
    name: str = Form(...),
    pin: str  = Form(...),
    public: str | None = Form(None)
):
    if not (pin.isdigit() and len(pin) == 4):
        raise HTTPException(400, "Pin must be 4 digits.")
    async with db.acquire() as conn:
        await conn.execute("""
            INSERT INTO codes (name, pin, public)
            VALUES ($1,$2,$3)
            ON CONFLICT(name) DO UPDATE SET pin=$2, public=$3
        """, name, pin, public is not None)
    return RedirectResponse("/admin", status_code=303)


@app.post("/codes/remove")
@login_required
async def remove_code(request: Request, user: str, name: str = Form(...)):
    async with db.acquire() as conn:
        await conn.execute("DELETE FROM codes WHERE name=$1", name)
    return RedirectResponse("/admin", status_code=303)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  MEMBER-FORM CRUD  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.post("/forms/update")
@login_required
async def update_form(
    request: Request,
    user: str,
    id: int = Form(...),
    json_text: str = Form(..., alias="json")
):
    try:
        parsed = json.loads(json_text)
    except json.JSONDecodeError:
        raise HTTPException(400, "Not valid JSON.")

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET data=$2 WHERE id=$1",
            id, parsed
        )
    return JSONResponse({"status": "updated"})


@app.post("/forms/accept")
@login_required
async def accept_member(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT user_id, data, status FROM member_forms WHERE id=$1", id
        )
    if not row or row["status"] != "pending":
        raise HTTPException(400, "Form not found or already handled")

    data: dict = json.loads(row["data"]) if isinstance(row["data"], str) else row["data"]
    uid: int   = row["user_id"]

    guild = botmod.bot.get_guild(GUILD_ID)
    if not guild:
        raise HTTPException(503, "Discord bot not ready")

    try:
        member = await guild.fetch_member(uid)
    except discord.NotFound:
        raise HTTPException(404, "User left the guild")

    roles = _build_role_list(guild, data)
    if not roles:
        raise HTTPException(500, "Required roles missing in guild")
    await member.add_roles(*roles, reason=f"Accepted via web panel ({user})")

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET status='accepted' WHERE id=$1", id
        )
    return JSONResponse({"status": "accepted"})


@app.post("/forms/deny")
@login_required
async def deny_member(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT user_id, status FROM member_forms WHERE id=$1", id
        )
    if not row or row["status"] != "pending":
        raise HTTPException(400, "Form not found or already handled")

    uid: int = row["user_id"]
    guild    = botmod.bot.get_guild(GUILD_ID)
    if not guild:
        raise HTTPException(503, "Discord bot not ready")

    await guild.ban(
        discord.Object(id=uid),
        reason=f"Application denied via web panel by {user} (temp-ban)",
        delete_message_seconds=0
    )

    async def unban_later():
        await asyncio.sleep(botmod.TEMP_BAN_SECONDS)
        try:
            await guild.unban(discord.Object(id=uid), reason="Temp ban expired")
        except discord.HTTPException:
            pass
    asyncio.create_task(unban_later())

    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE member_forms SET status='denied' WHERE id=$1", id
        )
    return JSONResponse({"status": "denied"})


@app.post("/forms/delete")
@login_required
async def delete_form(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        await conn.execute("DELETE FROM member_forms WHERE id=$1", id)
    return JSONResponse({"status": "deleted"})

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  GIVEAWAYS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
@app.post("/giveaways/update")
@login_required
async def update_giveaway(
    request: Request,
    user: str,
    id: int = Form(...),
    prize: str = Form(...),
    end_ts: int = Form(...),
    note: str = Form("")
):
    async with db.acquire() as conn:
        await conn.execute("""
            UPDATE giveaways
               SET prize=$2, end_ts=$3, note=$4
             WHERE id=$1
        """, id, prize, end_ts, note)
    return RedirectResponse("/admin#giveaways", status_code=303)


@app.post("/giveaways/end")
@login_required
async def end_giveaway(request: Request, user: str, id: int = Form(...)):
    async with db.acquire() as conn:
        await conn.execute(
            "UPDATE giveaways SET active=FALSE WHERE id=$1", id
        )
    return RedirectResponse("/admin#giveaways", status_code=303)

